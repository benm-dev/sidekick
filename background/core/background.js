import { a as qe, b as Eb, c as Bb } from "../../chunk-SHCR74HD.js";
import { a as Hu, b as Lo, c as Db } from "../../chunk-OFC5237D.js";
import "../../chunk-ZLUD5SWZ.js";
import {
  a as Pr,
  b as Ky,
  c as dr,
  d as qy,
  g as D,
  h as Ks,
  i as eb,
  j as tb,
  l as ob,
  m as cb,
  n as pb,
  p as lb,
  q as ub,
  r as Mu,
  s as R,
} from "../../chunk-JGEHADN5.js";
import { a as A } from "../../chunk-5JS46TXG.js";
import { a as ee, b as ct, c as $y } from "../../chunk-RBMHFGWD.js";
import { a as hb } from "../../chunk-LMTCQCWT.js";
import {
  A as Oo,
  B as Wb,
  c as Wo,
  d as Xs,
  e as bb,
  f as Ie,
  g as Do,
  h as gb,
  i as Js,
  j as vb,
  k as Du,
  l as fb,
  m as Zs,
  n as ea,
  o as ta,
  p as Sb,
  r as Uo,
  s as Uu,
  t as wb,
  v as kb,
  w as qr,
  x as Ou,
  z as Tb,
} from "../../chunk-EVVMRBSW.js";
import { a as ia, b as oa, c as ju } from "../../chunk-PRJNHMLU.js";
import {
  H as Mo,
  I as sb,
  J as ab,
  K as mr,
  L as Er,
  R as db,
  S as Ri,
  a as _o,
} from "../../chunk-I3ILDBO5.js";
import { a as Ys } from "../../chunk-Q3TMK7K4.js";
import { a as ra, b as Gb } from "../../chunk-SD2LYQKA.js";
import "../../chunk-TA24QOID.js";
import {
  b as Nu,
  c as Cb,
  d as jo,
  e as Lu,
  f as _b,
  g as Fb,
  h as Mb,
  i as Gu,
  j as aa,
} from "../../chunk-L7L2JV5F.js";
import { a as Rb, b as Ee, c as zr, d as Ub } from "../../chunk-ZEHGPMWH.js";
import {
  a as Pt,
  b as Ib,
  c as Ab,
  d as Pb,
  g as sa,
  h as Nb,
} from "../../chunk-PDVOFPAZ.js";
import {
  a as xu,
  b as yb,
  c as Wu,
  d as P,
  f as No,
  g as xb,
  h as Ei,
  i as na,
  j as Bi,
  k as ca,
  l as pa,
  m as Ob,
  n as la,
  o as jb,
  p as Lb,
} from "../../chunk-MKPTDAGU.js";
import { a as me } from "../../chunk-XYG7YXOD.js";
import { l as lt, m as je } from "../../chunk-3ZYQDD7H.js";
import {
  A as Fo,
  B as Cu,
  C as Jy,
  E as Zy,
  F as Gt,
  I as xo,
  J as Ht,
  O as _u,
  P as qs,
  Q as At,
  R as Vt,
  T as rb,
  U as zs,
  X as Qs,
  _ as ib,
  a as Kr,
  aa as Fu,
  b as de,
  ba as nb,
  da as yt,
  ea as mb,
  i as zy,
  j as Bu,
  k as ce,
  l as Ue,
  n as ye,
  o as ur,
  p as Qy,
  q as xe,
  r as Pi,
  t as pt,
  u as Rr,
  v as $s,
  x as Yy,
  y as Xy,
} from "../../chunk-OBPWZYQZ.js";
import {
  a as l,
  b as fe,
  c as Ly,
  e as Ai,
  f as Gy,
  g as Hy,
  h as Ru,
  i as Eu,
  j as Gs,
  k as le,
  l as Vy,
  m as Hs,
  o as Vs,
} from "../../chunk-QGLCH3FC.js";
import { a as Oe } from "../../chunk-MQVGYSOB.js";
import {
  a as Ny,
  b as z,
  c as Bo,
  d as Ii,
  e as lr,
  f as c,
  h as Ge,
  i as oe,
  j as L,
  k as Co,
  l as g,
} from "../../chunk-LGMSABOQ.js";
var tg = z((Tx, eg) => {
  "use strict";
  c();
  function Yr(o) {
    (this._maxSize = o), this.clear();
  }
  Yr.prototype.clear = function () {
    (this._size = 0), (this._values = Object.create(null));
  };
  Yr.prototype.get = function (o) {
    return this._values[o];
  };
  Yr.prototype.set = function (o, e) {
    return (
      this._size >= this._maxSize && this.clear(),
      o in this._values || this._size++,
      (this._values[o] = e)
    );
  };
  var GT = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
    Zb = /^\d+$/,
    HT = /^\d/,
    VT = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
    $T = /^\s*(['"]?)(.*?)(\1)\s*$/,
    Yu = 512,
    Yb = new Yr(Yu),
    Xb = new Yr(Yu),
    Jb = new Yr(Yu);
  eg.exports = {
    Cache: Yr,
    split: Qu,
    normalizePath: zu,
    setter: function (o) {
      var e = zu(o);
      return (
        Xb.get(o) ||
        Xb.set(o, function (r, i) {
          for (var s = 0, a = e.length, n = r; s < a - 1; ) {
            var p = e[s];
            if (p === "__proto__" || p === "constructor" || p === "prototype")
              return r;
            n = n[e[s++]];
          }
          n[e[s]] = i;
        })
      );
    },
    getter: function (o, e) {
      var t = zu(o);
      return (
        Jb.get(o) ||
        Jb.set(o, function (i) {
          for (var s = 0, a = t.length; s < a; )
            if (i != null || !e) i = i[t[s++]];
            else return;
          return i;
        })
      );
    },
    join: function (o) {
      return o.reduce(function (e, t) {
        return e + (Xu(t) || Zb.test(t) ? "[" + t + "]" : (e ? "." : "") + t);
      }, "");
    },
    forEach: function (o, e, t) {
      KT(Array.isArray(o) ? o : Qu(o), e, t);
    },
  };
  function zu(o) {
    return (
      Yb.get(o) ||
      Yb.set(
        o,
        Qu(o).map(function (e) {
          return e.replace($T, "$2");
        })
      )
    );
  }
  function Qu(o) {
    return o.match(GT) || [""];
  }
  function KT(o, e, t) {
    var r = o.length,
      i,
      s,
      a,
      n;
    for (s = 0; s < r; s++)
      (i = o[s]),
        i &&
          (QT(i) && (i = '"' + i + '"'),
          (n = Xu(i)),
          (a = !n && /^\d+$/.test(i)),
          e.call(t, i, n, a, s, o));
  }
  function Xu(o) {
    return typeof o == "string" && o && ["'", '"'].indexOf(o.charAt(0)) !== -1;
  }
  function qT(o) {
    return o.match(HT) && !o.match(Zb);
  }
  function zT(o) {
    return VT.test(o);
  }
  function QT(o) {
    return !Xu(o) && (qT(o) || zT(o));
  }
});
var og = z((Ax, ig) => {
  c();
  var YT =
      /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g,
    ga = (o) => o.match(YT) || [],
    va = (o) => o[0].toUpperCase() + o.slice(1),
    Ju = (o, e) => ga(o).join(e).toLowerCase(),
    rg = (o) =>
      ga(o).reduce(
        (e, t) =>
          `${e}${
            e ? t[0].toUpperCase() + t.slice(1).toLowerCase() : t.toLowerCase()
          }`,
        ""
      ),
    XT = (o) => va(rg(o)),
    JT = (o) => Ju(o, "_"),
    ZT = (o) => Ju(o, "-"),
    eI = (o) => va(Ju(o, " ")),
    tI = (o) => ga(o).map(va).join(" ");
  ig.exports = {
    words: ga,
    upperFirst: va,
    camelCase: rg,
    pascalCase: XT,
    snakeCase: JT,
    kebabCase: ZT,
    sentenceCase: eI,
    titleCase: tI,
  };
});
var ag = z((Rx, Zu) => {
  c();
  Zu.exports = function (o) {
    return sg(rI(o), o);
  };
  Zu.exports.array = sg;
  function sg(o, e) {
    var t = o.length,
      r = new Array(t),
      i = {},
      s = t,
      a = iI(e),
      n = oI(o);
    for (
      e.forEach(function (d) {
        if (!n.has(d[0]) || !n.has(d[1]))
          throw new Error(
            "Unknown node. There is an unknown node in the supplied edges."
          );
      });
      s--;

    )
      i[s] || p(o[s], s, new Set());
    return r;
    function p(d, u, m) {
      if (m.has(d)) {
        var y;
        try {
          y = ", node was:" + JSON.stringify(d);
        } catch {
          y = "";
        }
        throw new Error("Cyclic dependency" + y);
      }
      if (!n.has(d))
        throw new Error(
          "Found unknown node. Make sure to provided all involved nodes. Unknown node: " +
            JSON.stringify(d)
        );
      if (!i[u]) {
        i[u] = !0;
        var b = a.get(d) || new Set();
        if (((b = Array.from(b)), (u = b.length))) {
          m.add(d);
          do {
            var v = b[--u];
            p(v, n.get(v), m);
          } while (u);
          m.delete(d);
        }
        r[--t] = d;
      }
    }
  }
  function rI(o) {
    for (var e = new Set(), t = 0, r = o.length; t < r; t++) {
      var i = o[t];
      e.add(i[0]), e.add(i[1]);
    }
    return Array.from(e);
  }
  function iI(o) {
    for (var e = new Map(), t = 0, r = o.length; t < r; t++) {
      var i = o[t];
      e.has(i[0]) || e.set(i[0], new Set()),
        e.has(i[1]) || e.set(i[1], new Set()),
        e.get(i[0]).add(i[1]);
    }
    return e;
  }
  function oI(o) {
    for (var e = new Map(), t = 0, r = o.length; t < r; t++) e.set(o[t], t);
    return e;
  }
});
var gg = z((Vo) => {
  c();
  var Ca = (function () {
    var o = function (d, u, m, y) {
        for (m = m || {}, y = d.length; y--; m[d[y]] = u);
        return m;
      },
      e = [1, 9],
      t = [1, 10],
      r = [1, 11],
      i = [1, 12],
      s = [5, 11, 12, 13, 14, 15],
      a = {
        trace: function () {},
        yy: {},
        symbols_: {
          error: 2,
          root: 3,
          expressions: 4,
          EOF: 5,
          expression: 6,
          optional: 7,
          literal: 8,
          splat: 9,
          param: 10,
          "(": 11,
          ")": 12,
          LITERAL: 13,
          SPLAT: 14,
          PARAM: 15,
          $accept: 0,
          $end: 1,
        },
        terminals_: {
          2: "error",
          5: "EOF",
          11: "(",
          12: ")",
          13: "LITERAL",
          14: "SPLAT",
          15: "PARAM",
        },
        productions_: [
          0,
          [3, 2],
          [3, 1],
          [4, 2],
          [4, 1],
          [6, 1],
          [6, 1],
          [6, 1],
          [6, 1],
          [7, 3],
          [8, 1],
          [9, 1],
          [10, 1],
        ],
        performAction: function (u, m, y, b, v, S, w) {
          var T = S.length - 1;
          switch (v) {
            case 1:
              return new b.Root({}, [S[T - 1]]);
            case 2:
              return new b.Root({}, [new b.Literal({ value: "" })]);
            case 3:
              this.$ = new b.Concat({}, [S[T - 1], S[T]]);
              break;
            case 4:
            case 5:
              this.$ = S[T];
              break;
            case 6:
              this.$ = new b.Literal({ value: S[T] });
              break;
            case 7:
              this.$ = new b.Splat({ name: S[T] });
              break;
            case 8:
              this.$ = new b.Param({ name: S[T] });
              break;
            case 9:
              this.$ = new b.Optional({}, [S[T - 1]]);
              break;
            case 10:
              this.$ = u;
              break;
            case 11:
            case 12:
              this.$ = u.slice(1);
              break;
          }
        },
        table: [
          {
            3: 1,
            4: 2,
            5: [1, 3],
            6: 4,
            7: 5,
            8: 6,
            9: 7,
            10: 8,
            11: e,
            13: t,
            14: r,
            15: i,
          },
          { 1: [3] },
          {
            5: [1, 13],
            6: 14,
            7: 5,
            8: 6,
            9: 7,
            10: 8,
            11: e,
            13: t,
            14: r,
            15: i,
          },
          { 1: [2, 2] },
          o(s, [2, 4]),
          o(s, [2, 5]),
          o(s, [2, 6]),
          o(s, [2, 7]),
          o(s, [2, 8]),
          { 4: 15, 6: 4, 7: 5, 8: 6, 9: 7, 10: 8, 11: e, 13: t, 14: r, 15: i },
          o(s, [2, 10]),
          o(s, [2, 11]),
          o(s, [2, 12]),
          { 1: [2, 1] },
          o(s, [2, 3]),
          {
            6: 14,
            7: 5,
            8: 6,
            9: 7,
            10: 8,
            11: e,
            12: [1, 16],
            13: t,
            14: r,
            15: i,
          },
          o(s, [2, 9]),
        ],
        defaultActions: { 3: [2, 2], 13: [2, 1] },
        parseError: function (u, m) {
          if (m.recoverable) this.trace(u);
          else {
            let b = function (v, S) {
              (this.message = v), (this.hash = S);
            };
            var y = b;
            throw ((b.prototype = Error), new b(u, m));
          }
        },
        parse: function (u) {
          var m = this,
            y = [0],
            b = [],
            v = [null],
            S = [],
            w = this.table,
            T = "",
            I = 0,
            k = 0,
            _ = 0,
            O = 2,
            E = 1,
            f = S.slice.call(arguments, 1),
            j = Object.create(this.lexer),
            ue = { yy: {} };
          for (var Q in this.yy)
            Object.prototype.hasOwnProperty.call(this.yy, Q) &&
              (ue.yy[Q] = this.yy[Q]);
          j.setInput(u, ue.yy),
            (ue.yy.lexer = j),
            (ue.yy.parser = this),
            typeof j.yylloc > "u" && (j.yylloc = {});
          var C = j.yylloc;
          S.push(C);
          var G = j.options && j.options.ranges;
          typeof ue.yy.parseError == "function"
            ? (this.parseError = ue.yy.parseError)
            : (this.parseError = Object.getPrototypeOf(this).parseError);
          function K(Ke) {
            (y.length = y.length - 2 * Ke),
              (v.length = v.length - Ke),
              (S.length = S.length - Ke);
          }
          e: var B = function () {
            var Ke;
            return (
              (Ke = j.lex() || E),
              typeof Ke != "number" && (Ke = m.symbols_[Ke] || Ke),
              Ke
            );
          };
          for (var X, ie, Z, ve, Qe, St, wt = {}, kt, Me, Ye, Jt; ; ) {
            if (
              ((Z = y[y.length - 1]),
              this.defaultActions[Z]
                ? (ve = this.defaultActions[Z])
                : ((X === null || typeof X > "u") && (X = B()),
                  (ve = w[Z] && w[Z][X])),
              typeof ve > "u" || !ve.length || !ve[0])
            ) {
              var ar = "";
              Jt = [];
              for (kt in w[Z])
                this.terminals_[kt] &&
                  kt > O &&
                  Jt.push("'" + this.terminals_[kt] + "'");
              j.showPosition
                ? (ar =
                    "Parse error on line " +
                    (I + 1) +
                    `:
` +
                    j.showPosition() +
                    `
Expecting ` +
                    Jt.join(", ") +
                    ", got '" +
                    (this.terminals_[X] || X) +
                    "'")
                : (ar =
                    "Parse error on line " +
                    (I + 1) +
                    ": Unexpected " +
                    (X == E
                      ? "end of input"
                      : "'" + (this.terminals_[X] || X) + "'")),
                this.parseError(ar, {
                  text: j.match,
                  token: this.terminals_[X] || X,
                  line: j.yylineno,
                  loc: C,
                  expected: Jt,
                });
            }
            if (ve[0] instanceof Array && ve.length > 1)
              throw new Error(
                "Parse Error: multiple actions possible at state: " +
                  Z +
                  ", token: " +
                  X
              );
            switch (ve[0]) {
              case 1:
                y.push(X),
                  v.push(j.yytext),
                  S.push(j.yylloc),
                  y.push(ve[1]),
                  (X = null),
                  ie
                    ? ((X = ie), (ie = null))
                    : ((k = j.yyleng),
                      (T = j.yytext),
                      (I = j.yylineno),
                      (C = j.yylloc),
                      _ > 0 && _--);
                break;
              case 2:
                if (
                  ((Me = this.productions_[ve[1]][1]),
                  (wt.$ = v[v.length - Me]),
                  (wt._$ = {
                    first_line: S[S.length - (Me || 1)].first_line,
                    last_line: S[S.length - 1].last_line,
                    first_column: S[S.length - (Me || 1)].first_column,
                    last_column: S[S.length - 1].last_column,
                  }),
                  G &&
                    (wt._$.range = [
                      S[S.length - (Me || 1)].range[0],
                      S[S.length - 1].range[1],
                    ]),
                  (St = this.performAction.apply(
                    wt,
                    [T, k, I, ue.yy, ve[1], v, S].concat(f)
                  )),
                  typeof St < "u")
                )
                  return St;
                Me &&
                  ((y = y.slice(0, -1 * Me * 2)),
                  (v = v.slice(0, -1 * Me)),
                  (S = S.slice(0, -1 * Me))),
                  y.push(this.productions_[ve[1]][0]),
                  v.push(wt.$),
                  S.push(wt._$),
                  (Ye = w[y[y.length - 2]][y[y.length - 1]]),
                  y.push(Ye);
                break;
              case 3:
                return !0;
            }
          }
          return !0;
        },
      },
      n = (function () {
        var d = {
          EOF: 1,
          parseError: function (m, y) {
            if (this.yy.parser) this.yy.parser.parseError(m, y);
            else throw new Error(m);
          },
          setInput: function (u, m) {
            return (
              (this.yy = m || this.yy || {}),
              (this._input = u),
              (this._more = this._backtrack = this.done = !1),
              (this.yylineno = this.yyleng = 0),
              (this.yytext = this.matched = this.match = ""),
              (this.conditionStack = ["INITIAL"]),
              (this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0,
              }),
              this.options.ranges && (this.yylloc.range = [0, 0]),
              (this.offset = 0),
              this
            );
          },
          input: function () {
            var u = this._input[0];
            (this.yytext += u),
              this.yyleng++,
              this.offset++,
              (this.match += u),
              (this.matched += u);
            var m = u.match(/(?:\r\n?|\n).*/g);
            return (
              m
                ? (this.yylineno++, this.yylloc.last_line++)
                : this.yylloc.last_column++,
              this.options.ranges && this.yylloc.range[1]++,
              (this._input = this._input.slice(1)),
              u
            );
          },
          unput: function (u) {
            var m = u.length,
              y = u.split(/(?:\r\n?|\n)/g);
            (this._input = u + this._input),
              (this.yytext = this.yytext.substr(0, this.yytext.length - m)),
              (this.offset -= m);
            var b = this.match.split(/(?:\r\n?|\n)/g);
            (this.match = this.match.substr(0, this.match.length - 1)),
              (this.matched = this.matched.substr(0, this.matched.length - 1)),
              y.length - 1 && (this.yylineno -= y.length - 1);
            var v = this.yylloc.range;
            return (
              (this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: y
                  ? (y.length === b.length ? this.yylloc.first_column : 0) +
                    b[b.length - y.length].length -
                    y[0].length
                  : this.yylloc.first_column - m,
              }),
              this.options.ranges &&
                (this.yylloc.range = [v[0], v[0] + this.yyleng - m]),
              (this.yyleng = this.yytext.length),
              this
            );
          },
          more: function () {
            return (this._more = !0), this;
          },
          reject: function () {
            if (this.options.backtrack_lexer) this._backtrack = !0;
            else
              return this.parseError(
                "Lexical error on line " +
                  (this.yylineno + 1) +
                  `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                  this.showPosition(),
                { text: "", token: null, line: this.yylineno }
              );
            return this;
          },
          less: function (u) {
            this.unput(this.match.slice(u));
          },
          pastInput: function () {
            var u = this.matched.substr(
              0,
              this.matched.length - this.match.length
            );
            return (
              (u.length > 20 ? "..." : "") + u.substr(-20).replace(/\n/g, "")
            );
          },
          upcomingInput: function () {
            var u = this.match;
            return (
              u.length < 20 && (u += this._input.substr(0, 20 - u.length)),
              (u.substr(0, 20) + (u.length > 20 ? "..." : "")).replace(
                /\n/g,
                ""
              )
            );
          },
          showPosition: function () {
            var u = this.pastInput(),
              m = new Array(u.length + 1).join("-");
            return (
              u +
              this.upcomingInput() +
              `
` +
              m +
              "^"
            );
          },
          test_match: function (u, m) {
            var y, b, v;
            if (
              (this.options.backtrack_lexer &&
                ((v = {
                  yylineno: this.yylineno,
                  yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column,
                  },
                  yytext: this.yytext,
                  match: this.match,
                  matches: this.matches,
                  matched: this.matched,
                  yyleng: this.yyleng,
                  offset: this.offset,
                  _more: this._more,
                  _input: this._input,
                  yy: this.yy,
                  conditionStack: this.conditionStack.slice(0),
                  done: this.done,
                }),
                this.options.ranges &&
                  (v.yylloc.range = this.yylloc.range.slice(0))),
              (b = u[0].match(/(?:\r\n?|\n).*/g)),
              b && (this.yylineno += b.length),
              (this.yylloc = {
                first_line: this.yylloc.last_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.last_column,
                last_column: b
                  ? b[b.length - 1].length -
                    b[b.length - 1].match(/\r?\n?/)[0].length
                  : this.yylloc.last_column + u[0].length,
              }),
              (this.yytext += u[0]),
              (this.match += u[0]),
              (this.matches = u),
              (this.yyleng = this.yytext.length),
              this.options.ranges &&
                (this.yylloc.range = [
                  this.offset,
                  (this.offset += this.yyleng),
                ]),
              (this._more = !1),
              (this._backtrack = !1),
              (this._input = this._input.slice(u[0].length)),
              (this.matched += u[0]),
              (y = this.performAction.call(
                this,
                this.yy,
                this,
                m,
                this.conditionStack[this.conditionStack.length - 1]
              )),
              this.done && this._input && (this.done = !1),
              y)
            )
              return y;
            if (this._backtrack) {
              for (var S in v) this[S] = v[S];
              return !1;
            }
            return !1;
          },
          next: function () {
            if (this.done) return this.EOF;
            this._input || (this.done = !0);
            var u, m, y, b;
            this._more || ((this.yytext = ""), (this.match = ""));
            for (var v = this._currentRules(), S = 0; S < v.length; S++)
              if (
                ((y = this._input.match(this.rules[v[S]])),
                y && (!m || y[0].length > m[0].length))
              ) {
                if (((m = y), (b = S), this.options.backtrack_lexer)) {
                  if (((u = this.test_match(y, v[S])), u !== !1)) return u;
                  if (this._backtrack) {
                    m = !1;
                    continue;
                  } else return !1;
                } else if (!this.options.flex) break;
              }
            return m
              ? ((u = this.test_match(m, v[b])), u !== !1 ? u : !1)
              : this._input === ""
              ? this.EOF
              : this.parseError(
                  "Lexical error on line " +
                    (this.yylineno + 1) +
                    `. Unrecognized text.
` +
                    this.showPosition(),
                  { text: "", token: null, line: this.yylineno }
                );
          },
          lex: function () {
            var m = this.next();
            return m || this.lex();
          },
          begin: function (m) {
            this.conditionStack.push(m);
          },
          popState: function () {
            var m = this.conditionStack.length - 1;
            return m > 0 ? this.conditionStack.pop() : this.conditionStack[0];
          },
          _currentRules: function () {
            return this.conditionStack.length &&
              this.conditionStack[this.conditionStack.length - 1]
              ? this.conditions[
                  this.conditionStack[this.conditionStack.length - 1]
                ].rules
              : this.conditions.INITIAL.rules;
          },
          topState: function (m) {
            return (
              (m = this.conditionStack.length - 1 - Math.abs(m || 0)),
              m >= 0 ? this.conditionStack[m] : "INITIAL"
            );
          },
          pushState: function (m) {
            this.begin(m);
          },
          stateStackSize: function () {
            return this.conditionStack.length;
          },
          options: {},
          performAction: function (m, y, b, v) {
            var S = v;
            switch (b) {
              case 0:
                return "(";
              case 1:
                return ")";
              case 2:
                return "SPLAT";
              case 3:
                return "PARAM";
              case 4:
                return "LITERAL";
              case 5:
                return "LITERAL";
              case 6:
                return "EOF";
            }
          },
          rules: [
            /^(?:\()/,
            /^(?:\))/,
            /^(?:\*+\w+)/,
            /^(?::+\w+)/,
            /^(?:[\w%\-~\n]+)/,
            /^(?:.)/,
            /^(?:$)/,
          ],
          conditions: {
            INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6], inclusive: !0 },
          },
        };
        return d;
      })();
    a.lexer = n;
    function p() {
      this.yy = {};
    }
    return (p.prototype = a), (a.Parser = p), new p();
  })();
  typeof Ny < "u" &&
    typeof Vo < "u" &&
    ((Vo.parser = Ca),
    (Vo.Parser = Ca.Parser),
    (Vo.parse = function () {
      return Ca.parse.apply(Ca, arguments);
    }));
});
var im = z((Dx, vg) => {
  "use strict";
  c();
  function Wi(o) {
    return function (e, t) {
      return { displayName: o, props: e, children: t || [] };
    };
  }
  vg.exports = {
    Root: Wi("Root"),
    Concat: Wi("Concat"),
    Literal: Wi("Literal"),
    Splat: Wi("Splat"),
    Param: Wi("Param"),
    Optional: Wi("Optional"),
  };
});
var wg = z((Ox, Sg) => {
  "use strict";
  c();
  var fg = gg().parser;
  fg.yy = im();
  Sg.exports = fg;
});
var om = z((Nx, kg) => {
  "use strict";
  c();
  var BI = Object.keys(im());
  function CI(o) {
    return (
      BI.forEach(function (e) {
        if (typeof o[e] > "u")
          throw new Error("No handler defined for " + e.displayName);
      }),
      {
        visit: function (e, t) {
          return this.handlers[e.displayName].call(this, e, t);
        },
        handlers: o,
      }
    );
  }
  kg.exports = CI;
});
var Ag = z((Gx, Ig) => {
  "use strict";
  c();
  var _I = om(),
    FI = /[\-{}\[\]+?.,\\\^$|#\s]/g;
  function Tg(o) {
    (this.captures = o.captures), (this.re = o.re);
  }
  Tg.prototype.match = function (o) {
    var e = this.re.exec(o),
      t = {};
    if (e)
      return (
        this.captures.forEach(function (r, i) {
          typeof e[i + 1] > "u"
            ? (t[r] = void 0)
            : (t[r] = decodeURIComponent(e[i + 1]));
        }),
        t
      );
  };
  var MI = _I({
    Concat: function (o) {
      return o.children.reduce(
        function (e, t) {
          var r = this.visit(t);
          return { re: e.re + r.re, captures: e.captures.concat(r.captures) };
        }.bind(this),
        { re: "", captures: [] }
      );
    },
    Literal: function (o) {
      return { re: o.props.value.replace(FI, "\\$&"), captures: [] };
    },
    Splat: function (o) {
      return { re: "([^?]*?)", captures: [o.props.name] };
    },
    Param: function (o) {
      return { re: "([^\\/\\?]+)", captures: [o.props.name] };
    },
    Optional: function (o) {
      var e = this.visit(o.children[0]);
      return { re: "(?:" + e.re + ")?", captures: e.captures };
    },
    Root: function (o) {
      var e = this.visit(o.children[0]);
      return new Tg({
        re: new RegExp("^" + e.re + "(?=\\?|$)"),
        captures: e.captures,
      });
    },
  });
  Ig.exports = MI;
});
var Rg = z((Vx, Pg) => {
  "use strict";
  c();
  var xI = om(),
    WI = xI({
      Concat: function (o, e) {
        var t = o.children.map(
          function (r) {
            return this.visit(r, e);
          }.bind(this)
        );
        return t.some(function (r) {
          return r === !1;
        })
          ? !1
          : t.join("");
      },
      Literal: function (o) {
        return decodeURI(o.props.value);
      },
      Splat: function (o, e) {
        return e[o.props.name] ? e[o.props.name] : !1;
      },
      Param: function (o, e) {
        return e[o.props.name] ? e[o.props.name] : !1;
      },
      Optional: function (o, e) {
        var t = this.visit(o.children[0], e);
        return t || "";
      },
      Root: function (o, e) {
        e = e || {};
        var t = this.visit(o.children[0], e);
        return t ? encodeURI(t) : !1;
      },
    });
  Pg.exports = WI;
});
var Bg = z((Kx, Eg) => {
  "use strict";
  c();
  var DI = wg(),
    UI = Ag(),
    OI = Rg();
  $o.prototype = Object.create(null);
  $o.prototype.match = function (o) {
    var e = UI.visit(this.ast),
      t = e.match(o);
    return t || !1;
  };
  $o.prototype.reverse = function (o) {
    return OI.visit(this.ast, o);
  };
  function $o(o) {
    var e;
    if ((this ? (e = this) : (e = Object.create($o.prototype)), typeof o > "u"))
      throw new Error("A route spec is required");
    return (e.spec = o), (e.ast = DI.parse(o)), e;
  }
  Eg.exports = $o;
});
var sm = z((zx, Cg) => {
  "use strict";
  c();
  var jI = Bg();
  Cg.exports = jI;
});
var Jo = z((ij, bv) => {
  c();
  var iA = "2.0.0",
    oA = Number.MAX_SAFE_INTEGER || 9007199254740991,
    sA = 16,
    aA = 256 - 6,
    nA = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease",
    ];
  bv.exports = {
    MAX_LENGTH: 256,
    MAX_SAFE_COMPONENT_LENGTH: sA,
    MAX_SAFE_BUILD_LENGTH: aA,
    MAX_SAFE_INTEGER: oA,
    RELEASE_TYPES: nA,
    SEMVER_SPEC_VERSION: iA,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2,
  };
});
var Zo = z((sj, gv) => {
  c();
  var cA =
    typeof process == "object" &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ? (...o) => console.error("SEMVER", ...o)
      : () => {};
  gv.exports = cA;
});
var Oi = z((gr, vv) => {
  c();
  var {
      MAX_SAFE_COMPONENT_LENGTH: Xm,
      MAX_SAFE_BUILD_LENGTH: pA,
      MAX_LENGTH: lA,
    } = Jo(),
    dA = Zo();
  gr = vv.exports = {};
  var uA = (gr.re = []),
    mA = (gr.safeRe = []),
    V = (gr.src = []),
    $ = (gr.t = {}),
    hA = 0,
    Jm = "[a-zA-Z0-9-]",
    yA = [
      ["\\s", 1],
      ["\\d", lA],
      [Jm, pA],
    ],
    bA = (o) => {
      for (let [e, t] of yA)
        o = o
          .split(`${e}*`)
          .join(`${e}{0,${t}}`)
          .split(`${e}+`)
          .join(`${e}{1,${t}}`);
      return o;
    },
    ae = (o, e, t) => {
      let r = bA(e),
        i = hA++;
      dA(o, i, e),
        ($[o] = i),
        (V[i] = e),
        (uA[i] = new RegExp(e, t ? "g" : void 0)),
        (mA[i] = new RegExp(r, t ? "g" : void 0));
    };
  ae("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  ae("NUMERICIDENTIFIERLOOSE", "\\d+");
  ae("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${Jm}*`);
  ae(
    "MAINVERSION",
    `(${V[$.NUMERICIDENTIFIER]})\\.(${V[$.NUMERICIDENTIFIER]})\\.(${
      V[$.NUMERICIDENTIFIER]
    })`
  );
  ae(
    "MAINVERSIONLOOSE",
    `(${V[$.NUMERICIDENTIFIERLOOSE]})\\.(${V[$.NUMERICIDENTIFIERLOOSE]})\\.(${
      V[$.NUMERICIDENTIFIERLOOSE]
    })`
  );
  ae(
    "PRERELEASEIDENTIFIER",
    `(?:${V[$.NUMERICIDENTIFIER]}|${V[$.NONNUMERICIDENTIFIER]})`
  );
  ae(
    "PRERELEASEIDENTIFIERLOOSE",
    `(?:${V[$.NUMERICIDENTIFIERLOOSE]}|${V[$.NONNUMERICIDENTIFIER]})`
  );
  ae(
    "PRERELEASE",
    `(?:-(${V[$.PRERELEASEIDENTIFIER]}(?:\\.${V[$.PRERELEASEIDENTIFIER]})*))`
  );
  ae(
    "PRERELEASELOOSE",
    `(?:-?(${V[$.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${
      V[$.PRERELEASEIDENTIFIERLOOSE]
    })*))`
  );
  ae("BUILDIDENTIFIER", `${Jm}+`);
  ae(
    "BUILD",
    `(?:\\+(${V[$.BUILDIDENTIFIER]}(?:\\.${V[$.BUILDIDENTIFIER]})*))`
  );
  ae("FULLPLAIN", `v?${V[$.MAINVERSION]}${V[$.PRERELEASE]}?${V[$.BUILD]}?`);
  ae("FULL", `^${V[$.FULLPLAIN]}$`);
  ae(
    "LOOSEPLAIN",
    `[v=\\s]*${V[$.MAINVERSIONLOOSE]}${V[$.PRERELEASELOOSE]}?${V[$.BUILD]}?`
  );
  ae("LOOSE", `^${V[$.LOOSEPLAIN]}$`);
  ae("GTLT", "((?:<|>)?=?)");
  ae("XRANGEIDENTIFIERLOOSE", `${V[$.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  ae("XRANGEIDENTIFIER", `${V[$.NUMERICIDENTIFIER]}|x|X|\\*`);
  ae(
    "XRANGEPLAIN",
    `[v=\\s]*(${V[$.XRANGEIDENTIFIER]})(?:\\.(${V[$.XRANGEIDENTIFIER]})(?:\\.(${
      V[$.XRANGEIDENTIFIER]
    })(?:${V[$.PRERELEASE]})?${V[$.BUILD]}?)?)?`
  );
  ae(
    "XRANGEPLAINLOOSE",
    `[v=\\s]*(${V[$.XRANGEIDENTIFIERLOOSE]})(?:\\.(${
      V[$.XRANGEIDENTIFIERLOOSE]
    })(?:\\.(${V[$.XRANGEIDENTIFIERLOOSE]})(?:${V[$.PRERELEASELOOSE]})?${
      V[$.BUILD]
    }?)?)?`
  );
  ae("XRANGE", `^${V[$.GTLT]}\\s*${V[$.XRANGEPLAIN]}$`);
  ae("XRANGELOOSE", `^${V[$.GTLT]}\\s*${V[$.XRANGEPLAINLOOSE]}$`);
  ae(
    "COERCE",
    `(^|[^\\d])(\\d{1,${Xm}})(?:\\.(\\d{1,${Xm}}))?(?:\\.(\\d{1,${Xm}}))?(?:$|[^\\d])`
  );
  ae("COERCERTL", V[$.COERCE], !0);
  ae("LONETILDE", "(?:~>?)");
  ae("TILDETRIM", `(\\s*)${V[$.LONETILDE]}\\s+`, !0);
  gr.tildeTrimReplace = "$1~";
  ae("TILDE", `^${V[$.LONETILDE]}${V[$.XRANGEPLAIN]}$`);
  ae("TILDELOOSE", `^${V[$.LONETILDE]}${V[$.XRANGEPLAINLOOSE]}$`);
  ae("LONECARET", "(?:\\^)");
  ae("CARETTRIM", `(\\s*)${V[$.LONECARET]}\\s+`, !0);
  gr.caretTrimReplace = "$1^";
  ae("CARET", `^${V[$.LONECARET]}${V[$.XRANGEPLAIN]}$`);
  ae("CARETLOOSE", `^${V[$.LONECARET]}${V[$.XRANGEPLAINLOOSE]}$`);
  ae("COMPARATORLOOSE", `^${V[$.GTLT]}\\s*(${V[$.LOOSEPLAIN]})$|^$`);
  ae("COMPARATOR", `^${V[$.GTLT]}\\s*(${V[$.FULLPLAIN]})$|^$`);
  ae(
    "COMPARATORTRIM",
    `(\\s*)${V[$.GTLT]}\\s*(${V[$.LOOSEPLAIN]}|${V[$.XRANGEPLAIN]})`,
    !0
  );
  gr.comparatorTrimReplace = "$1$2$3";
  ae(
    "HYPHENRANGE",
    `^\\s*(${V[$.XRANGEPLAIN]})\\s+-\\s+(${V[$.XRANGEPLAIN]})\\s*$`
  );
  ae(
    "HYPHENRANGELOOSE",
    `^\\s*(${V[$.XRANGEPLAINLOOSE]})\\s+-\\s+(${V[$.XRANGEPLAINLOOSE]})\\s*$`
  );
  ae("STAR", "(<|>)?=?\\s*\\*");
  ae("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  ae("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});
var hn = z((cj, fv) => {
  c();
  var gA = Object.freeze({ loose: !0 }),
    vA = Object.freeze({}),
    fA = (o) => (o ? (typeof o != "object" ? gA : o) : vA);
  fv.exports = fA;
});
var Zm = z((lj, kv) => {
  c();
  var Sv = /^[0-9]+$/,
    wv = (o, e) => {
      let t = Sv.test(o),
        r = Sv.test(e);
      return (
        t && r && ((o = +o), (e = +e)),
        o === e ? 0 : t && !r ? -1 : r && !t ? 1 : o < e ? -1 : 1
      );
    },
    SA = (o, e) => wv(e, o);
  kv.exports = { compareIdentifiers: wv, rcompareIdentifiers: SA };
});
var it = z((uj, Pv) => {
  c();
  var yn = Zo(),
    { MAX_LENGTH: Tv, MAX_SAFE_INTEGER: bn } = Jo(),
    { safeRe: Iv, t: Av } = Oi(),
    wA = hn(),
    { compareIdentifiers: ji } = Zm(),
    Rt = class {
      constructor(e, t) {
        if (((t = wA(t)), e instanceof Rt)) {
          if (
            e.loose === !!t.loose &&
            e.includePrerelease === !!t.includePrerelease
          )
            return e;
          e = e.version;
        } else if (typeof e != "string")
          throw new TypeError(
            `Invalid version. Must be a string. Got type "${typeof e}".`
          );
        if (e.length > Tv)
          throw new TypeError(`version is longer than ${Tv} characters`);
        yn("SemVer", e, t),
          (this.options = t),
          (this.loose = !!t.loose),
          (this.includePrerelease = !!t.includePrerelease);
        let r = e.trim().match(t.loose ? Iv[Av.LOOSE] : Iv[Av.FULL]);
        if (!r) throw new TypeError(`Invalid Version: ${e}`);
        if (
          ((this.raw = e),
          (this.major = +r[1]),
          (this.minor = +r[2]),
          (this.patch = +r[3]),
          this.major > bn || this.major < 0)
        )
          throw new TypeError("Invalid major version");
        if (this.minor > bn || this.minor < 0)
          throw new TypeError("Invalid minor version");
        if (this.patch > bn || this.patch < 0)
          throw new TypeError("Invalid patch version");
        r[4]
          ? (this.prerelease = r[4].split(".").map((i) => {
              if (/^[0-9]+$/.test(i)) {
                let s = +i;
                if (s >= 0 && s < bn) return s;
              }
              return i;
            }))
          : (this.prerelease = []),
          (this.build = r[5] ? r[5].split(".") : []),
          this.format();
      }
      format() {
        return (
          (this.version = `${this.major}.${this.minor}.${this.patch}`),
          this.prerelease.length &&
            (this.version += `-${this.prerelease.join(".")}`),
          this.version
        );
      }
      toString() {
        return this.version;
      }
      compare(e) {
        if (
          (yn("SemVer.compare", this.version, this.options, e),
          !(e instanceof Rt))
        ) {
          if (typeof e == "string" && e === this.version) return 0;
          e = new Rt(e, this.options);
        }
        return e.version === this.version
          ? 0
          : this.compareMain(e) || this.comparePre(e);
      }
      compareMain(e) {
        return (
          e instanceof Rt || (e = new Rt(e, this.options)),
          ji(this.major, e.major) ||
            ji(this.minor, e.minor) ||
            ji(this.patch, e.patch)
        );
      }
      comparePre(e) {
        if (
          (e instanceof Rt || (e = new Rt(e, this.options)),
          this.prerelease.length && !e.prerelease.length)
        )
          return -1;
        if (!this.prerelease.length && e.prerelease.length) return 1;
        if (!this.prerelease.length && !e.prerelease.length) return 0;
        let t = 0;
        do {
          let r = this.prerelease[t],
            i = e.prerelease[t];
          if ((yn("prerelease compare", t, r, i), r === void 0 && i === void 0))
            return 0;
          if (i === void 0) return 1;
          if (r === void 0) return -1;
          if (r === i) continue;
          return ji(r, i);
        } while (++t);
      }
      compareBuild(e) {
        e instanceof Rt || (e = new Rt(e, this.options));
        let t = 0;
        do {
          let r = this.build[t],
            i = e.build[t];
          if ((yn("prerelease compare", t, r, i), r === void 0 && i === void 0))
            return 0;
          if (i === void 0) return 1;
          if (r === void 0) return -1;
          if (r === i) continue;
          return ji(r, i);
        } while (++t);
      }
      inc(e, t, r) {
        switch (e) {
          case "premajor":
            (this.prerelease.length = 0),
              (this.patch = 0),
              (this.minor = 0),
              this.major++,
              this.inc("pre", t, r);
            break;
          case "preminor":
            (this.prerelease.length = 0),
              (this.patch = 0),
              this.minor++,
              this.inc("pre", t, r);
            break;
          case "prepatch":
            (this.prerelease.length = 0),
              this.inc("patch", t, r),
              this.inc("pre", t, r);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", t, r),
              this.inc("pre", t, r);
            break;
          case "major":
            (this.minor !== 0 ||
              this.patch !== 0 ||
              this.prerelease.length === 0) &&
              this.major++,
              (this.minor = 0),
              (this.patch = 0),
              (this.prerelease = []);
            break;
          case "minor":
            (this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
              (this.patch = 0),
              (this.prerelease = []);
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++,
              (this.prerelease = []);
            break;
          case "pre": {
            let i = Number(r) ? 1 : 0;
            if (!t && r === !1)
              throw new Error(
                "invalid increment argument: identifier is empty"
              );
            if (this.prerelease.length === 0) this.prerelease = [i];
            else {
              let s = this.prerelease.length;
              for (; --s >= 0; )
                typeof this.prerelease[s] == "number" &&
                  (this.prerelease[s]++, (s = -2));
              if (s === -1) {
                if (t === this.prerelease.join(".") && r === !1)
                  throw new Error(
                    "invalid increment argument: identifier already exists"
                  );
                this.prerelease.push(i);
              }
            }
            if (t) {
              let s = [t, i];
              r === !1 && (s = [t]),
                ji(this.prerelease[0], t) === 0
                  ? isNaN(this.prerelease[1]) && (this.prerelease = s)
                  : (this.prerelease = s);
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${e}`);
        }
        return (
          (this.raw = this.format()),
          this.build.length && (this.raw += `+${this.build.join(".")}`),
          this
        );
      }
    };
  Pv.exports = Rt;
});
var ri = z((hj, Ev) => {
  c();
  var Rv = it(),
    kA = (o, e, t = !1) => {
      if (o instanceof Rv) return o;
      try {
        return new Rv(o, e);
      } catch (r) {
        if (!t) return null;
        throw r;
      }
    };
  Ev.exports = kA;
});
var Cv = z((bj, Bv) => {
  c();
  var TA = ri(),
    IA = (o, e) => {
      let t = TA(o, e);
      return t ? t.version : null;
    };
  Bv.exports = IA;
});
var Fv = z((vj, _v) => {
  c();
  var AA = ri(),
    PA = (o, e) => {
      let t = AA(o.trim().replace(/^[=v]+/, ""), e);
      return t ? t.version : null;
    };
  _v.exports = PA;
});
var Wv = z((Sj, xv) => {
  c();
  var Mv = it(),
    RA = (o, e, t, r, i) => {
      typeof t == "string" && ((i = r), (r = t), (t = void 0));
      try {
        return new Mv(o instanceof Mv ? o.version : o, t).inc(e, r, i).version;
      } catch {
        return null;
      }
    };
  xv.exports = RA;
});
var Ov = z((kj, Uv) => {
  c();
  var Dv = ri(),
    EA = (o, e) => {
      let t = Dv(o, null, !0),
        r = Dv(e, null, !0),
        i = t.compare(r);
      if (i === 0) return null;
      let s = i > 0,
        a = s ? t : r,
        n = s ? r : t,
        p = !!a.prerelease.length;
      if (!!n.prerelease.length && !p)
        return !n.patch && !n.minor
          ? "major"
          : a.patch
          ? "patch"
          : a.minor
          ? "minor"
          : "major";
      let u = p ? "pre" : "";
      return t.major !== r.major
        ? u + "major"
        : t.minor !== r.minor
        ? u + "minor"
        : t.patch !== r.patch
        ? u + "patch"
        : "prerelease";
    };
  Uv.exports = EA;
});
var Nv = z((Ij, jv) => {
  c();
  var BA = it(),
    CA = (o, e) => new BA(o, e).major;
  jv.exports = CA;
});
var Gv = z((Pj, Lv) => {
  c();
  var _A = it(),
    FA = (o, e) => new _A(o, e).minor;
  Lv.exports = FA;
});
var Vv = z((Ej, Hv) => {
  c();
  var MA = it(),
    xA = (o, e) => new MA(o, e).patch;
  Hv.exports = xA;
});
var Kv = z((Cj, $v) => {
  c();
  var WA = ri(),
    DA = (o, e) => {
      let t = WA(o, e);
      return t && t.prerelease.length ? t.prerelease : null;
    };
  $v.exports = DA;
});
var Wt = z((Fj, zv) => {
  c();
  var qv = it(),
    UA = (o, e, t) => new qv(o, t).compare(new qv(e, t));
  zv.exports = UA;
});
var Yv = z((xj, Qv) => {
  c();
  var OA = Wt(),
    jA = (o, e, t) => OA(e, o, t);
  Qv.exports = jA;
});
var Jv = z((Dj, Xv) => {
  c();
  var NA = Wt(),
    LA = (o, e) => NA(o, e, !0);
  Xv.exports = LA;
});
var gn = z((Oj, ef) => {
  c();
  var Zv = it(),
    GA = (o, e, t) => {
      let r = new Zv(o, t),
        i = new Zv(e, t);
      return r.compare(i) || r.compareBuild(i);
    };
  ef.exports = GA;
});
var rf = z((Nj, tf) => {
  c();
  var HA = gn(),
    VA = (o, e) => o.sort((t, r) => HA(t, r, e));
  tf.exports = VA;
});
var sf = z((Gj, of) => {
  c();
  var $A = gn(),
    KA = (o, e) => o.sort((t, r) => $A(r, t, e));
  of.exports = KA;
});
var es = z((Vj, af) => {
  c();
  var qA = Wt(),
    zA = (o, e, t) => qA(o, e, t) > 0;
  af.exports = zA;
});
var vn = z((Kj, nf) => {
  c();
  var QA = Wt(),
    YA = (o, e, t) => QA(o, e, t) < 0;
  nf.exports = YA;
});
var eh = z((zj, cf) => {
  c();
  var XA = Wt(),
    JA = (o, e, t) => XA(o, e, t) === 0;
  cf.exports = JA;
});
var th = z((Yj, pf) => {
  c();
  var ZA = Wt(),
    eP = (o, e, t) => ZA(o, e, t) !== 0;
  pf.exports = eP;
});
var fn = z((Jj, lf) => {
  c();
  var tP = Wt(),
    rP = (o, e, t) => tP(o, e, t) >= 0;
  lf.exports = rP;
});
var Sn = z((eN, df) => {
  c();
  var iP = Wt(),
    oP = (o, e, t) => iP(o, e, t) <= 0;
  df.exports = oP;
});
var rh = z((rN, uf) => {
  c();
  var sP = eh(),
    aP = th(),
    nP = es(),
    cP = fn(),
    pP = vn(),
    lP = Sn(),
    dP = (o, e, t, r) => {
      switch (e) {
        case "===":
          return (
            typeof o == "object" && (o = o.version),
            typeof t == "object" && (t = t.version),
            o === t
          );
        case "!==":
          return (
            typeof o == "object" && (o = o.version),
            typeof t == "object" && (t = t.version),
            o !== t
          );
        case "":
        case "=":
        case "==":
          return sP(o, t, r);
        case "!=":
          return aP(o, t, r);
        case ">":
          return nP(o, t, r);
        case ">=":
          return cP(o, t, r);
        case "<":
          return pP(o, t, r);
        case "<=":
          return lP(o, t, r);
        default:
          throw new TypeError(`Invalid operator: ${e}`);
      }
    };
  uf.exports = dP;
});
var hf = z((oN, mf) => {
  c();
  var uP = it(),
    mP = ri(),
    { safeRe: wn, t: kn } = Oi(),
    hP = (o, e) => {
      if (o instanceof uP) return o;
      if ((typeof o == "number" && (o = String(o)), typeof o != "string"))
        return null;
      e = e || {};
      let t = null;
      if (!e.rtl) t = o.match(wn[kn.COERCE]);
      else {
        let r;
        for (
          ;
          (r = wn[kn.COERCERTL].exec(o)) &&
          (!t || t.index + t[0].length !== o.length);

        )
          (!t || r.index + r[0].length !== t.index + t[0].length) && (t = r),
            (wn[kn.COERCERTL].lastIndex = r.index + r[1].length + r[2].length);
        wn[kn.COERCERTL].lastIndex = -1;
      }
      return t === null ? null : mP(`${t[2]}.${t[3] || "0"}.${t[4] || "0"}`, e);
    };
  mf.exports = hP;
});
var bf = z((aN, yf) => {
  "use strict";
  c();
  yf.exports = function (o) {
    o.prototype[Symbol.iterator] = function* () {
      for (let e = this.head; e; e = e.next) yield e.value;
    };
  };
});
var vf = z((cN, gf) => {
  "use strict";
  c();
  gf.exports = be;
  be.Node = ii;
  be.create = be;
  function be(o) {
    var e = this;
    if (
      (e instanceof be || (e = new be()),
      (e.tail = null),
      (e.head = null),
      (e.length = 0),
      o && typeof o.forEach == "function")
    )
      o.forEach(function (i) {
        e.push(i);
      });
    else if (arguments.length > 0)
      for (var t = 0, r = arguments.length; t < r; t++) e.push(arguments[t]);
    return e;
  }
  be.prototype.removeNode = function (o) {
    if (o.list !== this)
      throw new Error("removing node which does not belong to this list");
    var e = o.next,
      t = o.prev;
    return (
      e && (e.prev = t),
      t && (t.next = e),
      o === this.head && (this.head = e),
      o === this.tail && (this.tail = t),
      o.list.length--,
      (o.next = null),
      (o.prev = null),
      (o.list = null),
      e
    );
  };
  be.prototype.unshiftNode = function (o) {
    if (o !== this.head) {
      o.list && o.list.removeNode(o);
      var e = this.head;
      (o.list = this),
        (o.next = e),
        e && (e.prev = o),
        (this.head = o),
        this.tail || (this.tail = o),
        this.length++;
    }
  };
  be.prototype.pushNode = function (o) {
    if (o !== this.tail) {
      o.list && o.list.removeNode(o);
      var e = this.tail;
      (o.list = this),
        (o.prev = e),
        e && (e.next = o),
        (this.tail = o),
        this.head || (this.head = o),
        this.length++;
    }
  };
  be.prototype.push = function () {
    for (var o = 0, e = arguments.length; o < e; o++) bP(this, arguments[o]);
    return this.length;
  };
  be.prototype.unshift = function () {
    for (var o = 0, e = arguments.length; o < e; o++) gP(this, arguments[o]);
    return this.length;
  };
  be.prototype.pop = function () {
    if (this.tail) {
      var o = this.tail.value;
      return (
        (this.tail = this.tail.prev),
        this.tail ? (this.tail.next = null) : (this.head = null),
        this.length--,
        o
      );
    }
  };
  be.prototype.shift = function () {
    if (this.head) {
      var o = this.head.value;
      return (
        (this.head = this.head.next),
        this.head ? (this.head.prev = null) : (this.tail = null),
        this.length--,
        o
      );
    }
  };
  be.prototype.forEach = function (o, e) {
    e = e || this;
    for (var t = this.head, r = 0; t !== null; r++)
      o.call(e, t.value, r, this), (t = t.next);
  };
  be.prototype.forEachReverse = function (o, e) {
    e = e || this;
    for (var t = this.tail, r = this.length - 1; t !== null; r--)
      o.call(e, t.value, r, this), (t = t.prev);
  };
  be.prototype.get = function (o) {
    for (var e = 0, t = this.head; t !== null && e < o; e++) t = t.next;
    if (e === o && t !== null) return t.value;
  };
  be.prototype.getReverse = function (o) {
    for (var e = 0, t = this.tail; t !== null && e < o; e++) t = t.prev;
    if (e === o && t !== null) return t.value;
  };
  be.prototype.map = function (o, e) {
    e = e || this;
    for (var t = new be(), r = this.head; r !== null; )
      t.push(o.call(e, r.value, this)), (r = r.next);
    return t;
  };
  be.prototype.mapReverse = function (o, e) {
    e = e || this;
    for (var t = new be(), r = this.tail; r !== null; )
      t.push(o.call(e, r.value, this)), (r = r.prev);
    return t;
  };
  be.prototype.reduce = function (o, e) {
    var t,
      r = this.head;
    if (arguments.length > 1) t = e;
    else if (this.head) (r = this.head.next), (t = this.head.value);
    else throw new TypeError("Reduce of empty list with no initial value");
    for (var i = 0; r !== null; i++) (t = o(t, r.value, i)), (r = r.next);
    return t;
  };
  be.prototype.reduceReverse = function (o, e) {
    var t,
      r = this.tail;
    if (arguments.length > 1) t = e;
    else if (this.tail) (r = this.tail.prev), (t = this.tail.value);
    else throw new TypeError("Reduce of empty list with no initial value");
    for (var i = this.length - 1; r !== null; i--)
      (t = o(t, r.value, i)), (r = r.prev);
    return t;
  };
  be.prototype.toArray = function () {
    for (var o = new Array(this.length), e = 0, t = this.head; t !== null; e++)
      (o[e] = t.value), (t = t.next);
    return o;
  };
  be.prototype.toArrayReverse = function () {
    for (var o = new Array(this.length), e = 0, t = this.tail; t !== null; e++)
      (o[e] = t.value), (t = t.prev);
    return o;
  };
  be.prototype.slice = function (o, e) {
    (e = e || this.length),
      e < 0 && (e += this.length),
      (o = o || 0),
      o < 0 && (o += this.length);
    var t = new be();
    if (e < o || e < 0) return t;
    o < 0 && (o = 0), e > this.length && (e = this.length);
    for (var r = 0, i = this.head; i !== null && r < o; r++) i = i.next;
    for (; i !== null && r < e; r++, i = i.next) t.push(i.value);
    return t;
  };
  be.prototype.sliceReverse = function (o, e) {
    (e = e || this.length),
      e < 0 && (e += this.length),
      (o = o || 0),
      o < 0 && (o += this.length);
    var t = new be();
    if (e < o || e < 0) return t;
    o < 0 && (o = 0), e > this.length && (e = this.length);
    for (var r = this.length, i = this.tail; i !== null && r > e; r--)
      i = i.prev;
    for (; i !== null && r > o; r--, i = i.prev) t.push(i.value);
    return t;
  };
  be.prototype.splice = function (o, e, ...t) {
    o > this.length && (o = this.length - 1), o < 0 && (o = this.length + o);
    for (var r = 0, i = this.head; i !== null && r < o; r++) i = i.next;
    for (var s = [], r = 0; i && r < e; r++)
      s.push(i.value), (i = this.removeNode(i));
    i === null && (i = this.tail),
      i !== this.head && i !== this.tail && (i = i.prev);
    for (var r = 0; r < t.length; r++) i = yP(this, i, t[r]);
    return s;
  };
  be.prototype.reverse = function () {
    for (var o = this.head, e = this.tail, t = o; t !== null; t = t.prev) {
      var r = t.prev;
      (t.prev = t.next), (t.next = r);
    }
    return (this.head = e), (this.tail = o), this;
  };
  function yP(o, e, t) {
    var r = e === o.head ? new ii(t, null, e, o) : new ii(t, e, e.next, o);
    return (
      r.next === null && (o.tail = r),
      r.prev === null && (o.head = r),
      o.length++,
      r
    );
  }
  function bP(o, e) {
    (o.tail = new ii(e, o.tail, null, o)),
      o.head || (o.head = o.tail),
      o.length++;
  }
  function gP(o, e) {
    (o.head = new ii(e, null, o.head, o)),
      o.tail || (o.tail = o.head),
      o.length++;
  }
  function ii(o, e, t, r) {
    if (!(this instanceof ii)) return new ii(o, e, t, r);
    (this.list = r),
      (this.value = o),
      e ? ((e.next = this), (this.prev = e)) : (this.prev = null),
      t ? ((t.prev = this), (this.next = t)) : (this.next = null);
  }
  try {
    bf()(be);
  } catch {}
});
var Tf = z((lN, kf) => {
  "use strict";
  c();
  var vP = vf(),
    oi = Symbol("max"),
    fr = Symbol("length"),
    Ni = Symbol("lengthCalculator"),
    rs = Symbol("allowStale"),
    si = Symbol("maxAge"),
    vr = Symbol("dispose"),
    ff = Symbol("noDisposeOnSet"),
    $e = Symbol("lruList"),
    qt = Symbol("cache"),
    wf = Symbol("updateAgeOnGet"),
    ih = () => 1,
    sh = class {
      constructor(e) {
        if (
          (typeof e == "number" && (e = { max: e }),
          e || (e = {}),
          e.max && (typeof e.max != "number" || e.max < 0))
        )
          throw new TypeError("max must be a non-negative number");
        let t = (this[oi] = e.max || 1 / 0),
          r = e.length || ih;
        if (
          ((this[Ni] = typeof r != "function" ? ih : r),
          (this[rs] = e.stale || !1),
          e.maxAge && typeof e.maxAge != "number")
        )
          throw new TypeError("maxAge must be a number");
        (this[si] = e.maxAge || 0),
          (this[vr] = e.dispose),
          (this[ff] = e.noDisposeOnSet || !1),
          (this[wf] = e.updateAgeOnGet || !1),
          this.reset();
      }
      set max(e) {
        if (typeof e != "number" || e < 0)
          throw new TypeError("max must be a non-negative number");
        (this[oi] = e || 1 / 0), ts(this);
      }
      get max() {
        return this[oi];
      }
      set allowStale(e) {
        this[rs] = !!e;
      }
      get allowStale() {
        return this[rs];
      }
      set maxAge(e) {
        if (typeof e != "number")
          throw new TypeError("maxAge must be a non-negative number");
        (this[si] = e), ts(this);
      }
      get maxAge() {
        return this[si];
      }
      set lengthCalculator(e) {
        typeof e != "function" && (e = ih),
          e !== this[Ni] &&
            ((this[Ni] = e),
            (this[fr] = 0),
            this[$e].forEach((t) => {
              (t.length = this[Ni](t.value, t.key)), (this[fr] += t.length);
            })),
          ts(this);
      }
      get lengthCalculator() {
        return this[Ni];
      }
      get length() {
        return this[fr];
      }
      get itemCount() {
        return this[$e].length;
      }
      rforEach(e, t) {
        t = t || this;
        for (let r = this[$e].tail; r !== null; ) {
          let i = r.prev;
          Sf(this, e, r, t), (r = i);
        }
      }
      forEach(e, t) {
        t = t || this;
        for (let r = this[$e].head; r !== null; ) {
          let i = r.next;
          Sf(this, e, r, t), (r = i);
        }
      }
      keys() {
        return this[$e].toArray().map((e) => e.key);
      }
      values() {
        return this[$e].toArray().map((e) => e.value);
      }
      reset() {
        this[vr] &&
          this[$e] &&
          this[$e].length &&
          this[$e].forEach((e) => this[vr](e.key, e.value)),
          (this[qt] = new Map()),
          (this[$e] = new vP()),
          (this[fr] = 0);
      }
      dump() {
        return this[$e]
          .map((e) =>
            Tn(this, e)
              ? !1
              : { k: e.key, v: e.value, e: e.now + (e.maxAge || 0) }
          )
          .toArray()
          .filter((e) => e);
      }
      dumpLru() {
        return this[$e];
      }
      set(e, t, r) {
        if (((r = r || this[si]), r && typeof r != "number"))
          throw new TypeError("maxAge must be a number");
        let i = r ? Date.now() : 0,
          s = this[Ni](t, e);
        if (this[qt].has(e)) {
          if (s > this[oi]) return Li(this, this[qt].get(e)), !1;
          let p = this[qt].get(e).value;
          return (
            this[vr] && (this[ff] || this[vr](e, p.value)),
            (p.now = i),
            (p.maxAge = r),
            (p.value = t),
            (this[fr] += s - p.length),
            (p.length = s),
            this.get(e),
            ts(this),
            !0
          );
        }
        let a = new ah(e, t, s, i, r);
        return a.length > this[oi]
          ? (this[vr] && this[vr](e, t), !1)
          : ((this[fr] += a.length),
            this[$e].unshift(a),
            this[qt].set(e, this[$e].head),
            ts(this),
            !0);
      }
      has(e) {
        if (!this[qt].has(e)) return !1;
        let t = this[qt].get(e).value;
        return !Tn(this, t);
      }
      get(e) {
        return oh(this, e, !0);
      }
      peek(e) {
        return oh(this, e, !1);
      }
      pop() {
        let e = this[$e].tail;
        return e ? (Li(this, e), e.value) : null;
      }
      del(e) {
        Li(this, this[qt].get(e));
      }
      load(e) {
        this.reset();
        let t = Date.now();
        for (let r = e.length - 1; r >= 0; r--) {
          let i = e[r],
            s = i.e || 0;
          if (s === 0) this.set(i.k, i.v);
          else {
            let a = s - t;
            a > 0 && this.set(i.k, i.v, a);
          }
        }
      }
      prune() {
        this[qt].forEach((e, t) => oh(this, t, !1));
      }
    },
    oh = (o, e, t) => {
      let r = o[qt].get(e);
      if (r) {
        let i = r.value;
        if (Tn(o, i)) {
          if ((Li(o, r), !o[rs])) return;
        } else t && (o[wf] && (r.value.now = Date.now()), o[$e].unshiftNode(r));
        return i.value;
      }
    },
    Tn = (o, e) => {
      if (!e || (!e.maxAge && !o[si])) return !1;
      let t = Date.now() - e.now;
      return e.maxAge ? t > e.maxAge : o[si] && t > o[si];
    },
    ts = (o) => {
      if (o[fr] > o[oi])
        for (let e = o[$e].tail; o[fr] > o[oi] && e !== null; ) {
          let t = e.prev;
          Li(o, e), (e = t);
        }
    },
    Li = (o, e) => {
      if (e) {
        let t = e.value;
        o[vr] && o[vr](t.key, t.value),
          (o[fr] -= t.length),
          o[qt].delete(t.key),
          o[$e].removeNode(e);
      }
    },
    ah = class {
      constructor(e, t, r, i, s) {
        (this.key = e),
          (this.value = t),
          (this.length = r),
          (this.now = i),
          (this.maxAge = s || 0);
      }
    },
    Sf = (o, e, t, r) => {
      let i = t.value;
      Tn(o, i) && (Li(o, t), o[rs] || (i = void 0)),
        i && e.call(r, i.value, i.key, o);
    };
  kf.exports = sh;
});
var Dt = z((uN, Rf) => {
  c();
  var ai = class {
    constructor(e, t) {
      if (((t = SP(t)), e instanceof ai))
        return e.loose === !!t.loose &&
          e.includePrerelease === !!t.includePrerelease
          ? e
          : new ai(e.raw, t);
      if (e instanceof nh)
        return (this.raw = e.value), (this.set = [[e]]), this.format(), this;
      if (
        ((this.options = t),
        (this.loose = !!t.loose),
        (this.includePrerelease = !!t.includePrerelease),
        (this.raw = e.trim().split(/\s+/).join(" ")),
        (this.set = this.raw
          .split("||")
          .map((r) => this.parseRange(r.trim()))
          .filter((r) => r.length)),
        !this.set.length)
      )
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        let r = this.set[0];
        if (
          ((this.set = this.set.filter((i) => !Af(i[0]))),
          this.set.length === 0)
        )
          this.set = [r];
        else if (this.set.length > 1) {
          for (let i of this.set)
            if (i.length === 1 && RP(i[0])) {
              this.set = [i];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return (
        (this.range = this.set
          .map((e) => e.join(" ").trim())
          .join("||")
          .trim()),
        this.range
      );
    }
    toString() {
      return this.range;
    }
    parseRange(e) {
      let r =
          ((this.options.includePrerelease && AP) |
            (this.options.loose && PP)) +
          ":" +
          e,
        i = If.get(r);
      if (i) return i;
      let s = this.options.loose,
        a = s ? vt[dt.HYPHENRANGELOOSE] : vt[dt.HYPHENRANGE];
      (e = e.replace(a, UP(this.options.includePrerelease))),
        Pe("hyphen replace", e),
        (e = e.replace(vt[dt.COMPARATORTRIM], kP)),
        Pe("comparator trim", e),
        (e = e.replace(vt[dt.TILDETRIM], TP)),
        Pe("tilde trim", e),
        (e = e.replace(vt[dt.CARETTRIM], IP)),
        Pe("caret trim", e);
      let n = e
        .split(" ")
        .map((m) => EP(m, this.options))
        .join(" ")
        .split(/\s+/)
        .map((m) => DP(m, this.options));
      s &&
        (n = n.filter(
          (m) => (
            Pe("loose invalid filter", m, this.options),
            !!m.match(vt[dt.COMPARATORLOOSE])
          )
        )),
        Pe("range list", n);
      let p = new Map(),
        d = n.map((m) => new nh(m, this.options));
      for (let m of d) {
        if (Af(m)) return [m];
        p.set(m.value, m);
      }
      p.size > 1 && p.has("") && p.delete("");
      let u = [...p.values()];
      return If.set(r, u), u;
    }
    intersects(e, t) {
      if (!(e instanceof ai)) throw new TypeError("a Range is required");
      return this.set.some(
        (r) =>
          Pf(r, t) &&
          e.set.some(
            (i) =>
              Pf(i, t) && r.every((s) => i.every((a) => s.intersects(a, t)))
          )
      );
    }
    test(e) {
      if (!e) return !1;
      if (typeof e == "string")
        try {
          e = new wP(e, this.options);
        } catch {
          return !1;
        }
      for (let t = 0; t < this.set.length; t++)
        if (OP(this.set[t], e, this.options)) return !0;
      return !1;
    }
  };
  Rf.exports = ai;
  var fP = Tf(),
    If = new fP({ max: 1e3 }),
    SP = hn(),
    nh = is(),
    Pe = Zo(),
    wP = it(),
    {
      safeRe: vt,
      t: dt,
      comparatorTrimReplace: kP,
      tildeTrimReplace: TP,
      caretTrimReplace: IP,
    } = Oi(),
    { FLAG_INCLUDE_PRERELEASE: AP, FLAG_LOOSE: PP } = Jo(),
    Af = (o) => o.value === "<0.0.0-0",
    RP = (o) => o.value === "",
    Pf = (o, e) => {
      let t = !0,
        r = o.slice(),
        i = r.pop();
      for (; t && r.length; )
        (t = r.every((s) => i.intersects(s, e))), (i = r.pop());
      return t;
    },
    EP = (o, e) => (
      Pe("comp", o, e),
      (o = _P(o, e)),
      Pe("caret", o),
      (o = BP(o, e)),
      Pe("tildes", o),
      (o = MP(o, e)),
      Pe("xrange", o),
      (o = WP(o, e)),
      Pe("stars", o),
      o
    ),
    ut = (o) => !o || o.toLowerCase() === "x" || o === "*",
    BP = (o, e) =>
      o
        .trim()
        .split(/\s+/)
        .map((t) => CP(t, e))
        .join(" "),
    CP = (o, e) => {
      let t = e.loose ? vt[dt.TILDELOOSE] : vt[dt.TILDE];
      return o.replace(t, (r, i, s, a, n) => {
        Pe("tilde", o, r, i, s, a, n);
        let p;
        return (
          ut(i)
            ? (p = "")
            : ut(s)
            ? (p = `>=${i}.0.0 <${+i + 1}.0.0-0`)
            : ut(a)
            ? (p = `>=${i}.${s}.0 <${i}.${+s + 1}.0-0`)
            : n
            ? (Pe("replaceTilde pr", n),
              (p = `>=${i}.${s}.${a}-${n} <${i}.${+s + 1}.0-0`))
            : (p = `>=${i}.${s}.${a} <${i}.${+s + 1}.0-0`),
          Pe("tilde return", p),
          p
        );
      });
    },
    _P = (o, e) =>
      o
        .trim()
        .split(/\s+/)
        .map((t) => FP(t, e))
        .join(" "),
    FP = (o, e) => {
      Pe("caret", o, e);
      let t = e.loose ? vt[dt.CARETLOOSE] : vt[dt.CARET],
        r = e.includePrerelease ? "-0" : "";
      return o.replace(t, (i, s, a, n, p) => {
        Pe("caret", o, i, s, a, n, p);
        let d;
        return (
          ut(s)
            ? (d = "")
            : ut(a)
            ? (d = `>=${s}.0.0${r} <${+s + 1}.0.0-0`)
            : ut(n)
            ? s === "0"
              ? (d = `>=${s}.${a}.0${r} <${s}.${+a + 1}.0-0`)
              : (d = `>=${s}.${a}.0${r} <${+s + 1}.0.0-0`)
            : p
            ? (Pe("replaceCaret pr", p),
              s === "0"
                ? a === "0"
                  ? (d = `>=${s}.${a}.${n}-${p} <${s}.${a}.${+n + 1}-0`)
                  : (d = `>=${s}.${a}.${n}-${p} <${s}.${+a + 1}.0-0`)
                : (d = `>=${s}.${a}.${n}-${p} <${+s + 1}.0.0-0`))
            : (Pe("no pr"),
              s === "0"
                ? a === "0"
                  ? (d = `>=${s}.${a}.${n}${r} <${s}.${a}.${+n + 1}-0`)
                  : (d = `>=${s}.${a}.${n}${r} <${s}.${+a + 1}.0-0`)
                : (d = `>=${s}.${a}.${n} <${+s + 1}.0.0-0`)),
          Pe("caret return", d),
          d
        );
      });
    },
    MP = (o, e) => (
      Pe("replaceXRanges", o, e),
      o
        .split(/\s+/)
        .map((t) => xP(t, e))
        .join(" ")
    ),
    xP = (o, e) => {
      o = o.trim();
      let t = e.loose ? vt[dt.XRANGELOOSE] : vt[dt.XRANGE];
      return o.replace(t, (r, i, s, a, n, p) => {
        Pe("xRange", o, r, i, s, a, n, p);
        let d = ut(s),
          u = d || ut(a),
          m = u || ut(n),
          y = m;
        return (
          i === "=" && y && (i = ""),
          (p = e.includePrerelease ? "-0" : ""),
          d
            ? i === ">" || i === "<"
              ? (r = "<0.0.0-0")
              : (r = "*")
            : i && y
            ? (u && (a = 0),
              (n = 0),
              i === ">"
                ? ((i = ">="),
                  u
                    ? ((s = +s + 1), (a = 0), (n = 0))
                    : ((a = +a + 1), (n = 0)))
                : i === "<=" && ((i = "<"), u ? (s = +s + 1) : (a = +a + 1)),
              i === "<" && (p = "-0"),
              (r = `${i + s}.${a}.${n}${p}`))
            : u
            ? (r = `>=${s}.0.0${p} <${+s + 1}.0.0-0`)
            : m && (r = `>=${s}.${a}.0${p} <${s}.${+a + 1}.0-0`),
          Pe("xRange return", r),
          r
        );
      });
    },
    WP = (o, e) => (
      Pe("replaceStars", o, e), o.trim().replace(vt[dt.STAR], "")
    ),
    DP = (o, e) => (
      Pe("replaceGTE0", o, e),
      o.trim().replace(vt[e.includePrerelease ? dt.GTE0PRE : dt.GTE0], "")
    ),
    UP = (o) => (e, t, r, i, s, a, n, p, d, u, m, y, b) => (
      ut(r)
        ? (t = "")
        : ut(i)
        ? (t = `>=${r}.0.0${o ? "-0" : ""}`)
        : ut(s)
        ? (t = `>=${r}.${i}.0${o ? "-0" : ""}`)
        : a
        ? (t = `>=${t}`)
        : (t = `>=${t}${o ? "-0" : ""}`),
      ut(d)
        ? (p = "")
        : ut(u)
        ? (p = `<${+d + 1}.0.0-0`)
        : ut(m)
        ? (p = `<${d}.${+u + 1}.0-0`)
        : y
        ? (p = `<=${d}.${u}.${m}-${y}`)
        : o
        ? (p = `<${d}.${u}.${+m + 1}-0`)
        : (p = `<=${p}`),
      `${t} ${p}`.trim()
    ),
    OP = (o, e, t) => {
      for (let r = 0; r < o.length; r++) if (!o[r].test(e)) return !1;
      if (e.prerelease.length && !t.includePrerelease) {
        for (let r = 0; r < o.length; r++)
          if (
            (Pe(o[r].semver),
            o[r].semver !== nh.ANY && o[r].semver.prerelease.length > 0)
          ) {
            let i = o[r].semver;
            if (
              i.major === e.major &&
              i.minor === e.minor &&
              i.patch === e.patch
            )
              return !0;
          }
        return !1;
      }
      return !0;
    };
});
var is = z((hN, Mf) => {
  c();
  var os = Symbol("SemVer ANY"),
    Gi = class {
      static get ANY() {
        return os;
      }
      constructor(e, t) {
        if (((t = Ef(t)), e instanceof Gi)) {
          if (e.loose === !!t.loose) return e;
          e = e.value;
        }
        (e = e.trim().split(/\s+/).join(" ")),
          ph("comparator", e, t),
          (this.options = t),
          (this.loose = !!t.loose),
          this.parse(e),
          this.semver === os
            ? (this.value = "")
            : (this.value = this.operator + this.semver.version),
          ph("comp", this);
      }
      parse(e) {
        let t = this.options.loose ? Bf[Cf.COMPARATORLOOSE] : Bf[Cf.COMPARATOR],
          r = e.match(t);
        if (!r) throw new TypeError(`Invalid comparator: ${e}`);
        (this.operator = r[1] !== void 0 ? r[1] : ""),
          this.operator === "=" && (this.operator = ""),
          r[2]
            ? (this.semver = new _f(r[2], this.options.loose))
            : (this.semver = os);
      }
      toString() {
        return this.value;
      }
      test(e) {
        if (
          (ph("Comparator.test", e, this.options.loose),
          this.semver === os || e === os)
        )
          return !0;
        if (typeof e == "string")
          try {
            e = new _f(e, this.options);
          } catch {
            return !1;
          }
        return ch(e, this.operator, this.semver, this.options);
      }
      intersects(e, t) {
        if (!(e instanceof Gi)) throw new TypeError("a Comparator is required");
        return this.operator === ""
          ? this.value === ""
            ? !0
            : new Ff(e.value, t).test(this.value)
          : e.operator === ""
          ? e.value === ""
            ? !0
            : new Ff(this.value, t).test(e.semver)
          : ((t = Ef(t)),
            (t.includePrerelease &&
              (this.value === "<0.0.0-0" || e.value === "<0.0.0-0")) ||
            (!t.includePrerelease &&
              (this.value.startsWith("<0.0.0") || e.value.startsWith("<0.0.0")))
              ? !1
              : !!(
                  (this.operator.startsWith(">") &&
                    e.operator.startsWith(">")) ||
                  (this.operator.startsWith("<") &&
                    e.operator.startsWith("<")) ||
                  (this.semver.version === e.semver.version &&
                    this.operator.includes("=") &&
                    e.operator.includes("=")) ||
                  (ch(this.semver, "<", e.semver, t) &&
                    this.operator.startsWith(">") &&
                    e.operator.startsWith("<")) ||
                  (ch(this.semver, ">", e.semver, t) &&
                    this.operator.startsWith("<") &&
                    e.operator.startsWith(">"))
                ));
      }
    };
  Mf.exports = Gi;
  var Ef = hn(),
    { safeRe: Bf, t: Cf } = Oi(),
    ch = rh(),
    ph = Zo(),
    _f = it(),
    Ff = Dt();
});
var ss = z((bN, xf) => {
  c();
  var jP = Dt(),
    NP = (o, e, t) => {
      try {
        e = new jP(e, t);
      } catch {
        return !1;
      }
      return e.test(o);
    };
  xf.exports = NP;
});
var Df = z((vN, Wf) => {
  c();
  var LP = Dt(),
    GP = (o, e) =>
      new LP(o, e).set.map((t) =>
        t
          .map((r) => r.value)
          .join(" ")
          .trim()
          .split(" ")
      );
  Wf.exports = GP;
});
var Of = z((SN, Uf) => {
  c();
  var HP = it(),
    VP = Dt(),
    $P = (o, e, t) => {
      let r = null,
        i = null,
        s = null;
      try {
        s = new VP(e, t);
      } catch {
        return null;
      }
      return (
        o.forEach((a) => {
          s.test(a) &&
            (!r || i.compare(a) === -1) &&
            ((r = a), (i = new HP(r, t)));
        }),
        r
      );
    };
  Uf.exports = $P;
});
var Nf = z((kN, jf) => {
  c();
  var KP = it(),
    qP = Dt(),
    zP = (o, e, t) => {
      let r = null,
        i = null,
        s = null;
      try {
        s = new qP(e, t);
      } catch {
        return null;
      }
      return (
        o.forEach((a) => {
          s.test(a) &&
            (!r || i.compare(a) === 1) &&
            ((r = a), (i = new KP(r, t)));
        }),
        r
      );
    };
  jf.exports = zP;
});
var Hf = z((IN, Gf) => {
  c();
  var lh = it(),
    QP = Dt(),
    Lf = es(),
    YP = (o, e) => {
      o = new QP(o, e);
      let t = new lh("0.0.0");
      if (o.test(t) || ((t = new lh("0.0.0-0")), o.test(t))) return t;
      t = null;
      for (let r = 0; r < o.set.length; ++r) {
        let i = o.set[r],
          s = null;
        i.forEach((a) => {
          let n = new lh(a.semver.version);
          switch (a.operator) {
            case ">":
              n.prerelease.length === 0 ? n.patch++ : n.prerelease.push(0),
                (n.raw = n.format());
            case "":
            case ">=":
              (!s || Lf(n, s)) && (s = n);
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${a.operator}`);
          }
        }),
          s && (!t || Lf(t, s)) && (t = s);
      }
      return t && o.test(t) ? t : null;
    };
  Gf.exports = YP;
});
var $f = z((PN, Vf) => {
  c();
  var XP = Dt(),
    JP = (o, e) => {
      try {
        return new XP(o, e).range || "*";
      } catch {
        return null;
      }
    };
  Vf.exports = JP;
});
var In = z((EN, Qf) => {
  c();
  var ZP = it(),
    zf = is(),
    { ANY: eR } = zf,
    tR = Dt(),
    rR = ss(),
    Kf = es(),
    qf = vn(),
    iR = Sn(),
    oR = fn(),
    sR = (o, e, t, r) => {
      (o = new ZP(o, r)), (e = new tR(e, r));
      let i, s, a, n, p;
      switch (t) {
        case ">":
          (i = Kf), (s = iR), (a = qf), (n = ">"), (p = ">=");
          break;
        case "<":
          (i = qf), (s = oR), (a = Kf), (n = "<"), (p = "<=");
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (rR(o, e, r)) return !1;
      for (let d = 0; d < e.set.length; ++d) {
        let u = e.set[d],
          m = null,
          y = null;
        if (
          (u.forEach((b) => {
            b.semver === eR && (b = new zf(">=0.0.0")),
              (m = m || b),
              (y = y || b),
              i(b.semver, m.semver, r)
                ? (m = b)
                : a(b.semver, y.semver, r) && (y = b);
          }),
          m.operator === n ||
            m.operator === p ||
            ((!y.operator || y.operator === n) && s(o, y.semver)))
        )
          return !1;
        if (y.operator === p && a(o, y.semver)) return !1;
      }
      return !0;
    };
  Qf.exports = sR;
});
var Xf = z((CN, Yf) => {
  c();
  var aR = In(),
    nR = (o, e, t) => aR(o, e, ">", t);
  Yf.exports = nR;
});
var Zf = z((FN, Jf) => {
  c();
  var cR = In(),
    pR = (o, e, t) => cR(o, e, "<", t);
  Jf.exports = pR;
});
var rS = z((xN, tS) => {
  c();
  var eS = Dt(),
    lR = (o, e, t) => (
      (o = new eS(o, t)), (e = new eS(e, t)), o.intersects(e, t)
    );
  tS.exports = lR;
});
var oS = z((DN, iS) => {
  c();
  var dR = ss(),
    uR = Wt();
  iS.exports = (o, e, t) => {
    let r = [],
      i = null,
      s = null,
      a = o.sort((u, m) => uR(u, m, t));
    for (let u of a)
      dR(u, e, t)
        ? ((s = u), i || (i = u))
        : (s && r.push([i, s]), (s = null), (i = null));
    i && r.push([i, null]);
    let n = [];
    for (let [u, m] of r)
      u === m
        ? n.push(u)
        : !m && u === a[0]
        ? n.push("*")
        : m
        ? u === a[0]
          ? n.push(`<=${m}`)
          : n.push(`${u} - ${m}`)
        : n.push(`>=${u}`);
    let p = n.join(" || "),
      d = typeof e.raw == "string" ? e.raw : String(e);
    return p.length < d.length ? p : e;
  };
});
var lS = z((ON, pS) => {
  c();
  var sS = Dt(),
    uh = is(),
    { ANY: dh } = uh,
    as = ss(),
    mh = Wt(),
    mR = (o, e, t = {}) => {
      if (o === e) return !0;
      (o = new sS(o, t)), (e = new sS(e, t));
      let r = !1;
      e: for (let i of o.set) {
        for (let s of e.set) {
          let a = yR(i, s, t);
          if (((r = r || a !== null), a)) continue e;
        }
        if (r) return !1;
      }
      return !0;
    },
    hR = [new uh(">=0.0.0-0")],
    aS = [new uh(">=0.0.0")],
    yR = (o, e, t) => {
      if (o === e) return !0;
      if (o.length === 1 && o[0].semver === dh) {
        if (e.length === 1 && e[0].semver === dh) return !0;
        t.includePrerelease ? (o = hR) : (o = aS);
      }
      if (e.length === 1 && e[0].semver === dh) {
        if (t.includePrerelease) return !0;
        e = aS;
      }
      let r = new Set(),
        i,
        s;
      for (let b of o)
        b.operator === ">" || b.operator === ">="
          ? (i = nS(i, b, t))
          : b.operator === "<" || b.operator === "<="
          ? (s = cS(s, b, t))
          : r.add(b.semver);
      if (r.size > 1) return null;
      let a;
      if (i && s) {
        if (((a = mh(i.semver, s.semver, t)), a > 0)) return null;
        if (a === 0 && (i.operator !== ">=" || s.operator !== "<="))
          return null;
      }
      for (let b of r) {
        if ((i && !as(b, String(i), t)) || (s && !as(b, String(s), t)))
          return null;
        for (let v of e) if (!as(b, String(v), t)) return !1;
        return !0;
      }
      let n,
        p,
        d,
        u,
        m =
          s && !t.includePrerelease && s.semver.prerelease.length
            ? s.semver
            : !1,
        y =
          i && !t.includePrerelease && i.semver.prerelease.length
            ? i.semver
            : !1;
      m &&
        m.prerelease.length === 1 &&
        s.operator === "<" &&
        m.prerelease[0] === 0 &&
        (m = !1);
      for (let b of e) {
        if (
          ((u = u || b.operator === ">" || b.operator === ">="),
          (d = d || b.operator === "<" || b.operator === "<="),
          i)
        ) {
          if (
            (y &&
              b.semver.prerelease &&
              b.semver.prerelease.length &&
              b.semver.major === y.major &&
              b.semver.minor === y.minor &&
              b.semver.patch === y.patch &&
              (y = !1),
            b.operator === ">" || b.operator === ">=")
          ) {
            if (((n = nS(i, b, t)), n === b && n !== i)) return !1;
          } else if (i.operator === ">=" && !as(i.semver, String(b), t))
            return !1;
        }
        if (s) {
          if (
            (m &&
              b.semver.prerelease &&
              b.semver.prerelease.length &&
              b.semver.major === m.major &&
              b.semver.minor === m.minor &&
              b.semver.patch === m.patch &&
              (m = !1),
            b.operator === "<" || b.operator === "<=")
          ) {
            if (((p = cS(s, b, t)), p === b && p !== s)) return !1;
          } else if (s.operator === "<=" && !as(s.semver, String(b), t))
            return !1;
        }
        if (!b.operator && (s || i) && a !== 0) return !1;
      }
      return !(
        (i && d && !s && a !== 0) ||
        (s && u && !i && a !== 0) ||
        y ||
        m
      );
    },
    nS = (o, e, t) => {
      if (!o) return e;
      let r = mh(o.semver, e.semver, t);
      return r > 0
        ? o
        : r < 0 || (e.operator === ">" && o.operator === ">=")
        ? e
        : o;
    },
    cS = (o, e, t) => {
      if (!o) return e;
      let r = mh(o.semver, e.semver, t);
      return r < 0
        ? o
        : r > 0 || (e.operator === "<" && o.operator === "<=")
        ? e
        : o;
    };
  pS.exports = mR;
});
var hS = z((NN, mS) => {
  c();
  var hh = Oi(),
    dS = Jo(),
    bR = it(),
    uS = Zm(),
    gR = ri(),
    vR = Cv(),
    fR = Fv(),
    SR = Wv(),
    wR = Ov(),
    kR = Nv(),
    TR = Gv(),
    IR = Vv(),
    AR = Kv(),
    PR = Wt(),
    RR = Yv(),
    ER = Jv(),
    BR = gn(),
    CR = rf(),
    _R = sf(),
    FR = es(),
    MR = vn(),
    xR = eh(),
    WR = th(),
    DR = fn(),
    UR = Sn(),
    OR = rh(),
    jR = hf(),
    NR = is(),
    LR = Dt(),
    GR = ss(),
    HR = Df(),
    VR = Of(),
    $R = Nf(),
    KR = Hf(),
    qR = $f(),
    zR = In(),
    QR = Xf(),
    YR = Zf(),
    XR = rS(),
    JR = oS(),
    ZR = lS();
  mS.exports = {
    parse: gR,
    valid: vR,
    clean: fR,
    inc: SR,
    diff: wR,
    major: kR,
    minor: TR,
    patch: IR,
    prerelease: AR,
    compare: PR,
    rcompare: RR,
    compareLoose: ER,
    compareBuild: BR,
    sort: CR,
    rsort: _R,
    gt: FR,
    lt: MR,
    eq: xR,
    neq: WR,
    gte: DR,
    lte: UR,
    cmp: OR,
    coerce: jR,
    Comparator: NR,
    Range: LR,
    satisfies: GR,
    toComparators: HR,
    maxSatisfying: VR,
    minSatisfying: $R,
    minVersion: KR,
    validRange: qR,
    outside: zR,
    gtr: QR,
    ltr: YR,
    intersects: XR,
    simplifyRange: JR,
    subset: ZR,
    SemVer: bR,
    re: hh.re,
    src: hh.src,
    tokens: hh.t,
    SEMVER_SPEC_VERSION: dS.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: dS.RELEASE_TYPES,
    compareIdentifiers: uS.compareIdentifiers,
    rcompareIdentifiers: uS.rcompareIdentifiers,
  };
});
c();
c();
c();
c();
var AT = (o) => Ge(o) && oe(o, "type") && o.type === yb,
  da = class {
    id = Date.now().toString();
    subscriptions = new Set();
    constructor(e) {
      Wu({ type: xu, payload: { bgId: this.id } }),
        e.storage.local.set({ ["bg-inited"]: [this.id, Date.now()] }, () => {
          e.runtime.lastError &&
            l(
              new L(
                e.runtime.lastError.message || "Chrome Error without message"
              )
            );
        }),
        e.runtime.onMessage.addListener(this.onMessage),
        this.subscriptions.add(() =>
          e.runtime.onMessage.removeListener(this.onMessage)
        );
    }
    dispose() {
      this.subscriptions.forEach((e) => e()), this.subscriptions.clear();
    }
    onMessage = (e) => {
      AT(e) &&
        Wu({ type: xu, payload: { bgId: this.id, forPageName: e.payload } });
    };
  };
c();
var Go = (o) => {
  let e = new Map(),
    t = {},
    r = new $y({
      ...o,
      postMessage: s,
      canProcessMessage: (n) => Boolean(t[Ru(n.client)]),
    }),
    i = (n) => {
      let p = e.get(n);
      e.delete(n), p && (r.clearByClientId(p), delete t[p]);
    };
  function s(n) {
    Array.from(e.entries()).forEach(([p, d]) => {
      try {
        p.postMessage(n);
      } catch (u) {
        let m = d || p.name;
        if (
          (l(
            new L(`Problem with sending message to ${m}: ${String(u)}`, {
              groupId: "gateway-send-msg",
            })
          ),
          !(u instanceof Error) ||
            !u.message.includes("Attempting to use a disconnected port object"))
        )
          return;
        i(p);
      }
    });
  }
  chrome.runtime.onConnect.addListener((n) => {
    if (!n.name.startsWith(o.id)) return;
    me.NODE_ENV === "development" &&
      console.log(`Opened a new connection with "${n.name}"`),
      e.set(n, null);
    let p = (d) => {
      if (!e.has(n) || !Vs(d)) return;
      let u = Ru(d.client),
        m = e.get(n);
      m != null &&
        u !== m &&
        (l(new Error("Impossible case with changing client ID")),
        r.clearByClientId(m),
        delete t[m]),
        e.set(n, u),
        (t[u] = !0),
        r.processMessage(d);
    };
    n.onDisconnect.addListener(function d() {
      console.log(`Closed connection with "${n.name}"`),
        i(n),
        n.onMessage.removeListener(p),
        n.onDisconnect.removeListener(d);
    }),
      n.onMessage.addListener(p);
  });
  let a = () => Array.from(e.keys()).forEach((n) => n.disconnect());
  return window.addEventListener("unload", a, { once: !0 }), r;
};
var Vu = Kr,
  PT = new Promise((o) => {
    Vu = o;
  }),
  $u = Kr,
  RT = new Promise((o) => {
    $u = o;
  }),
  Ku = Kr,
  ET = new Promise((o) => {
    Ku = o;
  }),
  qu = Kr,
  BT = new Promise((o) => {
    qu = o;
  }),
  CT = () => Go({ id: "gateway-for-ntp", api: BT }),
  _T = () => Go({ id: "gateway-for-overlay", api: ET }),
  FT = () => Go({ id: "gateway-for-popups", api: RT }),
  MT = () => Go({ id: "gateway-for-sidecar", api: PT }),
  Hb = () => {
    CT(), _T(), FT(), MT(), new da(chrome);
  };
c();
var he = (o) => o;
c();
var Qr = (o, e) => {
  let t = null,
    r = o((i) => {
      t && (t(), (t = null)), (t = e(i) ?? null);
    });
  return () => {
    r && r(), t && t();
  };
};
c();
c();
var Vb = (o) => o;
var ua = (o, e) =>
  Vb({
    activateAccountToAppById: o.activateAccountToAppById.bind(o),
    changeAppIcon: (t, r) => o.changeAppIcon(t, r),
    changeAppName: (t, r) => o.changeAppName(t, r),
    changeDisableNotificationBadgeNumber: (t, r) =>
      o.changeDisableNotificationBadgeNumber(t, r),
    changeDisableNotificationMessages: (t, r) =>
      o.changeDisableNotificationMessages(t, r),
    changeDoNotSuspend: (t, r) => o.changeDoNotSuspend(t, r),
    changeIsMuted: (t, r) => o.changeIsMuted(t, r),
    changeIsNotificationBadgeEnabled: (t, r) =>
      o.changeIsNotificationBadgeEnabled(t, r),
    changeIsNotificationEnabled: (t, r) => o.changeIsNotificationEnabled(t, r),
    changeIsPinned: (t, r) => o.changeIsPinned(e(), t, r),
    changeSyncFocusMode: (t, r) => o.changeSyncFocusMode(t, r),
    changeShowAsSidecarPanel: (t, r) => o.changeShowAsSidecarPanel(t, r),
    closeAppById: (t) => o.closeAppById(t),
    createAccount: (t) => o.createAccount(e(), t),
    deleteAccount: (t, r) => o.deleteAccount(e(), t, r),
    editAccount: (t, r) => o.editAccount(e(), t, r),
    removeAppFromWorkspace: (t) => o.removeAppFromWorkspace(e(), t),
    resetAppIcon: (t) => o.resetAppIcon(t),
    showShareApplicationModal: (t) => o.showShareApplicationModal(t, e()),
    showLimitsReachedModal: (t) => o.showLimitsReachedModal(t, e()),
  });
var Br = (o) => (
    g(o.type === "ntp", `Client type must be ${"ntp"}`, {
      receivedType: o.type,
    }),
    o.tabId
  ),
  bt = (o) => {
    let e = ct(),
      t = Br(e);
    return o.getWindowIdByTabId(t);
  },
  xT = ({
    analytics: o,
    applicationPopupApi: e,
    b2bModalApi: t,
    billingDetailsPopupApi: r,
    exploreApi: i,
    helpApi: s,
    launchpadApi: a,
    modalApi: n,
    platformApi: p,
    pmfSurveyApi: d,
    popupApi: u,
    productHuntApi: m,
    searchApi: y,
    shareApplicationModalApi: b,
    sidecarApi: v,
    signUpModalApi: S,
    themeApi: w,
    walkthroughApi: T,
    windowTabObserver: I,
  }) =>
    Pr({
      actions: {
        ...ua(e, () => bt(I)),
        activateAppAsTabById: a.activateAppAsTabById.bind(a),
        activateAppById: a.activateAppById.bind(a),
        addItemCompleteList: s.addFeatureToChecklist.bind(s),
        changeAppPositionInOrderById: (k, _) =>
          a.changeAppPositionInOrderById(bt(I), k, _),
        changeIsHeadlessModeEnabled: a.changeIsHeadlessModeEnabled.bind(a),
        changeWasInvitationBannerClosed:
          a.changeWasInvitationBannerClosed.bind(a),
        changeWorkspaceIconColor: (k) => a.changeBackground(bt(I), k),
        changeWorkspaceIconEmoji: (k) => a.changeBackgroundEmoji(bt(I), k),
        changeWorkspaceName: (k) => a.changeName(bt(I), k),
        closeProductHuntPopup: m.closeProductHuntPopup.bind(m),
        closeSidecar: () => v.closeSidecar(bt(I)),
        closeYearlyOfferPopup: () => a.closeYearlyOfferPopup(),
        confirmWalkthrough: (k) => T.confirmWalkthrough(bt(I), k),
        continueUpdating: () => a.continueUpdating(),
        deleteWorkspace: a.deleteWorkspace.bind(a),
        explore: i.explore.bind(i),
        hideApplicationPopup: () => {
          u.hidePopup(bt(I), "application", !0);
        },
        hideBillingButtonAnimation: () => a.hideBillingButtonAnimation(),
        hideLaunchpadVerticalTabsBanner:
          a.hideLaunchpadVerticalTabsBanner.bind(a),
        ignorePmfSurvey: () => d.ignore(),
        loadInvitationsStats: () => r.loadInvitationsStats(),
        makeGmailSignature: r.makeGmailSignature.bind(r),
        markGlobalSearchInLaunchpadAsCompletedForWalkthrough: (k) => {
          T.markGlobalSearchInLaunchpadAsCompleted(bt(I), k);
        },
        openBeforeLanding: m.openBeforeLanding.bind(m),
        openChromeImport: p.openChromeImport.bind(p),
        openLiveLanding: m.openLiveLanding.bind(m),
        openPaidAccountManagingPortal: r.openPaidAccountManagingPortal.bind(r),
        openSearchItem: (k) => y.openSearchItem({ ...k, windowId: bt(I) }),
        retryAllRequests: () => a.retryAllRequests(),
        sendAnalyticsEvent: o.sendAnalyticsEvent.bind(o),
        setHelpChecklistItemCompleted: s.setHelpChecklistItemCompleted.bind(s),
        setShortcutsPopupClosed: a.setShortcutsPopupClosed.bind(a),
        setWorkspaceMinimized: (k) => {
          a.setWorkspaceMinimized(bt(I), k);
        },
        showApplicationPopupSilently: (k) => u.showApplicationPopupSilently(k),
        showGlobalSettingsModal: n.showGlobalSettingsModal.bind(n),
        showIntegrationSettingsPopup: n.showIntegrationSettingsPopup.bind(n),
        showInvitationsPopup: s.showInvitationsPopup.bind(s),
        showLimitsReachedModal: n.showLimitsReachedModal.bind(n),
        showMarketplaceModal: n.showMarketplaceModal.bind(n),
        showShareApplicationModal: (k) => n.showShareApplicationModal(k, bt(I)),
        showSignUpModal: S.showModal.bind(S),
        showVerticalTabsModal: n.showVerticalTabsModal.bind(n),
        showVideoModal: n.showVideoModal.bind(n),
        startInvitesBonusTime: r.startInvitesBonusTime.bind(r),
        startInvitingTeammates: (k) => t.startInvitationFlow(k, bt(I)),
        startPersonalPlanUpgrade: r.startPersonalPlanUpgrade.bind(r),
        startPlanUpgrade: r.startPlanUpgrade.bind(r),
        startTeamPlanUpgrade: r.startTeamPlanUpgrade.bind(r),
        startTrial: r.startTrial.bind(r),
        submitPmfSurvey: () => d.submit(),
        switchFromMonthlyToYearlyPlan: a.switchFromMonthlyToYearlyPlan.bind(a),
        switchWalkthrough: (k) => T.switchWalkthrough(k),
        toggleExploreSidekickPopup: s.toggleExploreSidekickPopup.bind(s),
        toggleHelp: a.toggleHelp.bind(a),
      },
      queries: {
        loadFeedbackInfo: () => a.loadFeedbackInfo(),
        loadPmfSurvey: d.loadPopupState.bind(d),
        searchGlobally: (k) => y.searchGlobally({ ...k, windowId: bt(I) }),
        searchInApp: (k) => y.searchInApp(k),
      },
      stores: {
        applicationPopup: he((k) => {
          let _ = ct(),
            O = Br(_);
          return Qr(I.subscribeWindowIdByTabId.bind(I, O), (E) =>
            e.subscribeAppPopup(E, k)
          );
        }),
        applicationPopupInfo: he((k) => {
          let _ = ct(),
            O = Br(_);
          return Qr(I.subscribeWindowIdByTabId.bind(I, O), (E) =>
            u.subscribePopupInfo(E, "application", k)
          );
        }),
        billingDetailsPopupState: he((k) => {
          let _ = ct(),
            O = Br(_);
          return Qr(I.subscribeWindowIdByTabId.bind(I, O), (E) =>
            r.subscribeBillingDetailsPopupState(E, k)
          );
        }),
        canBeShared: b.subscribeCanBeShared.bind(b),
        clock: a.subscribeClockState.bind(a),
        connection: a.subscribeConnectionState.bind(a),
        currentWallpaper: he((k) => {
          let _ = ct(),
            O = Br(_);
          return Qr(I.subscribeWindowIdByTabId.bind(I, O), (E) =>
            a.subscribeCurrentWallpaper(E, k)
          );
        }),
        globalSearch: y.subscribeGlobalSearchState.bind(y),
        helpPanel: he((k) => {
          let _ = ct(),
            O = Br(_);
          return Qr(I.subscribeWindowIdByTabId.bind(I, O), (E) =>
            s.subscribeHelpState(E, k)
          );
        }),
        isIntercomAvailable: a.subscribeIsIntercomAvailable.bind(a),
        isPmfSurveyVisible: d.subscribeVisibleState.bind(d),
        launchpadHeader: a.subscribeHeaderState.bind(a),
        launchpadMainState: a.subscribeLaunchpadMainState.bind(a),
        launchpadPopupId: he((k) => {
          let _ = ct(),
            O = Br(_);
          return a.subscribeLaunchpadPopup(O, k);
        }),
        platform: p.subscribePlatform.bind(p),
        productHuntPopupState: m.subscribePopupState.bind(m),
        specialOfferPopupState: a.subscribeToSpecialOfferPopupState.bind(a),
        theme: w.subscribeTheme.bind(w),
        walkthrough: T.subscribeState.bind(T),
        workspaceList: he((k) => {
          let _ = ct(),
            O = Br(_);
          return Qr(I.subscribeWindowIdByTabId.bind(I, O), (E) =>
            a.subscribeWorkspaceList(E, k)
          );
        }),
      },
    }),
  $b = (o) => {
    let e = xT(o);
    return qu(e), e;
  };
c();
var WT = (o) => (
    g(o.type === "overlay", `Client type must be ${"overlay"}`, {
      receivedType: o.type,
    }),
    o.windowId
  ),
  te = () => {
    let o = ct();
    return WT(o);
  },
  DT = ({
    addApplicationModalApi: o,
    analytics: e,
    billingModalsApi: t,
    b2bModalApi: r,
    cpuMonitorPopupApi: i,
    globalSettingsApi: s,
    marketplaceModalApi: a,
    modalApi: n,
    platformApi: p,
    searchApi: d,
    shareApplicationModalApi: u,
    signUpModalApi: m,
    tabSwitcherModalApi: y,
    upgradePlanModalApi: b,
    themeApi: v,
    exploreApi: S,
    calendarModalApi: w,
    workspaceManagementModalApi: T,
    workspaceEditModalApi: I,
    collectionModalApi: k,
    collectionsListApi: _,
    walkthroughApi: O,
    sidecarApi: E,
  }) =>
    Pr({
      actions: {
        activateCommand: (f) => d.activateCommand(f, te()),
        addAdBlockerDomain: (f) => s.addAdBlockerDomain(f),
        addApp: (f, j) => o.addApp(te(), f, j),
        addCalendar: w.addCalendar.bind(w),
        addCpuMonitorDomain: (f) => s.addCpuMonitorDomain(f),
        addCustomApp: (f) => o.addCustomApp(te(), f),
        addNonDiscardableDomain: (f) => s.addNonDiscardableDomain(f),
        changeBackgroundEmojiForWorkspace:
          T.changeBackgroundEmojiForWorkspace.bind(T),
        changeBackgroundForWorkspace: T.changeBackgroundForWorkspace.bind(T),
        changeCtrlTabOrder: (f) => s.changeCtrlTabOrder(f),
        changeDistractionBlockerRules: (f) =>
          s.changeDistractionBlockerRules(f),
        changeDistractionBlockerSchedule: (f) =>
          s.changeDistractionBlockerSchedule(f),
        changeEnableCpuMonitorAutoDiscard: (f) =>
          s.changeEnableCpuMonitorAutoDiscard(f),
        changeEnableCpuMonitorNotification: (f) =>
          s.changeEnableCpuMonitorNotification(f),
        changeEnableDistractionBlocker: (f) =>
          s.changeEnableDistractionBlocker(f),
        changeIsHeadlessModeEnabled: s.changeIsHeadlessModeEnabled.bind(s),
        changeIsHiddenWelcomeGlobalSearch: (f) =>
          d.changeIsHiddenWelcomeGlobalSearch(f),
        changeIsHiddenWelcomeToDistractionBlocker: (f) =>
          s.changeIsHiddenWelcomeToDistractionBlocker(f),
        changeIsHideToolbarIconsOnHoverEnabled:
          s.changeIsHideToolbarIconsOnHoverEnabled.bind(s),
        changeMinutesBeforeDiscard: (f) => s.changeMinutesBeforeDiscard(f),
        changePreferredWallpaperId: s.changePreferredWallpaperId.bind(s),
        changeSelectedAppShareApp: (f) => u.changeSelectedApp(te(), f),
        changeSidebarSize: (f) => s.changeSidebarSize(f),
        changeTheme: s.changeTheme.bind(s),
        changeUseAdBlocker: (f) => s.changeUseAdBlocker(f),
        claimCancelDiscountOffer: t.claimCancelDiscountOffer.bind(t),
        clearSelectedApp: () => u.clearSelectedApp(te()),
        closeAllModalsById: n.closeAllModalsById.bind(n),
        closeCpuPopup: () => {
          i.closePopup(te());
        },
        closeFocusedTabInSwitcherByTabId: (f) => y.closeTab(te(), f),
        closeModal: () => {
          n.closeModal(te());
        },
        closeWorkspace: T.closeWorkspace.bind(T),
        confirmLocalLawsForVPN: () => s.confirmLocalLawsForVPN(),
        confirmTeamCreation: (f) => r.confirmTeamCreation(f, te()),
        confirmWalkthrough: (f) => O.confirmWalkthrough(te(), f),
        confirmWalkthroughStep: (f) => O.confirmWalkthroughStep(f),
        continueFlowAfterIntro: () => r.continueFlowAfterIntro(te()),
        cpuMonitorDiscardTabs: () => i.discardTabs(),
        cpuMonitorIgnoreHighLoadTabs: () => i.ignoreHighLoadTabs(),
        createAccount: (f) => o.createAccount(te(), f),
        createTeamWorkspaceAndContinueFlow: (f) =>
          r.createTeamWorkspaceAndContinueFlow(f, te()),
        createWorkspace: T.createWorkspace.bind(T),
        decrementFocusedTabIndexInSwitcher: () => y.decrementIndex(),
        deleteAccount: (f, j) => o.deleteAccount(te(), f, j),
        deleteCollection: _.deleteCollection.bind(_),
        deleteTeamPlanSubscription: () => t.deleteTeamPlanSubscription(te()),
        deleteWorkspace: T.deleteWorkspace.bind(T),
        disableShowingPaidTrialModal: t.disableShowingPaidTrialModal.bind(t),
        dismissCancelDiscountOffer: t.dismissCancelDiscountOffer.bind(t),
        editAccount: (f, j) => o.editAccount(te(), f, j),
        editWorkspaceData: I.editWorkspaceData.bind(I),
        enableWallpapersRotate: () => s.enableWallpapersRotate(),
        explore: S.explore.bind(S),
        incrementFocusedTabIndexInSwitcher: () => y.incrementIndex(),
        inviteToTeam: (f) => r.handleInviteToTeam(f, te()),
        loadInvitationStats: () => s.loadInvitationsStats(),
        makeGmailSignature: s.makeGmailSignature.bind(s),
        makeSidekickDefaultBrowser: s.makeSidekickDefaultBrowser.bind(s),
        markDistractionBlockerIntroShowed: () =>
          s.markDistractionBlockerIntroShowed(),
        openBillingLimitsModal: a.openBillingLimitsModal.bind(a),
        openChromeImport: p.openChromeImport.bind(p),
        openChromeShortcuts: p.openChromeShortcuts.bind(p),
        openCustomerPortal: s.openCustomerPortal.bind(s),
        openLaunchpadWithInvitations: t.openLaunchpadWithInvitations.bind(t),
        openManageColors: p.openManageColors.bind(p),
        openNotReadyModalParentModal: t.openNotReadyModalParentModal.bind(t),
        openPaidTrialPortal: t.openPaidTrialPortal.bind(t),
        openSearchItem: (f) => d.openSearchItem({ ...f, windowId: te() }),
        openTeamUpgradePlanTab: () => t.openTeamUpgradePlanTab(te()),
        openUpgradePlanTab: b.openUpgradePlanTab.bind(b),
        openWorkspace: T.openWorkspace.bind(T),
        removeAdBlockerDomain: (f) => s.removeAdBlockerDomain(f),
        removeCalendar: w.removeCalendar.bind(w),
        removeCpuMonitorDomain: (f) => s.removeCpuMonitorDomain(f),
        removeNonDiscardableDomain: (f) => s.removeNonDiscardableDomain(f),
        removeSharingRecipient: (f) => u.removeRecipient(f),
        sendAnalyticsEvent: e.sendAnalyticsEvent.bind(e),
        sendAnalyticsEventWithOptions: e.sendAnalyticsEventWithOptions.bind(e),
        shareApp: (f) => u.shareApp(f),
        shareCollection: (f, j) => _.shareCollection(te(), f, j),
        showAddApplicationModal: n.showAddApplicationModal.bind(o),
        showB2bIntroModal: (f) => r.showB2bIntroModal(f, te()),
        showCalendarModal: n.showCalendarModal.bind(n),
        showDistractionBlockerIntroModal:
          n.showDistractionBlockerIntroModal.bind(n),
        showFocusedTabInSwitcherByTabId: (f) => y.activateTab(te(), f),
        showGoogleContactsPicker: (f, j, ue) =>
          r.showGoogleContactsPicker(te(), f, j, ue),
        showInviteTeammatesModal: (f, j) => r.showInvitationModal(te(), f, j),
        showLimitsReachedModal: n.showLimitsReachedModal.bind(n),
        showNotReadyToUpgradeModal: t.showNotReadyModal.bind(t),
        showSignUpModal: m.showModal.bind(m),
        showSlackContactsPicker: (f, j) =>
          r.showSlackContactsPicker(te(), f, j),
        showUpgradeModal: n.showUpgradeModal.bind(n),
        showVideoModal: n.showVideoModal.bind(n),
        showWorkspaceCreationModal: (f) =>
          n.showWorkspaceCreationModal(f, te()),
        showWorkspaceEditingModal: n.showWorkspaceEditingModal.bind(n),
        showWorkspacesManagementModal: (f) =>
          n.showWorkspacesManagementModal(f, te()),
        signOut: () => s.signOut(te()),
        signOutWithClearData: s.signOutWithClearData.bind(s),
        startInvitingTeammates: (f) => r.startInvitationFlow(f, te()),
        startPlanUpgrade: s.startPlanUpgrade.bind(s),
        switchWalkthrough: O.switchWalkthrough.bind(O),
        toggleCalendarsIntegration: s.toggleCalendarsIntegration.bind(s),
        toggleCollections: (f) => E.toggleCollections(f, te()),
        toggleInactiveServiceGrayscale: (f) =>
          s.changeInteractiveServiceGrayscale(f),
        toggleSelectedSites: (f) => s.toggleSelectedSites(f),
        toggleShowingPhotoBackground: (f) => s.showPhotoBackground(f),
        toggleSidebarVisibility: (f) => {
          s.changeShowSidebar(te(), f);
        },
        toggleTabsDiscarding: (f) => s.changeDisableDiscarding(!f),
        toggleUseProxy: (f) => s.toggleUseProxy(f),
        tryShowVerticalSidecarView: () => E.tryShowVerticalSidecarView(te()),
        unshareCollection: (f, j) => _.unshareCollection(te(), f, j),
        updateAppCredentials: u.updateAppCredentials.bind(u),
        updateCalendarInfo: w.updateCalendarInfo.bind(w),
        updateCollection: (f, j) => _.updateCollection(te(), f, j),
        updateCollectionsLink: _.updateLink.bind(_),
        updatePaidTrialModalShowedDay: t.updatePaidTrialModalShowedDay.bind(t),
        use12HFormatInClock: (f) => s.changeUse12Format(f),
        useRandomUserAgent: (f) => s.changeRandomUserAgent(f),
      },
      queries: {
        loadAlarmSettings: () => i.loadAlarmSettings(te()),
        loadCollectionSharedRecipient: k.loadSharedRecipients.bind(k),
        loadDefaultBrowserQuery: () => s.loadDefaultBrowserQuery(),
        loadOauthData: n.loadOauthData.bind(n),
        loadUpgradePlanModalState: () => b.loadUpgradePlanModalState(),
        loadWorkspaceStatisticsState: T.loadWorkspaceStatisticsState.bind(T),
        saveOauthData: n.saveOauthData.bind(n),
        searchGlobally: (f) => d.searchGlobally({ ...f, windowId: te() }),
        updateInviterCode: s.updateInviterCode.bind(s),
      },
      stores: {
        activeCpuPopupId: he((f) => i.subscribeCurrentPopup(te(), f)),
        activeModalInfo: he((f) => n.subscribeCurrentModal(te(), f)),
        addApplicationModal: he((f) => o.subscribeAddApplication(te(), f)),
        collectionsShareModal: he((f) =>
          k.subscribeCollectionShareState(te(), f)
        ),
        globalSearch: d.subscribeGlobalSearchState.bind(d),
        globalSettingsAccountTab: he((f) => s.subscribeAccountTab(te(), f)),
        globalSettingsAdBlockerTab: s.subscribeAdBlockerTab.bind(s),
        globalSettingsAppearanceTab: he((f) =>
          s.subscribeAppearanceTab(te(), f)
        ),
        globalSettingsCpuMonitorTab: s.subscribeCpuMonitorTab.bind(s),
        globalSettingsDistractionBlocker:
          s.subscribeDistractionBlockerTab.bind(s),
        globalSettingsIntegrationsTab: s.subscribeIntegrationsTab.bind(s),
        globalSettingsModal: s.subscribeGlobalSettings.bind(s),
        globalSettingsOtherTab: s.subscribeOtherTab.bind(s),
        globalSettingsPrivacyTab: s.subscribePrivacyTab.bind(s),
        globalSettingsSuspenderTab: s.subscribeSuspenderTab.bind(s),
        marketplaceModal: he((f) => (f(a.loadMarketplaceData(te())), () => {})),
        marketplaceModalTabs: a.subscribeTabsLoading.bind(a),
        platform: p.subscribePlatform.bind(p),
        shareApplicationModal: he((f) => u.subscribeShareDataState(te(), f)),
        tabSwitcherModal: he((f) => y.subscribeTabSwitcherModalState(te(), f)),
        theme: v.subscribeTheme.bind(v),
        walkthrough: O.subscribeState.bind(O),
        workspaceEditModal: he((f) => I.subscribeEditWorkspace(te(), f)),
        workspaceManagmentModal: T.subscribeWorkspaceManagmentState.bind(T),
      },
    }),
  Kb = (o) => {
    let e = DT(o);
    return Ku(e), e;
  };
c();
var UT = (o) => (
    g(o.type === "popup", `Client type must be ${"popup"}`, {
      receivedType: o.type,
    }),
    o.windowId
  ),
  Ze = () => {
    let o = ct();
    return UT(o);
  },
  OT = ({
    analytics: o,
    applicationPopupApi: e,
    cpuMonitorPopupApi: t,
    exploreApi: r,
    hintsApi: i,
    modalApi: s,
    notificationsApi: a,
    notificationsSettingsPopupApi: n,
    platformApi: p,
    popupApi: d,
    productHuntApi: u,
    quickSessionSwitcherPopupApi: m,
    searchApi: y,
    themeApi: b,
    walkthroughApi: v,
    helpApi: S,
    adblockerPopupApi: w,
    sessionContextMenuApi: T,
    sessionListApi: I,
  }) =>
    Pr({
      actions: {
        activateCalendarsFeature: a.activateCalendarsFeature.bind(a),
        ...ua(e, Ze),
        addAdBlockerDomain: (k) => w.addAdblockerDomain(k),
        addNewTabToTabGroup: T.addNewTabToTabGroup.bind(T),
        addTabToCollection: (k) => T.addTabToCollection(k, Ze()),
        addTabToNewTabGroup: (k, _) => T.addTabToNewTabGroup(Ze(), k, _),
        addTabToTabGroup: T.addTabToTabGroup.bind(T),
        addTabToTasks: (k) => T.addTabToTasks(k, Ze()),
        changeSessionTabMuting: I.changeSessionTabMuting.bind(I),
        changeSessionTabPinning: I.changeSessionTabPinning.bind(I),
        closeHintAutomatically: (k) => i.closeHintAutomatically(Ze(), k),
        closeHintManually: (k) => i.closeHintManually(k),
        closeTabGroup: T.closeTabGroup.bind(T),
        confirmWalkthrough: (k) => v.confirmWalkthrough(Ze(), k),
        createWindowForSession: m.createWindowForSession.bind(m),
        duplicateSessionTab: I.duplicateSessionTab.bind(I),
        enableFocusMode: n.enableFocusMode.bind(n),
        explore: r.explore.bind(r),
        hideNotification: a.hideNotification.bind(a),
        hidePopup: (k) => {
          d.hidePopup(Ze(), k);
        },
        hideTabContextMenu: () => T.hideTabContextMenu(Ze()),
        hideTabGroupContextMenu: () => T.hideTabGroupContextMenu(Ze()),
        makeBrowserDefault: a.makeBrowserDefault.bind(a),
        makeGmailSignature: a.makeGmailSignature.bind(a),
        markTaskAsDoneAndCloseTimer: a.markTaskAsDoneAndCloseTimer.bind(a),
        moveSessionTabToSession: I.moveSessionTabToSession.bind(I),
        muteForHour: n.muteForHour.bind(n),
        muteUntilEvening: n.muteUntilEvening.bind(n),
        muteUntilNight: n.muteUntilNight.bind(n),
        muteUntilThisMorning: n.muteUntilThisMorning.bind(n),
        muteUntilTomorrowMorning: n.muteUntilTomorrowMorning.bind(n),
        notifyTabContextMenuHovered: (k) => T.notifyTabContextMenuHovered(k),
        notifyTabGroupContextMenuHovered: (k) =>
          T.notifyTabGroupContextMenuHovered(k),
        openAdblockerSettings: w.openAdBlockerSettings.bind(w),
        openBeforeLanding: u.openBeforeLanding.bind(u),
        openChromeImport: p.openChromeImport.bind(p),
        openDistractionBlockerSettings:
          n.openDistractionBlockerSettings.bind(n),
        openLiveLanding: u.openLiveLanding.bind(u),
        openNewTab: p.openTab.bind(p),
        openSearchItem: (k) => y.openSearchItem({ ...k, windowId: Ze() }),
        reloadSessionTab: I.reloadSessionTab.bind(I),
        removeAdBlockerDomain: (k) => w.removeAdblockerDomain(k),
        removeOtherSessionTabs: I.removeOtherSessionTabs.bind(I),
        removeSessionTab: I.removeSessionTab.bind(I),
        removeTabFromTabGroup: T.removeTabFromTabGroup.bind(T),
        resetQuickSwitcherIndex: () => m.resetIndex(),
        revealSessionWindow: (k) => m.revealSessionWindow(k),
        sendAnalyticsEvent: o.sendAnalyticsEvent.bind(o),
        showApplicationPopupSettings: (k) => d.showApplicationPopupSettings(k),
        showCalendarModal: s.showCalendarModal.bind(s),
        showCpuMonitorSettingPopup: s.showCpuMonitorSettingPopup.bind(s),
        showInvitationsPopup: e.showInvitationsPopup.bind(e),
        showTrialExpireSoonModal: a.showTrialExpireSoonModal.bind(a),
        skipCalendarsFeature: a.skipCalendarsFeature.bind(a),
        skipDefaultBrowserNotifications:
          a.skipDefaultBrowserNotifications.bind(a),
        startInvitesBonusTime: a.startInvitesBonusTime.bind(a),
        startPlanUpgrade: e.startPlanUpgrade.bind(e),
        switchSessionOfWindow: (k) => m.switchSessionOfWindow(k, Ze()),
        switchWalkthrough: v.switchWalkthrough.bind(v),
        toggleMute: n.toggleMute.bind(n),
        toggleSiteTaskPause: a.toggleSiteTaskPause.bind(a),
        ungroupTabsFromTabGroup: T.ungroupTabsFromTabGroup.bind(T),
        updateTabGroup: T.updateTabGroup.bind(T),
      },
      queries: {
        loadCpuNotificationState: () => t.loadNotificationsSettings(Ze()),
        searchInApp: (k) => y.searchInApp(k),
      },
      stores: {
        applicationPopup: he((k) => e.subscribeAppPopup(Ze(), k)),
        helpPanel: he((k) => S.subscribeHelpState(Ze(), k)),
        hints: he((k) => i.subscribeHintsState(Ze(), k)),
        notifications: a.subscribeNotifications.bind(a),
        notificationsSettingsPopup:
          n.subscribeNotificationsSettingsPopupState.bind(n),
        platform: p.subscribePlatform.bind(p),
        quickSessionSwitcherPopup: he((k) =>
          m.subscribeSessionSwitcherPopupState(Ze(), k)
        ),
        taskTrackerInfo: a.subscribeTaskTrackerInfo.bind(a),
        theme: b.subscribeTheme.bind(b),
        walkthrough: v.subscribeState.bind(v),
      },
    }),
  qb = (o) => {
    let e = OT(o);
    return $u(e), e;
  };
c();
var jT = (o) => (
    g(o.type === "sidecar", `Client type must be ${"sidecar"}`, {
      receivedType: o.type,
    }),
    o.windowId
  ),
  Se = () => {
    let o = ct();
    return jT(o);
  },
  NT = ({
    modalApi: o,
    helpApi: e,
    sessionListApi: t,
    sidecarApi: r,
    analytics: i,
    platformApi: s,
    exploreApi: a,
    collectionsListApi: n,
    sessionContextMenuApi: p,
    walkthroughApi: d,
    b2bModalApi: u,
  }) =>
    Pr({
      actions: {
        addCurrentTabToBookmarksCollection:
          n.addCurrentTabToBookmarksCollection.bind(n),
        addCurrentTabToCollection: (m) => n.addCurrentTabToCollection(Se(), m),
        addItemCompleteList: e.addFeatureToChecklist.bind(e),
        addLinkToBookmarksCollection: n.addLinkToBookmarksCollection.bind(n),
        addTabToCollection: (m) => p.addTabToCollection(m, Se()),
        addTabToTasks: (m) => p.addTabToTasks(m, Se()),
        changeIsHiddenWelcomeToCollections: (m) =>
          n.changeIsHiddenWelcomeToCollections(m),
        changeIsHiddenWelcomeToSessions: (m) =>
          t.changeIsHiddenWelcomeToSessions(m),
        changeSessionTabMuting: t.changeSessionTabMuting.bind(t),
        changeSessionTabPinning: t.changeSessionTabPinning.bind(t),
        closeBookmarksSuccessPopup: n.closeSuccessPopup.bind(n),
        closeSession: t.closeSession.bind(t),
        closeSidecar: () => r.closeSidecar(Se()),
        createBookmarkFolder: n.createBookmarkFolder.bind(n),
        createCollection: (m) => n.createCollection({ ...m, windowId: Se() }),
        createCollectionLink: (m, y, b) => n.createLink(m, y, b),
        createNewTab: t.createNewTab.bind(t),
        createTab: n.createTab.bind(n),
        createUserSession: (m) => {
          t.createUserSession(Se(), m);
        },
        createWindowForSession: (m) => t.createWindowForSession(m),
        deleteCollection: (m) => n.deleteCollection(m),
        deleteLink: (m) => n.deleteLink(m),
        duplicateSessionTab: (m, y) => t.duplicateSessionTab(m, y),
        explore: a.explore.bind(a),
        hideSidecar: (m) => r.hideSidecar(Se(), m),
        hideTabContextMenu: () => p.hideTabContextMenu(Se()),
        hideTabGroupContextMenu: () => p.hideTabGroupContextMenu(Se()),
        importBookmarks: n.importBookmarks.bind(n),
        moveBookmark: n.moveBookmark.bind(n),
        moveSessionTabToSession: t.moveSessionTabToSession.bind(t),
        openChromeImport: s.openChromeImport.bind(s),
        openChromeSettingsTab: s.openChromeShortcuts.bind(s),
        openSessionTab: (m) => t.openSessionTab(Se(), m),
        pinSidecar: () => r.pinSidecar(Se()),
        reloadSessionTab: (m, y) => t.reloadSessionTab(m, y),
        removeBookmark: n.removeBookmark.bind(n),
        removeBookmarkFolder: n.removeBookmarkFolder.bind(n),
        removeOtherSessionTabs: t.removeOtherSessionTabs.bind(t),
        removeSessionById: (m) => t.removeSessionById(m),
        removeSessionTab: t.removeSessionTab.bind(t),
        renameCollection: (m, y) => n.renameCollection(m, y),
        renameSession: (m, y) => t.renameSession(m, y),
        reorderSessionTab: (m, y, b) => t.reorderSessionTab(Se(), m, y, b),
        revealSessionWindow: (m) => t.revealSessionWindow(m),
        saveSession: t.saveSession.bind(t),
        sendAnalyticsEvent: i.sendAnalyticsEvent.bind(i),
        setHelpChecklistItemCompleted: e.setHelpChecklistItemCompleted.bind(e),
        showCollectionShareModal: o.showCollectionShareModal.bind(o),
        showIntegrationSettingsPopup: o.showIntegrationSettingsPopup.bind(o),
        showInvitationsPopup: e.showInvitationsPopup.bind(e),
        showTabContextMenu: (m) => p.showTabContextMenu(m, Se()),
        showTabGroupContextMenu: (m) => p.showTabGroupContextMenu(m, Se()),
        showVideoModal: o.showVideoModal.bind(o),
        startInvitingTeammates: (m) => u.startInvitationFlow(m, Se()),
        startPlanUpgrade: t.startPlanUpgrade.bind(t),
        switchSessionOfWindow: (m) => t.switchSessionOfWindow(m, Se()),
        switchWalkthrough: (m) => d.switchWalkthrough(m),
        toggleCollections: (m) => r.toggleCollections(m, Se()),
        toggleExploreSidekickPopup: e.toggleExploreSidekickPopup.bind(e),
        toggleFullscreen: (m) => r.toggleFullscreen(Se(), m),
        toggleSessions: (m) => r.toggleSessions(m, Se()),
        toggleTasks: (m) => r.toggleTasks(m, Se()),
        unpinSidecar: () => r.unpinSidecar(Se()),
        updateBookmark: n.updateBookmark.bind(n),
        updateCollection: (m, y) => n.updateCollection(Se(), m, y),
        updateCollectionsLink: n.updateLink.bind(n),
      },
      queries: {},
      stores: {
        collections: he((m) => n.subscribeCollections(Se(), m)),
        collectionsAndTasksEnableState: he((m) =>
          r.subscribeCollectionsAndTasksEnableState(Se(), m)
        ),
        collectionsBookmarks: n.subscribeCollectionsBookmarks.bind(n),
        collectionsError: n.subscribeCollectionError.bind(n),
        helpPanel: he((m) => e.subscribeHelpState(Se(), m)),
        lastCreatedCollection: n.subscribeLastCreatedCollection.bind(n),
        platform: s.subscribePlatform.bind(s),
        sessionListActiveTab: he((m) => t.subscribeActiveTab(Se(), m)),
        sessionsList: he((m) => t.subscribeSessionList(Se(), m)),
        sidecar: he((m) => r.subscribeSidecar(Se(), m)),
        verticalTabContextMenu: he((m) => p.subscribeToTabMenuState(Se(), m)),
        verticalTabGroupContextMenu: he((m) =>
          p.subscribeToTabGroupMenuState(Se(), m)
        ),
        walkthrough: d.subscribeState.bind(d),
      },
    }),
  zb = (o) => {
    let e = NT(o);
    return Vu(e), e;
  };
c();
c();
var ha = class {
  constructor(e) {
    this.collectionsBookmarksService = e;
  }
  importBookmarks() {
    return this.collectionsBookmarksService.importBookmarks();
  }
  addCurrentTabToBookmarksCollection(e) {
    return this.collectionsBookmarksService.addCurrentTabToBookmarksCollection(
      e
    );
  }
  addLinkToBookmarksCollection(e, t, r) {
    return this.collectionsBookmarksService.addLinkToBookmarksCollection(
      e,
      t,
      r
    );
  }
  removeBookmark(e) {
    return this.collectionsBookmarksService.removeBookmark(e);
  }
  removeBookmarkFolder(e) {
    return this.collectionsBookmarksService.removeBookmarkFolder(e);
  }
  moveBookmark(e, t) {
    return this.collectionsBookmarksService.moveBookmark(e, t);
  }
  updateBookmark(e, t) {
    return this.collectionsBookmarksService.updateBookmark(e, t);
  }
  closeSuccessPopup() {
    return this.collectionsBookmarksService.closeSuccessPopup();
  }
};
c();
c();
var se = new A(),
  Qb = ["billing-plan-loaded", "invitations-stats-loaded"];
var Ci = "sessions-pro-notification-alarm",
  LT = 1,
  ya = class {
    constructor(e, t, r, i, s, a, n, p) {
      this.notificationsService = e;
      this.featureFlagsRepository = t;
      this.browserService = r;
      this.browserStorage = i;
      this.browserEventsService = s;
      this.billingApi = a;
      this.userApi = n;
      this.onboardingDataService = p;
      let d = !1,
        u = !1;
      this.setWasSessionsEnabled(),
        this.featureFlagsRepository.onFeatureFlagsLoaded((m, y) => {
          y ||
            ((d = !0),
            this.initProSessionsPopup().catch(l),
            u && ((u = !1), this.tryShowPopup().catch(l)));
        }),
        se.on("billing-plan-loaded", () => {
          d && this.trySetupInterval().catch(l);
        }),
        this.browserEventsService.subscribeToAlarm((m) => {
          if (m.name === Ci) {
            if (!d) {
              u = !0;
              return;
            }
            this.tryShowPopup().catch(l);
          }
        }),
        this.tryShowAfterStart().catch(l);
    }
    async trySetupInterval() {
      let e = ur(pt(LT));
      (await this.browserService.getAlarmByName(Ci))?.periodInMinutes !== e &&
        (await this.disableFeature(),
        await this.setAlarm({ periodInMinutes: e }));
    }
    setAlarm(e) {
      return this.browserService.createAlarm(Ci, e), this.updateScheduledAt();
    }
    async initProSessionsPopup() {
      (
        await Promise.all([
          this.tryDisableFeature(),
          this.browserService.getAlarmByName(Ci),
        ])
      ).some(Boolean) || (await this.trySetupInterval());
    }
    async tryDisableFeature() {
      return this.featureFlagsRepository.getFeatureFlag("sessionsForOldUsers")
        .shouldShowUpgradePopup
        ? this.tryDisableBecauseAlreadyPro()
        : (await this.disableFeature(), !0);
    }
    async tryDisableBecauseAlreadyPro() {
      return this.billingApi.canUseSessions()
        ? (await this.disableFeature(), !0)
        : !1;
    }
    updateScheduledAt() {
      return this.browserStorage.setItem(
        "session-pro-notifications-alarm-scheduled-at",
        Date.now()
      );
    }
    disableFeature() {
      return Promise.all([
        this.browserStorage.removeItem(
          "session-pro-notifications-alarm-scheduled-at"
        ),
        this.browserService.clearAlarmByName(Ci),
      ]);
    }
    setWasSessionsEnabled() {
      let e = this.userApi.getSettings();
      e.wasSessionsEnabled === null &&
        (e.wasSessionsEnabled ??
          !this.onboardingDataService.getIsInitialOnboarding()) &&
        this.userApi.setWasSessionsEnabled();
    }
    async tryShowPopup() {
      (await this.tryDisableBecauseAlreadyPro()) ||
        (this.notificationsService.showSessionsBecomeProNotification(),
        !(await this.tryDisableFeature()) &&
          (await this.trySetupInterval(), await this.updateScheduledAt()));
    }
    async tryShowAfterStart() {
      let e = await this.browserStorage.getItem(
        "session-pro-notifications-alarm-scheduled-at"
      );
      if (!e) return;
      let t = await this.browserService.getAlarmByName(Ci);
      if (!t) {
        await this.tryShowPopup();
        return;
      }
      if (!t.periodInMinutes) return;
      let r = ye(t.periodInMinutes);
      Math.floor(t.scheduledTime) - e > r && (await this.tryShowPopup());
    }
  };
c();
var ba = class {
  constructor(e, t) {
    this.browserStorage = e;
    this.encryptionService = t;
    (this.keyset = this.encryptionService.getKeyset()),
      this.keyset
        ? this.init().catch(l)
        : this.encryptionService.onKeysetLoaded(() => {
            (this.keyset = this.encryptionService.getKeyset()),
              this.init().catch(l);
          });
  }
  emitter = new A();
  credentials = null;
  keyset = null;
  onCredentialsLoaded(e) {
    return this.emitter.on("app-sharing-credentials-loaded", e);
  }
  onCredentialsUpdated(e) {
    return this.emitter.on("app-sharing-credentials-update", e);
  }
  getCredentials() {
    return this.credentials;
  }
  updateCredentials(e) {
    g(this.credentials, "No credentials to update");
    let t = this.credentials[e.id];
    (t && Ri(e, t)) ||
      ((this.credentials[e.id] = {
        username: e.username,
        password: e.password,
        note: e.note,
      }),
      e.updateSilently ||
        this.emitter.emit("app-sharing-credentials-update", e.id),
      this.saveCredentialsToLs(this.credentials).catch(l));
  }
  async init() {
    await this.loadCredentialsFromLs(),
      this.emitter.emit("app-sharing-credentials-loaded");
  }
  async loadCredentialsFromLs() {
    let e = (await this.browserStorage.getItem("credentials-pairs")) ?? {},
      t = {};
    await Promise.all(
      Object.entries(e).map(async ([r, i]) => {
        let s = await this.encryptionService.decryptLocal(i);
        s !== null && (t[r] = s);
      })
    ),
      (this.credentials = t);
  }
  async saveCredentialsToLs(e) {
    let t = Object.fromEntries(
      await Promise.all(
        Object.entries(e).map(async ([r, i]) => [
          r,
          await this.encryptionService.encryptLocal(i),
        ])
      )
    );
    return this.browserStorage.setItem("credentials-pairs", t);
  }
};
c();
var cm = {};
Bo(cm, {
  publicKeyRoute: () => nm,
  serviceSharingRecipientsRoute: () => Di,
  updateServiceSharingRecipientsRoute: () => _a,
});
c();
c();
c();
var Mt = Ii(tg()),
  Ho = Ii(og()),
  lg = Ii(ag()),
  sI = Object.prototype.toString,
  aI = Error.prototype.toString,
  nI = RegExp.prototype.toString,
  cI = typeof Symbol < "u" ? Symbol.prototype.toString : () => "",
  pI = /^Symbol\((.*)\)(.*)$/;
function lI(o) {
  return o != +o ? "NaN" : o === 0 && 1 / o < 0 ? "-0" : "" + o;
}
function ng(o, e = !1) {
  if (o == null || o === !0 || o === !1) return "" + o;
  let t = typeof o;
  if (t === "number") return lI(o);
  if (t === "string") return e ? `"${o}"` : o;
  if (t === "function") return "[Function " + (o.name || "anonymous") + "]";
  if (t === "symbol") return cI.call(o).replace(pI, "Symbol($1)");
  let r = sI.call(o).slice(8, -1);
  return r === "Date"
    ? isNaN(o.getTime())
      ? "" + o
      : o.toISOString(o)
    : r === "Error" || o instanceof Error
    ? "[" + aI.call(o) + "]"
    : r === "RegExp"
    ? nI.call(o)
    : null;
}
function yr(o, e) {
  let t = ng(o, e);
  return t !== null
    ? t
    : JSON.stringify(
        o,
        function (r, i) {
          let s = ng(this[r], e);
          return s !== null ? s : i;
        },
        2
      );
}
function dg(o) {
  return o == null ? [] : [].concat(o);
}
var dI = /\$\{\s*(\w+)\s*\}/g,
  tt = class extends Error {
    static formatError(e, t) {
      let r = t.label || t.path || "this";
      return (
        r !== t.path && (t = Object.assign({}, t, { path: r })),
        typeof e == "string"
          ? e.replace(dI, (i, s) => yr(t[s]))
          : typeof e == "function"
          ? e(t)
          : e
      );
    }
    static isError(e) {
      return e && e.name === "ValidationError";
    }
    constructor(e, t, r, i) {
      super(),
        (this.value = void 0),
        (this.path = void 0),
        (this.type = void 0),
        (this.errors = void 0),
        (this.params = void 0),
        (this.inner = void 0),
        (this.name = "ValidationError"),
        (this.value = t),
        (this.path = r),
        (this.type = i),
        (this.errors = []),
        (this.inner = []),
        dg(e).forEach((s) => {
          tt.isError(s)
            ? (this.errors.push(...s.errors),
              (this.inner = this.inner.concat(s.inner.length ? s.inner : s)))
            : this.errors.push(s);
        }),
        (this.message =
          this.errors.length > 1
            ? `${this.errors.length} errors occurred`
            : this.errors[0]),
        Error.captureStackTrace && Error.captureStackTrace(this, tt);
    }
  },
  tr = {
    default: "${path} is invalid",
    required: "${path} is a required field",
    defined: "${path} must be defined",
    notNull: "${path} cannot be null",
    oneOf: "${path} must be one of the following values: ${values}",
    notOneOf: "${path} must not be one of the following values: ${values}",
    notType: ({ path: o, type: e, value: t, originalValue: r }) => {
      let i =
        r != null && r !== t ? ` (cast from the value \`${yr(r, !0)}\`).` : ".";
      return e !== "mixed"
        ? `${o} must be a \`${e}\` type, but the final value was: \`${yr(
            t,
            !0
          )}\`` + i
        : `${o} must match the configured type. The validated value was: \`${yr(
            t,
            !0
          )}\`` + i;
    },
  },
  $t = {
    length: "${path} must be exactly ${length} characters",
    min: "${path} must be at least ${min} characters",
    max: "${path} must be at most ${max} characters",
    matches: '${path} must match the following: "${regex}"',
    email: "${path} must be a valid email",
    url: "${path} must be a valid URL",
    uuid: "${path} must be a valid UUID",
    trim: "${path} must be a trimmed string",
    lowercase: "${path} must be a lowercase string",
    uppercase: "${path} must be a upper case string",
  },
  Cr = {
    min: "${path} must be greater than or equal to ${min}",
    max: "${path} must be less than or equal to ${max}",
    lessThan: "${path} must be less than ${less}",
    moreThan: "${path} must be greater than ${more}",
    positive: "${path} must be a positive number",
    negative: "${path} must be a negative number",
    integer: "${path} must be an integer",
  },
  em = {
    min: "${path} field must be later than ${min}",
    max: "${path} field must be at earlier than ${max}",
  },
  tm = { isValue: "${path} field must be ${value}" },
  rm = { noUnknown: "${path} field has unspecified keys: ${unknown}" },
  Sa = {
    min: "${path} field must have at least ${min} items",
    max: "${path} field must have less than or equal to ${max} items",
    length: "${path} must have ${length} items",
  },
  uI = {
    notType: (o) => {
      let { path: e, value: t, spec: r } = o,
        i = r.types.length;
      if (Array.isArray(t)) {
        if (t.length < i)
          return `${e} tuple value has too few items, expected a length of ${i} but got ${
            t.length
          } for value: \`${yr(t, !0)}\``;
        if (t.length > i)
          return `${e} tuple value has too many items, expected a length of ${i} but got ${
            t.length
          } for value: \`${yr(t, !0)}\``;
      }
      return tt.formatError(tr.notType, o);
    },
  },
  Bx = Object.assign(Object.create(null), {
    mixed: tr,
    string: $t,
    number: Cr,
    date: em,
    object: rm,
    array: Sa,
    boolean: tm,
  }),
  Ba = (o) => o && o.__isYupSchema__,
  Mi = class {
    static fromOptions(e, t) {
      if (!t.then && !t.otherwise)
        throw new TypeError(
          "either `then:` or `otherwise:` is required for `when()` conditions"
        );
      let { is: r, then: i, otherwise: s } = t,
        a = typeof r == "function" ? r : (...n) => n.every((p) => p === r);
      return new Mi(e, (n, p) => {
        var d;
        let u = a(...n) ? i : s;
        return (d = u?.(p)) != null ? d : p;
      });
    }
    constructor(e, t) {
      (this.fn = void 0), (this.refs = e), (this.refs = e), (this.fn = t);
    }
    resolve(e, t) {
      let r = this.refs.map((s) => s.getValue(t?.value, t?.parent, t?.context)),
        i = this.fn(r, e, t);
      if (i === void 0 || i === e) return e;
      if (!Ba(i)) throw new TypeError("conditions must return a schema object");
      return i.resolve(t);
    }
  },
  fa = { context: "$", value: "." };
var br = class {
  constructor(e, t = {}) {
    if (
      ((this.key = void 0),
      (this.isContext = void 0),
      (this.isValue = void 0),
      (this.isSibling = void 0),
      (this.path = void 0),
      (this.getter = void 0),
      (this.map = void 0),
      typeof e != "string")
    )
      throw new TypeError("ref must be a string, got: " + e);
    if (((this.key = e.trim()), e === ""))
      throw new TypeError("ref must be a non-empty string");
    (this.isContext = this.key[0] === fa.context),
      (this.isValue = this.key[0] === fa.value),
      (this.isSibling = !this.isContext && !this.isValue);
    let r = this.isContext ? fa.context : this.isValue ? fa.value : "";
    (this.path = this.key.slice(r.length)),
      (this.getter = this.path && (0, Mt.getter)(this.path, !0)),
      (this.map = t.map);
  }
  getValue(e, t, r) {
    let i = this.isContext ? r : this.isValue ? e : t;
    return (
      this.getter && (i = this.getter(i || {})),
      this.map && (i = this.map(i)),
      i
    );
  }
  cast(e, t) {
    return this.getValue(e, t?.parent, t?.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return { type: "ref", key: this.key };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(e) {
    return e && e.__isYupRef;
  }
};
br.prototype.__isYupRef = !0;
var Kt = (o) => o == null;
function _i(o) {
  function e(
    { value: t, path: r = "", options: i, originalValue: s, schema: a },
    n,
    p
  ) {
    let { name: d, test: u, params: m, message: y, skipAbsent: b } = o,
      { parent: v, context: S, abortEarly: w = a.spec.abortEarly } = i;
    function T(Q) {
      return br.isRef(Q) ? Q.getValue(t, v, S) : Q;
    }
    function I(Q = {}) {
      let C = Object.assign(
        {
          value: t,
          originalValue: s,
          label: a.spec.label,
          path: Q.path || r,
          spec: a.spec,
        },
        m,
        Q.params
      );
      for (let K of Object.keys(C)) C[K] = T(C[K]);
      let G = new tt(tt.formatError(Q.message || y, C), t, C.path, Q.type || d);
      return (G.params = C), G;
    }
    let k = w ? n : p,
      _ = {
        path: r,
        parent: v,
        type: d,
        from: i.from,
        createError: I,
        resolve: T,
        options: i,
        originalValue: s,
        schema: a,
      },
      O = (Q) => {
        tt.isError(Q) ? k(Q) : Q ? p(null) : k(I());
      },
      E = (Q) => {
        tt.isError(Q) ? k(Q) : n(Q);
      },
      f = b && Kt(t);
    if (!i.sync) {
      try {
        Promise.resolve(f ? !0 : u.call(_, t, _)).then(O, E);
      } catch (Q) {
        E(Q);
      }
      return;
    }
    let j;
    try {
      var ue;
      if (
        ((j = f ? !0 : u.call(_, t, _)),
        typeof ((ue = j) == null ? void 0 : ue.then) == "function")
      )
        throw new Error(
          `Validation test of type: "${_.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`
        );
    } catch (Q) {
      E(Q);
      return;
    }
    O(j);
  }
  return (e.OPTIONS = o), e;
}
function mI(o, e, t, r = t) {
  let i, s, a;
  return e
    ? ((0, Mt.forEach)(e, (n, p, d) => {
        let u = p ? n.slice(1, n.length - 1) : n;
        o = o.resolve({ context: r, parent: i, value: t });
        let m = o.type === "tuple",
          y = d ? parseInt(u, 10) : 0;
        if (o.innerType || m) {
          if (m && !d)
            throw new Error(
              `Yup.reach cannot implicitly index into a tuple type. the path part "${a}" must contain an index to the tuple element, e.g. "${a}[0]"`
            );
          if (t && y >= t.length)
            throw new Error(
              `Yup.reach cannot resolve an array item at index: ${n}, in the path: ${e}. because there is no value at that index. `
            );
          (i = t), (t = t && t[y]), (o = m ? o.spec.types[y] : o.innerType);
        }
        if (!d) {
          if (!o.fields || !o.fields[u])
            throw new Error(
              `The schema does not contain the path: ${e}. (failed at: ${a} which is a type: "${o.type}")`
            );
          (i = t), (t = t && t[u]), (o = o.fields[u]);
        }
        (s = u), (a = p ? "[" + n + "]" : "." + n);
      }),
      { schema: o, parent: i, parentPath: s })
    : { parent: i, parentPath: e, schema: o };
}
var xi = class extends Set {
  describe() {
    let e = [];
    for (let t of this.values()) e.push(br.isRef(t) ? t.describe() : t);
    return e;
  }
  resolveAll(e) {
    let t = [];
    for (let r of this.values()) t.push(e(r));
    return t;
  }
  clone() {
    return new xi(this.values());
  }
  merge(e, t) {
    let r = this.clone();
    return e.forEach((i) => r.add(i)), t.forEach((i) => r.delete(i)), r;
  }
};
function Fi(o, e = new Map()) {
  if (Ba(o) || !o || typeof o != "object") return o;
  if (e.has(o)) return e.get(o);
  let t;
  if (o instanceof Date) (t = new Date(o.getTime())), e.set(o, t);
  else if (o instanceof RegExp) (t = new RegExp(o)), e.set(o, t);
  else if (Array.isArray(o)) {
    (t = new Array(o.length)), e.set(o, t);
    for (let r = 0; r < o.length; r++) t[r] = Fi(o[r], e);
  } else if (o instanceof Map) {
    (t = new Map()), e.set(o, t);
    for (let [r, i] of o.entries()) t.set(r, Fi(i, e));
  } else if (o instanceof Set) {
    (t = new Set()), e.set(o, t);
    for (let r of o) t.add(Fi(r, e));
  } else if (o instanceof Object) {
    (t = {}), e.set(o, t);
    for (let [r, i] of Object.entries(o)) t[r] = Fi(i, e);
  } else throw Error(`Unable to clone ${o}`);
  return t;
}
var ze = class {
  constructor(e) {
    (this.type = void 0),
      (this.deps = []),
      (this.tests = void 0),
      (this.transforms = void 0),
      (this.conditions = []),
      (this._mutate = void 0),
      (this.internalTests = {}),
      (this._whitelist = new xi()),
      (this._blacklist = new xi()),
      (this.exclusiveTests = Object.create(null)),
      (this._typeCheck = void 0),
      (this.spec = void 0),
      (this.tests = []),
      (this.transforms = []),
      this.withMutation(() => {
        this.typeError(tr.notType);
      }),
      (this.type = e.type),
      (this._typeCheck = e.check),
      (this.spec = Object.assign(
        {
          strip: !1,
          strict: !1,
          abortEarly: !0,
          recursive: !0,
          nullable: !1,
          optional: !0,
          coerce: !0,
        },
        e?.spec
      )),
      this.withMutation((t) => {
        t.nonNullable();
      });
  }
  get _type() {
    return this.type;
  }
  clone(e) {
    if (this._mutate) return e && Object.assign(this.spec, e), this;
    let t = Object.create(Object.getPrototypeOf(this));
    return (
      (t.type = this.type),
      (t._typeCheck = this._typeCheck),
      (t._whitelist = this._whitelist.clone()),
      (t._blacklist = this._blacklist.clone()),
      (t.internalTests = Object.assign({}, this.internalTests)),
      (t.exclusiveTests = Object.assign({}, this.exclusiveTests)),
      (t.deps = [...this.deps]),
      (t.conditions = [...this.conditions]),
      (t.tests = [...this.tests]),
      (t.transforms = [...this.transforms]),
      (t.spec = Fi(Object.assign({}, this.spec, e))),
      t
    );
  }
  label(e) {
    let t = this.clone();
    return (t.spec.label = e), t;
  }
  meta(...e) {
    if (e.length === 0) return this.spec.meta;
    let t = this.clone();
    return (t.spec.meta = Object.assign(t.spec.meta || {}, e[0])), t;
  }
  withMutation(e) {
    let t = this._mutate;
    this._mutate = !0;
    let r = e(this);
    return (this._mutate = t), r;
  }
  concat(e) {
    if (!e || e === this) return this;
    if (e.type !== this.type && this.type !== "mixed")
      throw new TypeError(
        `You cannot \`concat()\` schema's of different types: ${this.type} and ${e.type}`
      );
    let t = this,
      r = e.clone(),
      i = Object.assign({}, t.spec, r.spec);
    return (
      (r.spec = i),
      (r.internalTests = Object.assign({}, t.internalTests, r.internalTests)),
      (r._whitelist = t._whitelist.merge(e._whitelist, e._blacklist)),
      (r._blacklist = t._blacklist.merge(e._blacklist, e._whitelist)),
      (r.tests = t.tests),
      (r.exclusiveTests = t.exclusiveTests),
      r.withMutation((s) => {
        e.tests.forEach((a) => {
          s.test(a.OPTIONS);
        });
      }),
      (r.transforms = [...t.transforms, ...r.transforms]),
      r
    );
  }
  isType(e) {
    return e == null
      ? !!(
          (this.spec.nullable && e === null) ||
          (this.spec.optional && e === void 0)
        )
      : this._typeCheck(e);
  }
  resolve(e) {
    let t = this;
    if (t.conditions.length) {
      let r = t.conditions;
      (t = t.clone()),
        (t.conditions = []),
        (t = r.reduce((i, s) => s.resolve(i, e), t)),
        (t = t.resolve(e));
    }
    return t;
  }
  resolveOptions(e) {
    var t, r, i;
    return Object.assign({}, e, {
      from: e.from || [],
      strict: (t = e.strict) != null ? t : this.spec.strict,
      abortEarly: (r = e.abortEarly) != null ? r : this.spec.abortEarly,
      recursive: (i = e.recursive) != null ? i : this.spec.recursive,
    });
  }
  cast(e, t = {}) {
    let r = this.resolve(Object.assign({ value: e }, t)),
      i = t.assert === "ignore-optionality",
      s = r._cast(e, t);
    if (t.assert !== !1 && !r.isType(s)) {
      if (i && Kt(s)) return s;
      let a = yr(e),
        n = yr(s);
      throw new TypeError(
        `The value of ${
          t.path || "field"
        } could not be cast to a value that satisfies the schema type: "${
          r.type
        }". 

attempted value: ${a} 
` + (n !== a ? `result of cast: ${n}` : "")
      );
    }
    return s;
  }
  _cast(e, t) {
    let r =
      e === void 0
        ? e
        : this.transforms.reduce((i, s) => s.call(this, i, e, this), e);
    return r === void 0 && (r = this.getDefault(t)), r;
  }
  _validate(e, t = {}, r, i) {
    let { path: s, originalValue: a = e, strict: n = this.spec.strict } = t,
      p = e;
    n || (p = this._cast(p, Object.assign({ assert: !1 }, t)));
    let d = [];
    for (let u of Object.values(this.internalTests)) u && d.push(u);
    this.runTests(
      { path: s, value: p, originalValue: a, options: t, tests: d },
      r,
      (u) => {
        if (u.length) return i(u, p);
        this.runTests(
          {
            path: s,
            value: p,
            originalValue: a,
            options: t,
            tests: this.tests,
          },
          r,
          i
        );
      }
    );
  }
  runTests(e, t, r) {
    let i = !1,
      { tests: s, value: a, originalValue: n, path: p, options: d } = e,
      u = (S) => {
        i || ((i = !0), t(S, a));
      },
      m = (S) => {
        i || ((i = !0), r(S, a));
      },
      y = s.length,
      b = [];
    if (!y) return m([]);
    let v = { value: a, originalValue: n, path: p, options: d, schema: this };
    for (let S = 0; S < s.length; S++) {
      let w = s[S];
      w(v, u, function (I) {
        I && (b = b.concat(I)), --y <= 0 && m(b);
      });
    }
  }
  asNestedTest({
    key: e,
    index: t,
    parent: r,
    parentPath: i,
    originalParent: s,
    options: a,
  }) {
    let n = e ?? t;
    if (n == null)
      throw TypeError("Must include `key` or `index` for nested validations");
    let p = typeof n == "number",
      d = r[n],
      u = Object.assign({}, a, {
        strict: !0,
        parent: r,
        value: d,
        originalValue: s[n],
        key: void 0,
        [p ? "index" : "key"]: n,
        path:
          p || n.includes(".")
            ? `${i || ""}[${d ? n : `"${n}"`}]`
            : (i ? `${i}.` : "") + e,
      });
    return (m, y, b) => this.resolve(u)._validate(d, u, y, b);
  }
  validate(e, t) {
    let r = this.resolve(Object.assign({}, t, { value: e }));
    return new Promise((i, s) =>
      r._validate(
        e,
        t,
        (a, n) => {
          tt.isError(a) && (a.value = n), s(a);
        },
        (a, n) => {
          a.length ? s(new tt(a, n)) : i(n);
        }
      )
    );
  }
  validateSync(e, t) {
    let r = this.resolve(Object.assign({}, t, { value: e })),
      i;
    return (
      r._validate(
        e,
        Object.assign({}, t, { sync: !0 }),
        (s, a) => {
          throw (tt.isError(s) && (s.value = a), s);
        },
        (s, a) => {
          if (s.length) throw new tt(s, e);
          i = a;
        }
      ),
      i
    );
  }
  isValid(e, t) {
    return this.validate(e, t).then(
      () => !0,
      (r) => {
        if (tt.isError(r)) return !1;
        throw r;
      }
    );
  }
  isValidSync(e, t) {
    try {
      return this.validateSync(e, t), !0;
    } catch (r) {
      if (tt.isError(r)) return !1;
      throw r;
    }
  }
  _getDefault(e) {
    let t = this.spec.default;
    return t == null ? t : typeof t == "function" ? t.call(this, e) : Fi(t);
  }
  getDefault(e) {
    return this.resolve(e || {})._getDefault(e);
  }
  default(e) {
    return arguments.length === 0
      ? this._getDefault()
      : this.clone({ default: e });
  }
  strict(e = !0) {
    return this.clone({ strict: e });
  }
  nullability(e, t) {
    let r = this.clone({ nullable: e });
    return (
      (r.internalTests.nullable = _i({
        message: t,
        name: "nullable",
        test(i) {
          return i === null ? this.schema.spec.nullable : !0;
        },
      })),
      r
    );
  }
  optionality(e, t) {
    let r = this.clone({ optional: e });
    return (
      (r.internalTests.optionality = _i({
        message: t,
        name: "optionality",
        test(i) {
          return i === void 0 ? this.schema.spec.optional : !0;
        },
      })),
      r
    );
  }
  optional() {
    return this.optionality(!0);
  }
  defined(e = tr.defined) {
    return this.optionality(!1, e);
  }
  nullable() {
    return this.nullability(!0);
  }
  nonNullable(e = tr.notNull) {
    return this.nullability(!1, e);
  }
  required(e = tr.required) {
    return this.clone().withMutation((t) => t.nonNullable(e).defined(e));
  }
  notRequired() {
    return this.clone().withMutation((e) => e.nullable().optional());
  }
  transform(e) {
    let t = this.clone();
    return t.transforms.push(e), t;
  }
  test(...e) {
    let t;
    if (
      (e.length === 1
        ? typeof e[0] == "function"
          ? (t = { test: e[0] })
          : (t = e[0])
        : e.length === 2
        ? (t = { name: e[0], test: e[1] })
        : (t = { name: e[0], message: e[1], test: e[2] }),
      t.message === void 0 && (t.message = tr.default),
      typeof t.test != "function")
    )
      throw new TypeError("`test` is a required parameters");
    let r = this.clone(),
      i = _i(t),
      s = t.exclusive || (t.name && r.exclusiveTests[t.name] === !0);
    if (t.exclusive && !t.name)
      throw new TypeError(
        "Exclusive tests must provide a unique `name` identifying the test"
      );
    return (
      t.name && (r.exclusiveTests[t.name] = !!t.exclusive),
      (r.tests = r.tests.filter(
        (a) =>
          !(
            a.OPTIONS.name === t.name &&
            (s || a.OPTIONS.test === i.OPTIONS.test)
          )
      )),
      r.tests.push(i),
      r
    );
  }
  when(e, t) {
    !Array.isArray(e) && typeof e != "string" && ((t = e), (e = "."));
    let r = this.clone(),
      i = dg(e).map((s) => new br(s));
    return (
      i.forEach((s) => {
        s.isSibling && r.deps.push(s.key);
      }),
      r.conditions.push(
        typeof t == "function" ? new Mi(i, t) : Mi.fromOptions(i, t)
      ),
      r
    );
  }
  typeError(e) {
    let t = this.clone();
    return (
      (t.internalTests.typeError = _i({
        message: e,
        name: "typeError",
        skipAbsent: !0,
        test(r) {
          return this.schema._typeCheck(r)
            ? !0
            : this.createError({ params: { type: this.schema.type } });
        },
      })),
      t
    );
  }
  oneOf(e, t = tr.oneOf) {
    let r = this.clone();
    return (
      e.forEach((i) => {
        r._whitelist.add(i), r._blacklist.delete(i);
      }),
      (r.internalTests.whiteList = _i({
        message: t,
        name: "oneOf",
        skipAbsent: !0,
        test(i) {
          let s = this.schema._whitelist,
            a = s.resolveAll(this.resolve);
          return a.includes(i)
            ? !0
            : this.createError({
                params: { values: Array.from(s).join(", "), resolved: a },
              });
        },
      })),
      r
    );
  }
  notOneOf(e, t = tr.notOneOf) {
    let r = this.clone();
    return (
      e.forEach((i) => {
        r._blacklist.add(i), r._whitelist.delete(i);
      }),
      (r.internalTests.blacklist = _i({
        message: t,
        name: "notOneOf",
        test(i) {
          let s = this.schema._blacklist,
            a = s.resolveAll(this.resolve);
          return a.includes(i)
            ? this.createError({
                params: { values: Array.from(s).join(", "), resolved: a },
              })
            : !0;
        },
      })),
      r
    );
  }
  strip(e = !0) {
    let t = this.clone();
    return (t.spec.strip = e), t;
  }
  describe(e) {
    let t = (e ? this.resolve(e) : this).clone(),
      { label: r, meta: i, optional: s, nullable: a } = t.spec;
    return {
      meta: i,
      label: r,
      optional: s,
      nullable: a,
      default: t.getDefault(e),
      type: t.type,
      oneOf: t._whitelist.describe(),
      notOneOf: t._blacklist.describe(),
      tests: t.tests
        .map((p) => ({ name: p.OPTIONS.name, params: p.OPTIONS.params }))
        .filter((p, d, u) => u.findIndex((m) => m.name === p.name) === d),
    };
  }
};
ze.prototype.__isYupSchema__ = !0;
for (let o of ["validate", "validateSync"])
  ze.prototype[`${o}At`] = function (e, t, r = {}) {
    let { parent: i, parentPath: s, schema: a } = mI(this, e, t, r.context);
    return a[o](i && i[s], Object.assign({}, r, { parent: i, path: e }));
  };
for (let o of ["equals", "is"]) ze.prototype[o] = ze.prototype.oneOf;
for (let o of ["not", "nope"]) ze.prototype[o] = ze.prototype.notOneOf;
var hI = () => !0;
function rt(o) {
  return new ka(o);
}
var ka = class extends ze {
  constructor(e) {
    super(
      typeof e == "function"
        ? { type: "mixed", check: e }
        : Object.assign({ type: "mixed", check: hI }, e)
    );
  }
};
rt.prototype = ka.prototype;
function H() {
  return new Ta();
}
var Ta = class extends ze {
  constructor() {
    super({
      type: "boolean",
      check(e) {
        return e instanceof Boolean && (e = e.valueOf()), typeof e == "boolean";
      },
    }),
      this.withMutation(() => {
        this.transform((e, t, r) => {
          if (r.spec.coerce && !r.isType(e)) {
            if (/^(true|1)$/i.test(String(e))) return !0;
            if (/^(false|0)$/i.test(String(e))) return !1;
          }
          return e;
        });
      });
  }
  isTrue(e = tm.isValue) {
    return this.test({
      message: e,
      name: "is-value",
      exclusive: !0,
      params: { value: "true" },
      test(t) {
        return Kt(t) || t === !0;
      },
    });
  }
  isFalse(e = tm.isValue) {
    return this.test({
      message: e,
      name: "is-value",
      exclusive: !0,
      params: { value: "false" },
      test(t) {
        return Kt(t) || t === !1;
      },
    });
  }
  default(e) {
    return super.default(e);
  }
  defined(e) {
    return super.defined(e);
  }
  optional() {
    return super.optional();
  }
  required(e) {
    return super.required(e);
  }
  notRequired() {
    return super.notRequired();
  }
  nullable() {
    return super.nullable();
  }
  nonNullable(e) {
    return super.nonNullable(e);
  }
  strip(e) {
    return super.strip(e);
  }
};
H.prototype = Ta.prototype;
var yI =
    /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
  bI =
    /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i,
  gI =
    /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i,
  vI = (o) => Kt(o) || o === o.trim(),
  fI = {}.toString();
function M() {
  return new Ia();
}
var Ia = class extends ze {
  constructor() {
    super({
      type: "string",
      check(e) {
        return e instanceof String && (e = e.valueOf()), typeof e == "string";
      },
    }),
      this.withMutation(() => {
        this.transform((e, t, r) => {
          if (!r.spec.coerce || r.isType(e) || Array.isArray(e)) return e;
          let i = e != null && e.toString ? e.toString() : e;
          return i === fI ? e : i;
        });
      });
  }
  required(e) {
    return super.required(e).withMutation((t) =>
      t.test({
        message: e || tr.required,
        name: "required",
        skipAbsent: !0,
        test: (r) => !!r.length,
      })
    );
  }
  notRequired() {
    return super
      .notRequired()
      .withMutation(
        (e) => (
          (e.tests = e.tests.filter((t) => t.OPTIONS.name !== "required")), e
        )
      );
  }
  length(e, t = $t.length) {
    return this.test({
      message: t,
      name: "length",
      exclusive: !0,
      params: { length: e },
      skipAbsent: !0,
      test(r) {
        return r.length === this.resolve(e);
      },
    });
  }
  min(e, t = $t.min) {
    return this.test({
      message: t,
      name: "min",
      exclusive: !0,
      params: { min: e },
      skipAbsent: !0,
      test(r) {
        return r.length >= this.resolve(e);
      },
    });
  }
  max(e, t = $t.max) {
    return this.test({
      name: "max",
      exclusive: !0,
      message: t,
      params: { max: e },
      skipAbsent: !0,
      test(r) {
        return r.length <= this.resolve(e);
      },
    });
  }
  matches(e, t) {
    let r = !1,
      i,
      s;
    return (
      t &&
        (typeof t == "object"
          ? ({ excludeEmptyString: r = !1, message: i, name: s } = t)
          : (i = t)),
      this.test({
        name: s || "matches",
        message: i || $t.matches,
        params: { regex: e },
        skipAbsent: !0,
        test: (a) => (a === "" && r) || a.search(e) !== -1,
      })
    );
  }
  email(e = $t.email) {
    return this.matches(yI, {
      name: "email",
      message: e,
      excludeEmptyString: !0,
    });
  }
  url(e = $t.url) {
    return this.matches(bI, {
      name: "url",
      message: e,
      excludeEmptyString: !0,
    });
  }
  uuid(e = $t.uuid) {
    return this.matches(gI, {
      name: "uuid",
      message: e,
      excludeEmptyString: !1,
    });
  }
  ensure() {
    return this.default("").transform((e) => (e === null ? "" : e));
  }
  trim(e = $t.trim) {
    return this.transform((t) => (t != null ? t.trim() : t)).test({
      message: e,
      name: "trim",
      test: vI,
    });
  }
  lowercase(e = $t.lowercase) {
    return this.transform((t) => (Kt(t) ? t : t.toLowerCase())).test({
      message: e,
      name: "string_case",
      exclusive: !0,
      skipAbsent: !0,
      test: (t) => Kt(t) || t === t.toLowerCase(),
    });
  }
  uppercase(e = $t.uppercase) {
    return this.transform((t) => (Kt(t) ? t : t.toUpperCase())).test({
      message: e,
      name: "string_case",
      exclusive: !0,
      skipAbsent: !0,
      test: (t) => Kt(t) || t === t.toUpperCase(),
    });
  }
};
M.prototype = Ia.prototype;
var SI = (o) => o != +o;
function Te() {
  return new Aa();
}
var Aa = class extends ze {
  constructor() {
    super({
      type: "number",
      check(e) {
        return (
          e instanceof Number && (e = e.valueOf()),
          typeof e == "number" && !SI(e)
        );
      },
    }),
      this.withMutation(() => {
        this.transform((e, t, r) => {
          if (!r.spec.coerce) return e;
          let i = e;
          if (typeof i == "string") {
            if (((i = i.replace(/\s/g, "")), i === "")) return NaN;
            i = +i;
          }
          return r.isType(i) || i === null ? i : parseFloat(i);
        });
      });
  }
  min(e, t = Cr.min) {
    return this.test({
      message: t,
      name: "min",
      exclusive: !0,
      params: { min: e },
      skipAbsent: !0,
      test(r) {
        return r >= this.resolve(e);
      },
    });
  }
  max(e, t = Cr.max) {
    return this.test({
      message: t,
      name: "max",
      exclusive: !0,
      params: { max: e },
      skipAbsent: !0,
      test(r) {
        return r <= this.resolve(e);
      },
    });
  }
  lessThan(e, t = Cr.lessThan) {
    return this.test({
      message: t,
      name: "max",
      exclusive: !0,
      params: { less: e },
      skipAbsent: !0,
      test(r) {
        return r < this.resolve(e);
      },
    });
  }
  moreThan(e, t = Cr.moreThan) {
    return this.test({
      message: t,
      name: "min",
      exclusive: !0,
      params: { more: e },
      skipAbsent: !0,
      test(r) {
        return r > this.resolve(e);
      },
    });
  }
  positive(e = Cr.positive) {
    return this.moreThan(0, e);
  }
  negative(e = Cr.negative) {
    return this.lessThan(0, e);
  }
  integer(e = Cr.integer) {
    return this.test({
      name: "integer",
      message: e,
      skipAbsent: !0,
      test: (t) => Number.isInteger(t),
    });
  }
  truncate() {
    return this.transform((e) => (Kt(e) ? e : e | 0));
  }
  round(e) {
    var t;
    let r = ["ceil", "floor", "round", "trunc"];
    if (
      ((e = ((t = e) == null ? void 0 : t.toLowerCase()) || "round"),
      e === "trunc")
    )
      return this.truncate();
    if (r.indexOf(e.toLowerCase()) === -1)
      throw new TypeError(
        "Only valid options for round() are: " + r.join(", ")
      );
    return this.transform((i) => (Kt(i) ? i : Math[e](i)));
  }
};
Te.prototype = Aa.prototype;
var wI =
  /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
function kI(o) {
  var e = [1, 4, 5, 6, 7, 10, 11],
    t = 0,
    r,
    i;
  if ((i = wI.exec(o))) {
    for (var s = 0, a; (a = e[s]); ++s) i[a] = +i[a] || 0;
    (i[2] = (+i[2] || 1) - 1),
      (i[3] = +i[3] || 1),
      (i[7] = i[7] ? String(i[7]).substr(0, 3) : 0),
      (i[8] === void 0 || i[8] === "") && (i[9] === void 0 || i[9] === "")
        ? (r = +new Date(i[1], i[2], i[3], i[4], i[5], i[6], i[7]))
        : (i[8] !== "Z" &&
            i[9] !== void 0 &&
            ((t = i[10] * 60 + i[11]), i[9] === "+" && (t = 0 - t)),
          (r = Date.UTC(i[1], i[2], i[3], i[4], i[5] + t, i[6], i[7])));
  } else r = Date.parse ? Date.parse(o) : NaN;
  return r;
}
var ug = new Date(""),
  TI = (o) => Object.prototype.toString.call(o) === "[object Date]";
function mg() {
  return new Xr();
}
var Xr = class extends ze {
  constructor() {
    super({
      type: "date",
      check(e) {
        return TI(e) && !isNaN(e.getTime());
      },
    }),
      this.withMutation(() => {
        this.transform((e, t, r) =>
          !r.spec.coerce || r.isType(e) || e === null
            ? e
            : ((e = kI(e)), isNaN(e) ? Xr.INVALID_DATE : new Date(e))
        );
      });
  }
  prepareParam(e, t) {
    let r;
    if (br.isRef(e)) r = e;
    else {
      let i = this.cast(e);
      if (!this._typeCheck(i))
        throw new TypeError(
          `\`${t}\` must be a Date or a value that can be \`cast()\` to a Date`
        );
      r = i;
    }
    return r;
  }
  min(e, t = em.min) {
    let r = this.prepareParam(e, "min");
    return this.test({
      message: t,
      name: "min",
      exclusive: !0,
      params: { min: e },
      skipAbsent: !0,
      test(i) {
        return i >= this.resolve(r);
      },
    });
  }
  max(e, t = em.max) {
    let r = this.prepareParam(e, "max");
    return this.test({
      message: t,
      name: "max",
      exclusive: !0,
      params: { max: e },
      skipAbsent: !0,
      test(i) {
        return i <= this.resolve(r);
      },
    });
  }
};
Xr.INVALID_DATE = ug;
mg.prototype = Xr.prototype;
mg.INVALID_DATE = ug;
function II(o, e = []) {
  let t = [],
    r = new Set(),
    i = new Set(e.map(([a, n]) => `${a}-${n}`));
  function s(a, n) {
    let p = (0, Mt.split)(a)[0];
    r.add(p), i.has(`${n}-${p}`) || t.push([n, p]);
  }
  for (let a of Object.keys(o)) {
    let n = o[a];
    r.add(a),
      br.isRef(n) && n.isSibling
        ? s(n.path, a)
        : Ba(n) && "deps" in n && n.deps.forEach((p) => s(p, a));
  }
  return lg.default.array(Array.from(r), t).reverse();
}
function cg(o, e) {
  let t = 1 / 0;
  return (
    o.some((r, i) => {
      var s;
      if ((s = e.path) != null && s.includes(r)) return (t = i), !0;
    }),
    t
  );
}
function hg(o) {
  return (e, t) => cg(o, e) - cg(o, t);
}
var yg = (o, e, t) => {
  if (typeof o != "string") return o;
  let r = o;
  try {
    r = JSON.parse(o);
  } catch {}
  return t.isType(r) ? r : o;
};
function wa(o) {
  if ("fields" in o) {
    let e = {};
    for (let [t, r] of Object.entries(o.fields)) e[t] = wa(r);
    return o.setFields(e);
  }
  if (o.type === "array") {
    let e = o.optional();
    return e.innerType && (e.innerType = wa(e.innerType)), e;
  }
  return o.type === "tuple"
    ? o.optional().clone({ types: o.spec.types.map(wa) })
    : "optional" in o
    ? o.optional()
    : o;
}
var AI = (o, e) => {
    let t = [...(0, Mt.normalizePath)(e)];
    if (t.length === 1) return t[0] in o;
    let r = t.pop(),
      i = (0, Mt.getter)((0, Mt.join)(t), !0)(o);
    return !!(i && r in i);
  },
  pg = (o) => Object.prototype.toString.call(o) === "[object Object]";
function PI(o, e) {
  let t = Object.keys(o.fields);
  return Object.keys(e).filter((r) => t.indexOf(r) === -1);
}
var RI = hg([]);
function J(o) {
  return new Pa(o);
}
var Pa = class extends ze {
  constructor(e) {
    super({
      type: "object",
      check(t) {
        return pg(t) || typeof t == "function";
      },
    }),
      (this.fields = Object.create(null)),
      (this._sortErrors = RI),
      (this._nodes = []),
      (this._excludedEdges = []),
      this.withMutation(() => {
        e && this.shape(e);
      });
  }
  _cast(e, t = {}) {
    var r;
    let i = super._cast(e, t);
    if (i === void 0) return this.getDefault(t);
    if (!this._typeCheck(i)) return i;
    let s = this.fields,
      a = (r = t.stripUnknown) != null ? r : this.spec.noUnknown,
      n = [].concat(
        this._nodes,
        Object.keys(i).filter((m) => !this._nodes.includes(m))
      ),
      p = {},
      d = Object.assign({}, t, {
        parent: p,
        __validating: t.__validating || !1,
      }),
      u = !1;
    for (let m of n) {
      let y = s[m],
        b = m in i;
      if (y) {
        let v,
          S = i[m];
        (d.path = (t.path ? `${t.path}.` : "") + m),
          (y = y.resolve({ value: S, context: t.context, parent: p }));
        let w = y instanceof ze ? y.spec : void 0,
          T = w?.strict;
        if (w != null && w.strip) {
          u = u || m in i;
          continue;
        }
        (v = !t.__validating || !T ? y.cast(i[m], d) : i[m]),
          v !== void 0 && (p[m] = v);
      } else b && !a && (p[m] = i[m]);
      (b !== m in p || p[m] !== i[m]) && (u = !0);
    }
    return u ? p : i;
  }
  _validate(e, t = {}, r, i) {
    let {
      from: s = [],
      originalValue: a = e,
      recursive: n = this.spec.recursive,
    } = t;
    (t.from = [{ schema: this, value: a }, ...s]),
      (t.__validating = !0),
      (t.originalValue = a),
      super._validate(e, t, r, (p, d) => {
        if (!n || !pg(d)) {
          i(p, d);
          return;
        }
        a = a || d;
        let u = [];
        for (let m of this._nodes) {
          let y = this.fields[m];
          !y ||
            br.isRef(y) ||
            u.push(
              y.asNestedTest({
                options: t,
                key: m,
                parent: d,
                parentPath: t.path,
                originalParent: a,
              })
            );
        }
        this.runTests(
          { tests: u, value: d, originalValue: a, options: t },
          r,
          (m) => {
            i(m.sort(this._sortErrors).concat(p), d);
          }
        );
      });
  }
  clone(e) {
    let t = super.clone(e);
    return (
      (t.fields = Object.assign({}, this.fields)),
      (t._nodes = this._nodes),
      (t._excludedEdges = this._excludedEdges),
      (t._sortErrors = this._sortErrors),
      t
    );
  }
  concat(e) {
    let t = super.concat(e),
      r = t.fields;
    for (let [i, s] of Object.entries(this.fields)) {
      let a = r[i];
      r[i] = a === void 0 ? s : a;
    }
    return t.withMutation((i) =>
      i.setFields(r, [...this._excludedEdges, ...e._excludedEdges])
    );
  }
  _getDefault(e) {
    if ("default" in this.spec) return super._getDefault(e);
    if (!this._nodes.length) return;
    let t = {};
    return (
      this._nodes.forEach((r) => {
        var i;
        let s = this.fields[r],
          a = e;
        (i = a) != null &&
          i.value &&
          (a = Object.assign({}, a, { parent: a.value, value: a.value[r] })),
          (t[r] = s && "getDefault" in s ? s.getDefault(a) : void 0);
      }),
      t
    );
  }
  setFields(e, t) {
    let r = this.clone();
    return (
      (r.fields = e),
      (r._nodes = II(e, t)),
      (r._sortErrors = hg(Object.keys(e))),
      t && (r._excludedEdges = t),
      r
    );
  }
  shape(e, t = []) {
    return this.clone().withMutation((r) => {
      let i = r._excludedEdges;
      return (
        t.length &&
          (Array.isArray(t[0]) || (t = [t]), (i = [...r._excludedEdges, ...t])),
        r.setFields(Object.assign(r.fields, e), i)
      );
    });
  }
  partial() {
    let e = {};
    for (let [t, r] of Object.entries(this.fields))
      e[t] =
        "optional" in r && r.optional instanceof Function ? r.optional() : r;
    return this.setFields(e);
  }
  deepPartial() {
    return wa(this);
  }
  pick(e) {
    let t = {};
    for (let r of e) this.fields[r] && (t[r] = this.fields[r]);
    return this.setFields(t);
  }
  omit(e) {
    let t = Object.assign({}, this.fields);
    for (let r of e) delete t[r];
    return this.setFields(t);
  }
  from(e, t, r) {
    let i = (0, Mt.getter)(e, !0);
    return this.transform((s) => {
      if (!s) return s;
      let a = s;
      return (
        AI(s, e) &&
          ((a = Object.assign({}, s)), r || delete a[e], (a[t] = i(s))),
        a
      );
    });
  }
  json() {
    return this.transform(yg);
  }
  noUnknown(e = !0, t = rm.noUnknown) {
    typeof e != "boolean" && ((t = e), (e = !0));
    let r = this.test({
      name: "noUnknown",
      exclusive: !0,
      message: t,
      test(i) {
        if (i == null) return !0;
        let s = PI(this.schema, i);
        return (
          !e ||
          s.length === 0 ||
          this.createError({ params: { unknown: s.join(", ") } })
        );
      },
    });
    return (r.spec.noUnknown = e), r;
  }
  unknown(e = !0, t = rm.noUnknown) {
    return this.noUnknown(!e, t);
  }
  transformKeys(e) {
    return this.transform((t) => {
      if (!t) return t;
      let r = {};
      for (let i of Object.keys(t)) r[e(i)] = t[i];
      return r;
    });
  }
  camelCase() {
    return this.transformKeys(Ho.camelCase);
  }
  snakeCase() {
    return this.transformKeys(Ho.snakeCase);
  }
  constantCase() {
    return this.transformKeys((e) => (0, Ho.snakeCase)(e).toUpperCase());
  }
  describe(e) {
    let t = super.describe(e);
    t.fields = {};
    for (let [i, s] of Object.entries(this.fields)) {
      var r;
      let a = e;
      (r = a) != null &&
        r.value &&
        (a = Object.assign({}, a, { parent: a.value, value: a.value[i] })),
        (t.fields[i] = s.describe(a));
    }
    return t;
  }
};
J.prototype = Pa.prototype;
function We(o) {
  return new Ra(o);
}
var Ra = class extends ze {
  constructor(e) {
    super({
      type: "array",
      spec: { types: e },
      check(t) {
        return Array.isArray(t);
      },
    }),
      (this.innerType = void 0),
      (this.innerType = e);
  }
  _cast(e, t) {
    let r = super._cast(e, t);
    if (!this._typeCheck(r) || !this.innerType) return r;
    let i = !1,
      s = r.map((a, n) => {
        let p = this.innerType.cast(
          a,
          Object.assign({}, t, { path: `${t.path || ""}[${n}]` })
        );
        return p !== a && (i = !0), p;
      });
    return i ? s : r;
  }
  _validate(e, t = {}, r, i) {
    var s;
    let a = this.innerType,
      n = (s = t.recursive) != null ? s : this.spec.recursive;
    t.originalValue != null && t.originalValue,
      super._validate(e, t, r, (p, d) => {
        var u;
        if (!n || !a || !this._typeCheck(d)) {
          i(p, d);
          return;
        }
        let m = new Array(d.length);
        for (let b = 0; b < d.length; b++) {
          var y;
          m[b] = a.asNestedTest({
            options: t,
            index: b,
            parent: d,
            parentPath: t.path,
            originalParent: (y = t.originalValue) != null ? y : e,
          });
        }
        this.runTests(
          {
            value: d,
            tests: m,
            originalValue: (u = t.originalValue) != null ? u : e,
            options: t,
          },
          r,
          (b) => i(b.concat(p), d)
        );
      });
  }
  clone(e) {
    let t = super.clone(e);
    return (t.innerType = this.innerType), t;
  }
  json() {
    return this.transform(yg);
  }
  concat(e) {
    let t = super.concat(e);
    return (
      (t.innerType = this.innerType),
      e.innerType &&
        (t.innerType = t.innerType
          ? t.innerType.concat(e.innerType)
          : e.innerType),
      t
    );
  }
  of(e) {
    let t = this.clone();
    if (!Ba(e))
      throw new TypeError(
        "`array.of()` sub-schema must be a valid yup schema not: " + yr(e)
      );
    return (
      (t.innerType = e), (t.spec = Object.assign({}, t.spec, { types: e })), t
    );
  }
  length(e, t = Sa.length) {
    return this.test({
      message: t,
      name: "length",
      exclusive: !0,
      params: { length: e },
      skipAbsent: !0,
      test(r) {
        return r.length === this.resolve(e);
      },
    });
  }
  min(e, t) {
    return (
      (t = t || Sa.min),
      this.test({
        message: t,
        name: "min",
        exclusive: !0,
        params: { min: e },
        skipAbsent: !0,
        test(r) {
          return r.length >= this.resolve(e);
        },
      })
    );
  }
  max(e, t) {
    return (
      (t = t || Sa.max),
      this.test({
        message: t,
        name: "max",
        exclusive: !0,
        params: { max: e },
        skipAbsent: !0,
        test(r) {
          return r.length <= this.resolve(e);
        },
      })
    );
  }
  ensure() {
    return this.default(() => []).transform((e, t) =>
      this._typeCheck(e) ? e : t == null ? [] : [].concat(t)
    );
  }
  compact(e) {
    let t = e ? (r, i, s) => !e(r, i, s) : (r) => !!r;
    return this.transform((r) => (r != null ? r.filter(t) : r));
  }
  describe(e) {
    let t = super.describe(e);
    if (this.innerType) {
      var r;
      let i = e;
      (r = i) != null &&
        r.value &&
        (i = Object.assign({}, i, { parent: i.value, value: i.value[0] })),
        (t.innerType = this.innerType.describe(i));
    }
    return t;
  }
};
We.prototype = Ra.prototype;
function EI(o) {
  return new Ea(o);
}
var Ea = class extends ze {
  constructor(e) {
    super({
      type: "tuple",
      spec: { types: e },
      check(t) {
        let r = this.spec.types;
        return Array.isArray(t) && t.length === r.length;
      },
    }),
      this.withMutation(() => {
        this.typeError(uI.notType);
      });
  }
  _cast(e, t) {
    let { types: r } = this.spec,
      i = super._cast(e, t);
    if (!this._typeCheck(i)) return i;
    let s = !1,
      a = r.map((n, p) => {
        let d = n.cast(
          i[p],
          Object.assign({}, t, { path: `${t.path || ""}[${p}]` })
        );
        return d !== i[p] && (s = !0), d;
      });
    return s ? a : i;
  }
  _validate(e, t = {}, r, i) {
    let s = this.spec.types;
    super._validate(e, t, r, (a, n) => {
      var p;
      if (!this._typeCheck(n)) {
        i(a, n);
        return;
      }
      let d = [];
      for (let [m, y] of s.entries()) {
        var u;
        d[m] = y.asNestedTest({
          options: t,
          index: m,
          parent: n,
          parentPath: t.path,
          originalParent: (u = t.originalValue) != null ? u : e,
        });
      }
      this.runTests(
        {
          value: n,
          tests: d,
          originalValue: (p = t.originalValue) != null ? p : e,
          options: t,
        },
        r,
        (m) => i(m.concat(a), n)
      );
    });
  }
  describe(e) {
    let t = super.describe(e);
    return (
      (t.innerType = this.spec.types.map((r, i) => {
        var s;
        let a = e;
        return (
          (s = a) != null &&
            s.value &&
            (a = Object.assign({}, a, { parent: a.value, value: a.value[i] })),
          r.describe(a)
        );
      })),
      t
    );
  }
};
EI.prototype = Ea.prototype;
var bg = J().shape({ id: M().required(), data: J().required() });
c();
var _g = Ii(sm(), 1);
var q = ({ path: o, cache: e, schema: t }) => {
    let r = new _g.default(o);
    return {
      cache: new Set(e),
      match: (i) => r.match(i),
      getPath: (i) => {
        if (!i) return o;
        let s = r.reverse(i);
        return g(s, "Route must be type of string"), s;
      },
      schema: t,
    };
  },
  am = async (o) => {
    let e = await fetch(o.src);
    URL.revokeObjectURL(o.src);
    let t = new FormData();
    if (e.status < 400) {
      let r = await e.blob(),
        i = new File([r], o.name ?? "default_icon_name");
      t.append("custom_icon", i);
    }
    return t;
  },
  Fg = (o) => o.method.toLowerCase();
var nm = q({ path: "/extension/me/public_keys", cache: [], schema: bg }),
  Di = q({ path: "/extension/service_sharing_recipients", cache: [] }),
  _a = q({ path: "/extension/service_sharing_recipients/:id", cache: [] });
c();
c();
var Fa = class {
  constructor(e, t, r, i) {
    this.appSharingCredentials = e;
    this.encryptionService = t;
    this.backendService = r;
    this.init().catch(l),
      i.subscribe(
        ["updated"],
        ["service_sharing_recipients.updated"],
        async () => {
          (this.recipients = await this.loadRecipients()),
            this.emitter.emit("app-sharing-recipients-update", this.recipients);
        },
        { uri: Di.getPath() }
      );
  }
  emitter = new A();
  recipients = [];
  onRecipientsLoaded(e) {
    return this.emitter.on("app-sharing-recipients-loaded", e);
  }
  onRecipientsUpdate(e) {
    return this.emitter.on("app-sharing-recipients-update", e);
  }
  getRecipients() {
    return this.recipients;
  }
  getRecipientsByAppId(e) {
    return this.recipients.filter((t) => t.service_id === e);
  }
  async createRecipient(e) {
    let t = await this.backendService.sharing.createRecipient({
      expiration_date: e.expiration_date,
      has_credentials: e.has_credentials,
      service_id: e.service_id,
      email: e.email,
    });
    (this.recipients = [...this.recipients, t]),
      this.emitter.emit("app-sharing-recipients-update", [t]);
  }
  async updateRecipient(e, t) {
    await this.backendService.sharing.updateRecipient({
      id: e,
      data: { expiration_date: t },
    }),
      (this.recipients = this.recipients.map((i) =>
        i.uuid === e ? { ...i, expiration_date: t } : i
      ));
    let r = this.recipients.find((i) => i.uuid === e);
    r && this.emitter.emit("app-sharing-recipients-update", [r]);
  }
  async removeRecipient(e) {
    await this.backendService.sharing.deleteRecipient(e),
      (this.recipients = this.recipients.filter((t) => t.uuid !== e)),
      this.emitter.emit("app-sharing-recipients-update", []);
  }
  async init() {
    (this.recipients = await this.loadRecipients()),
      this.emitter.emit("app-sharing-recipients-loaded"),
      this.onRecipientsUpdate((e) => {
        this.updateRecipients(e).catch(l);
      }),
      this.appSharingCredentials.onCredentialsUpdated((e) => {
        let t = this.recipients.filter((r) => r.service_id === e);
        this.updateRecipients(t).catch(l);
      });
  }
  async updateInfoForRecipient(e) {
    let t = this.encryptionService.encryptRemote.bind(this.encryptionService),
      r = Boolean(e.shareData.username),
      i = await Promise.all(
        e.publicKeys.map(async (s) => ({
          version: "1",
          public_key_id: s.id,
          data: await t(e.shareData, s.data),
        }))
      );
    await this.backendService.sharing.updateRecipient({
      id: e.id,
      data: {
        expiration_date: e.expiration,
        credentials: i,
        has_credentials: r,
      },
    });
  }
  async loadRecipients() {
    return this.backendService.sharing.getRecipients();
  }
  async updateRecipients(e) {
    let t = { username: "", password: "", note: "" };
    await Promise.all(
      e.map(async (r) => {
        let i = this.appSharingCredentials.getCredentials()?.[r.service_id];
        if (!i && r.has_credentials) {
          l(
            new L(
              `Couldn't find credentials for application "${r.service_id}"`,
              { groupId: "no-credentials-for-app" }
            )
          );
          return;
        }
        await this.updateInfoForRecipient({
          id: r.uuid,
          publicKeys: r.public_keys,
          expiration: r.expiration_date,
          credentials: r.credentials,
          hasCredentials: r.has_credentials,
          shareData: i || t,
        });
      })
    );
  }
};
c();
c();
var NI =
    /^P(?!$)((?<years>\d+)(?:\.\d+)?Y)?((?<months>\d+)(?:\.\d+)?M)?(?<weeks>(\d+)(?:\.\d+)?W)?((?<days>\d+)(?:\.\d+)?D)?(T(?=\d)((?<hours>\d+)(?:\.\d+)?H)?((?<minutes>\d+)(?:\.\d+)?M)?((?<seconds>\d+)(?:\.\d+)?S)?)?$/,
  Mg = (o) => {
    let e = NI.exec(o);
    g(e?.groups, `Invalid ISO8601 format for duration: ${o}`);
    let t = (i) => (i && parseInt(i, 10)) || 0,
      r = e.groups;
    return {
      years: t(r.years),
      months: t(r.months),
      weeks: t(r.weeks),
      days: t(r.days),
      hours: t(r.hours),
      minutes: t(r.minutes),
      seconds: t(r.seconds),
    };
  };
var Ma = class {
  constructor(e, t) {
    this.appSharingRecipients = e;
    this.appSharingCredentials = t;
  }
  selectedApps = {};
  emitter = new A();
  onPopupDataUpdate(e) {
    return this.emitter.on("app-sharing-popup-data-update", e);
  }
  getSelectedAppForWindow(e) {
    return this.selectedApps[e];
  }
  updateSelectedApp(e, t) {
    (this.selectedApps = { ...this.selectedApps, [e]: t }),
      this.emitter.emit("app-sharing-popup-data-update");
  }
  clearSelectedApp(e) {
    this.selectedApps = Ie(this.selectedApps, e);
  }
  async shareApp({ expiration: e, appId: t, email: r }) {
    let i = e
        ? Uo(typeof e == "string" ? vb(Date.now(), Mg(e)) : e, "yyyy-MM-dd")
        : null,
      s = this.appSharingRecipients.getRecipients();
    if (s) {
      let n = s.find((p) => p.service_id === t && p.email === r);
      if (n) {
        await this.appSharingRecipients.updateRecipient(n.uuid, i);
        return;
      }
    }
    let a = this.appSharingCredentials.getCredentials();
    await this.appSharingRecipients.createRecipient({
      expiration_date: i,
      has_credentials: Boolean(a?.[t]?.username),
      service_id: t,
      email: r,
    });
  }
};
c();
c();
var um = {};
Bo(um, {
  applicationsBulkRoute: () => lm,
  applicationsRoute: () => Da,
  updateApplicationRoute: () => ei,
  workspaceApplicationsRoute: () => dm,
});
c();
c();
var xa = J({
    uuid: M().required().ensure(),
    workspace_id: M().required().ensure(),
    team_service: H().required(),
    credential_id: M().nullable().default(null),
    can_edit: H().default(!0),
    can_delete: H().default(!0),
    icon: M().nullable().default(null),
    shared_to_me: H().default(!1),
    shared_by_me: H().default(!1),
    sharing: J({
      expiration_date: M().nullable(),
      email: M(),
      has_credentials: H().required().default(!1),
      credentials: We(
        J({
          version: M().required().ensure(),
          public_key_id: M().required().ensure(),
          data: M().required().ensure(),
        })
      )
        .required()
        .default([]),
    })
      .nullable()
      .default(null),
    custom_icon: M().default(null).nullable(),
    recipe_basic: J({
      hasCustomUrl: H().nullable().default(!1),
      hasTeamId: H().nullable().default(!1),
      teamIdLabel: M().default(null).nullable(),
      welcomeURL: M().default(null).nullable(),
      serviceURL: M().default(null).nullable(),
    }).nullable(),
    data: J({
      name: M().nullable(),
      changedStartUrl: M().nullable().default(null),
      customUrl: M().nullable().default(null),
      isNotificationEnabled: rt()
        .transform((o) => Boolean(o))
        .default(!0),
      isNotificationBadgeEnabled: H().default(!0),
      disableNotificationBadgeNumber: H().default(!1),
      disableNotificationMessages: H().default(!1),
      sessionSandbox: H().default(!1),
      showAsSidecarPanelSetting: H().default(!1),
      isMuted: H().default(!1),
      customIconUrl: M().default(null).nullable(),
      team: M().default(null).nullable(),
      keepRunning: H().default(!1),
      recoverClosed: H().default(!1),
      recipeId: M().default(Pt.id),
      pinnedByWorkspace: rt(),
      savedId: M().default(null).nullable(),
      defaultAccountId: M().nullable(),
      syncFocusMode: H().default(!0),
      splitViewWidth: Te(),
      loginURL: M().default(void 0),
      welcomeURL: M().default(void 0),
      accountsType: M().default(void 0),
      hasFocusMode: H().default(!1),
    }).required(),
  }).required(),
  pm = We(xa).required();
var Da = q({ path: "/desktop/services", cache: [], schema: xa }),
  lm = q({ path: "/desktop/services/bulk", cache: [], schema: pm }),
  dm = q({
    path: "/desktop/services?workspace_ids=:workspaceId",
    cache: ["get"],
    schema: pm,
  }),
  ei = q({ path: "/desktop/services/:id", cache: [], schema: xa });
c();
var He = class {
  constructor(e) {
    this.sidekickBackend = e;
  }
  async get({ route: e, queryParams: t }) {
    let r = await this.sidekickBackend.get(t ? e.getPath(t) : e.getPath(), {
      route: e.getPath(),
    });
    return g(r, "Empty response received"), e.schema ? e.schema.validate(r) : r;
  }
  async head({ route: e, queryParams: t }) {
    await this.sidekickBackend.head(t ? e.getPath(t) : e.getPath(), {
      route: e.getPath(),
    });
  }
  async patch({ route: e, payload: t, queryParams: r }) {
    let i = await this.sidekickBackend.patch(
      r ? e.getPath(r) : e.getPath(),
      { route: e.getPath() },
      { body: t }
    );
    return e.schema
      ? (g(i, "Empty response received"), e.schema.validate(i))
      : i;
  }
  async post({ route: e, payload: t, raw: r, queryParams: i }) {
    let s = await this.sidekickBackend.post(
      e.getPath(i),
      { route: e.getPath() },
      { body: t, raw: r }
    );
    return e.schema
      ? (g(s, "Empty response received"), e.schema.validate(s))
      : s;
  }
  async delete({ route: e, queryParams: t }) {
    await this.sidekickBackend.delete(e.getPath(t), { route: e.getPath() });
  }
};
var xg = {
    disableNotificationBadgeNumber: !1,
    isBadgeEnabled: !0,
    isDarkModeEnabled: !1,
    isMuted: !1,
    isNotificationBadgeEnabled: !0,
    isNotificationEnabled: !0,
    pinnedByWorkspace: {},
    recoverClosed: !1,
    sessionSandbox: !1,
    showAsSidecarPanelSetting: !1,
    team: "",
  },
  Ua = class extends He {
    async getApplications(e) {
      return this.get({ route: dm, queryParams: { workspaceId: e } });
    }
    async createApplication(e) {
      return (
        g(e.workspaceId, "Workspace id shouldn't be empty"),
        this.post({ route: Da, payload: this.getAppPayload(e) })
      );
    }
    async createCustomApplication({
      workspaceId: e,
      applicationStub: {
        recipeId: t,
        name: r,
        customUrl: i,
        recipeMetaData: s,
      },
      customIcon: a,
    }) {
      g(e, "Workspace id shouldn't be empty");
      let n = a ? await am(a) : new FormData();
      return (
        n.append("workspace_id", e),
        n.append("recipe_id", t),
        n.append("name", r),
        n.append(
          "data",
          JSON.stringify({
            ...xg,
            ...s,
            customUrl: i,
            changedStartUrl: i,
            startUrl: i,
            name: r,
            recipeId: t,
          })
        ),
        this.post({ route: Da, payload: n })
      );
    }
    async createApplicationBulk({ workspaceId: e, recipes: t }) {
      g(e, "Workspace id shouldn't be empty");
      let r = t.map(
        ({ recipeId: i, recipeMetaData: s, shouldOpenInSplitView: a }) =>
          this.getAppPayload({
            workspaceId: e,
            recipeId: i,
            recipeMetaData: s,
            shouldOpenInSplitView: a,
          })
      );
      return this.post({ route: lm, payload: { services: r } });
    }
    async updateApplicationById({ id: e, changes: t }) {
      return this.patch({
        route: ei,
        queryParams: { id: e },
        payload: { data: t },
      });
    }
    async updateApplicationIconById({ id: e, icon: t }) {
      return this.patch({
        route: ei,
        queryParams: { id: e },
        payload: t === null ? { custom_icon: null } : await am(t),
      });
    }
    async deleteApplicationById(e) {
      await this.delete({ route: ei, queryParams: { id: e } });
    }
    getAppPayload({
      workspaceId: e,
      recipeId: t,
      recipeMetaData: r,
      shouldOpenInSplitView: i = !1,
    }) {
      return {
        workspace_id: e,
        recipe_id: t,
        name: "",
        data: {
          ...xg,
          ...r,
          customUrl: "",
          recipeId: t,
          shouldOpenInSplitView: i,
          sessionSandbox: !1,
          showAsSidecarPanelSetting: i,
        },
      };
    }
  };
c();
c();
var mm = q({ path: "/extension/collections", cache: ["get"] }),
  Wg = q({
    path: "/extension/collections?workspace=:workspaceId",
    cache: ["get"],
  }),
  Dg = q({ path: "/extension/collections/:id/collections", cache: [] }),
  Ug = q({ path: "/extension/collections/:id/subscriptions", cache: ["post"] }),
  Og = q({ path: "/extension/collections/:id/links", cache: [] }),
  Ko = q({ path: "/extension/collections/:id", cache: [] }),
  hm = q({ path: "/extension/collections/:id/recipients", cache: [] }),
  jg = q({ path: "/extension/collections/recipients/:id", cache: [] }),
  qo = q({ path: "/extension/collections/links/:id", cache: [] });
var Oa = class extends He {
  constructor(t) {
    super(t);
    this.backendApi = t;
  }
  getAllCollections() {
    return this.get({ route: mm });
  }
  getCollectionsByWorkspaceId(t) {
    return this.get({ route: Wg, queryParams: { workspaceId: t } });
  }
  createRootCollection(t, r, i, s, a) {
    return this.post({
      route: mm,
      payload: { name: t, team_uuid: s, emoji: i, workspace_uuid: r, index: a },
    });
  }
  createNestedCollection(t, r, i, s, a) {
    return this.post({
      route: Dg,
      payload: { name: t, workspace_id: i, emoji: s, index: a },
      queryParams: { id: r },
    });
  }
  getRecipientsByCollectionId(t) {
    return this.get({ route: hm, queryParams: { id: t } });
  }
  subscribeCollection(t, r, i) {
    return this.post({
      route: Ug,
      payload: { workspace_uuid: r, invite_code: i },
      queryParams: { id: t },
    });
  }
  updateCollection(t, r) {
    return this.patch({
      route: Ko,
      queryParams: { id: t },
      payload: {
        name: r.name,
        emoji: r.emoji,
        user_uuid: r.userUuid,
        team_uuid: r.teamUuid,
        folder_uuid: r.folderUuid,
        index: r.index,
        is_public: r.isPublic,
      },
    });
  }
  deleteCollection(t) {
    return this.delete({ route: Ko, queryParams: { id: t } });
  }
  shareCollection(t, r) {
    return this.post({
      route: hm,
      queryParams: { id: t },
      payload: { email: r },
    });
  }
  unshareCollection(t) {
    return this.delete({ route: jg, queryParams: { id: t } });
  }
  createLink(t, r, i, s) {
    return this.post({
      route: Og,
      queryParams: { id: t },
      payload: { name: r, url: i, index: s },
    });
  }
  deleteLink(t) {
    return this.delete({ route: qo, queryParams: { id: t } });
  }
  updateLink(t, r) {
    return this.patch({
      route: qo,
      queryParams: { id: t },
      payload: {
        name: r.name,
        url: r.url,
        folder_uuid: r.folderUuid,
        index: r.index,
      },
    });
  }
};
c();
var vm = {};
Bo(vm, {
  createWorkspaceRoute: () => gm,
  featuresRoute: () => ym,
  updateWorkspaceRoute: () => Fr,
  workspacesRoute: () => bm,
});
c();
c();
var LI = J({
    name: M().required().ensure(),
    works: H().required(),
    data: J().required(),
  }).required(),
  Ng = We(LI).required(),
  GI = J({
    author: M().required().ensure(),
    id: Te().required(),
    group_id: rt((o) => Object.values(ra).includes(o)).required(),
    image_4k_url: M().required().ensure(),
    image_url: M().required().ensure(),
    original_url: M().required().ensure(),
    thumbnail_url: M().required().ensure(),
  }).required(),
  KW = We(GI).required(),
  ja = J({
    uuid: M().required().ensure(),
    name: M()
      .transform((o) => o || void 0)
      .default("Personal workspace"),
    team_workspace: H().default(!1),
    can_delete: H().default(!1),
    pinned_services_order: J({
      order: We(M().ensure()).default([]),
    }).required(),
    services_order: J({ order: We(M().ensure()).default([]) }).required(),
    background: J().shape({
      type: M().oneOf(["Color", "Emoji"], "unknown background type"),
      value: J().shape({ bg: M(), letterColor: M(), symbol: M() }),
    }),
    sandbox: H().required().default(!0),
    team_uuid: M().nullable(),
  }).required(),
  Lg = We(ja).required();
var ym = q({ path: "/desktop/features", cache: ["get"], schema: Ng }),
  Fr = q({ path: "/desktop/workspaces/:id", cache: [], schema: ja }),
  bm = q({ path: "/desktop/workspaces", cache: ["get"], schema: Lg }),
  gm = q({ path: "/desktop/workspaces", cache: [], schema: ja });
var Na = class extends He {
  getFeatures() {
    return this.get({ route: ym });
  }
  getWorkspaces() {
    return this.get({ route: bm });
  }
  createWorkspace(e) {
    return this.post({ route: gm, payload: e });
  }
  deleteWorkspaceById(e) {
    return this.delete({ route: Fr, queryParams: { id: e } });
  }
  updateWorkspaceById({ id: e, changes: t }) {
    return this.patch({ route: Fr, queryParams: { id: e }, payload: t });
  }
};
c();
c();
var Ui = {
  is_just_me: !0,
  name: "Personal",
  uuid: "00000000-0000-0000-0000-000000000000",
  domains: [],
};
var xm = {};
Bo(xm, {
  allTeamsRoute: () => Ga,
  billingClaimDiscountOfferRoute: () => Tm,
  billingPlanRoute: () => zo,
  billingPlanUpgradeUrl: () => fm,
  billingPlansRoute: () => Qo,
  billingStartInvitesBonusRoute: () => Im,
  billingStartTrialRoute: () => km,
  billingTeamsCancelSubscriptionRoute: () => wm,
  billingTeamsUpgradeRoute: () => Sm,
  browserUpdateRoute: () => Bm,
  invitationsPlansRoute: () => Rm,
  invitationsStatsRoute: () => Pm,
  inviteTeammatesRoute: () => Am,
  meRoute: () => ti,
  stripeCustomerPortalUrlRoute: () => _m,
  stripePaidTrialRoute: () => Fm,
  subscribeToNotificationsRoute: () => Mm,
  teamBrowserPolicyRoute: () => Yo,
  teamRoute: () => Ha,
  updateInviteCodeRoute: () => Cm,
  wallpapersRoute: () => Em,
});
c();
c();
c();
var Gg = J({ hours: Te().required(), minutes: Te().required() }),
  La = J({
    name: M().nullable(),
    email: M().email().default(null),
    avatar: M().nullable(),
    registered_at: Te().required(),
    registered_with: rt().default("email"),
    registered_domain: M().nullable().default(null),
    has_temporary_email: H().required().default(!1),
    inviter_code: M().nullable().default(null),
    has_stripe_customer_id: H(),
    sidekick_is_default: H().default(!1),
    app_settings: J({
      useAdBlocker: H(),
      adBlockerWhiteList: We(M().ensure()),
      isDistractionBlockerEnabled: H(),
      isDistractionBlockerIntroShowed: H(),
      isHiddenWelcomeGlobalSearch: H(),
      distractionBlockerRules: We(
        J({ id: M().ensure(), from: M().ensure(), to: M().ensure() })
      ).nullable(),
      distractionBlockerSchedule: J({
        allDay: H().required(),
        from: Gg.required(),
        to: Gg.required(),
        weekdays: We(rt().oneOf(Object.values(zy)).required()).required(),
      })
        .nullable()
        .default(null),
      disableDiscarding: H(),
      noneDiscardableDomains: We(M().ensure()),
      minutesBeforeDiscard: rt((o) => Object.values(ia).includes(o)).transform(
        (o) => Object.values(ia).find((e) => e === o) ?? "10"
      ),
      sidebarSize: rt().transform((o) =>
        Object.values(ju).find((t) => t === o)
          ? "unset"
          : Object.values(oa).find((t) => t === o)
      ),
      isHiddenWelcomeToSessions: H(),
      wasActivated: H(),
      wasGmailSignatureSet: H(),
      isHiddenWelcomeToCollections: H(),
      isHiddenWelcomeToDistractionBlocker: H(),
      isHiddenLaunchpadTeamsBillingAnimation: H(),
      inactiveServiceGrayscale: H(),
      showPhotoBackground: H(),
      discountStartTimestamp: Te(),
      use12Format: H(),
      preferredWallpaperId: rt(
        (o) => typeof o == "string" || typeof o == "number"
      ).nullable(),
      randomUserAgent: H(),
      showedOnboardingHints: We(M().ensure()),
      cpuMonitorNotificationsEnabledByUser: H(),
      cpuAutoDiscardEnabledByUser: H(),
      cpuAutoDiscardUserWhitelist: We(M().ensure()),
      ctrlTabOrder: rt((o) => Object.values(Oo).includes(o)),
      rotateWallpapersEnabled: H(),
      showedHintsV2: We(rt().oneOf(Object.values(qe)).required()).nullable(),
    }),
  });
var Hg = J({ user: La.required() }),
  dD = J({ session_url: M().required() }),
  uD = J({ url: M().required() }),
  xt = (o) => J({ description: M(), value: o }),
  Vg = J().shape({
    id: Te().required(),
    name: M().required(),
    original_name: M().nullable(),
    billingLink: M().url().required(),
    can_manage: H().default(!1),
    cancel_at: Te().nullable(),
    options: J().shape({
      isGift: H().default(!1),
      isPaid: H().required(),
      isPro: H().required(),
      isTeam: H().default(!1),
      isTrial: H().required(),
      interval: rt().oneOf(["day", "week", "month", "year"]).nullable(),
      isTrialExpired: H().required(),
      subscriptionTimeLeft: Te().nullable(),
    }),
    planOptions: J().shape({
      accountsLimitPerApp: xt(Te().nullable()),
      appSharingLimit: xt(Te().nullable()),
      canBeUpgradedByInvites: xt(H().required()).default(void 0),
      cancelLink: xt(M().required()).default(void 0),
      canUseIntercom: xt(H().required()).default(void 0),
      canUseAdblock: xt(H().required()).default(void 0),
      pinnedAppsLimit: xt(Te().nullable()),
      splitViewLimitPerWindow: xt(Te().nullable()),
      totalAppsLimit: xt(Te().nullable()),
      workspacesLimit: xt(Te().nullable()),
      sessionsPerWorkspaceLimit: xt(Te().nullable()),
      preInstalledAppsLimit: xt(Te().nullable()),
    }),
  }),
  $g = J({
    invite_link: M().required().ensure(),
    required_activations: Te().nullable(),
    statistics: J({ activations: Te(), downloads: Te() }),
  }),
  Kg = J({
    collection: We(
      J({
        count: Te().required(),
        duration: Te().required().nullable(),
        is_used: H().required(),
        base_plan_id: Te().required(),
      })
    ).required(),
  }),
  qg = J({
    url: M().nullable().default(null),
    text: M().nullable().default(null),
    version: M().nullable().default(null),
    can_autoupdate: H().default(!1),
  }).required();
var ti = q({ path: "/extension/me", cache: ["get", "put"], schema: Hg }),
  fm = q({
    path: "/extension/billing/upgrade-plan?plan_id=:plan_id",
    cache: ["get"],
  }),
  zo = q({ path: "/extension/billing/plan", cache: ["get"], schema: Vg }),
  Qo = q({ path: "/extension/billing/plans", cache: ["get"] }),
  Sm = q({
    path: "/extension/teams/:id/billing/subscription/upgrade?plan_id=:plan_id",
    cache: [],
  }),
  wm = q({ path: "/extension/teams/:id/billing/subscription", cache: [] }),
  km = q({ path: "/extension/billing/start_trial", cache: [] }),
  Tm = q({ path: "/extension/billing/claim-discount-offer", cache: [] }),
  Im = q({ path: "/extension/invitations_plans/start_plan", cache: [] }),
  Ga = q({ path: "/extension/teams", cache: ["get"] }),
  Ha = q({ path: "/extension/teams/:id", cache: ["get"] }),
  Yo = q({ path: "/extension/teams/:id/browser-policy", cache: ["get"] }),
  Am = q({ path: "/extension/teams/:id/invites", cache: [] }),
  Pm = q({ path: "/extension/invitations/stats", cache: ["get"], schema: $g }),
  Rm = q({ path: "/extension/invitations_plans", cache: ["get"], schema: Kg }),
  Em = q({ path: "/extension/wallpapers3", cache: [] }),
  Bm = q({
    path: "/extension/browser-update?browser=:browserVersion&ext=:extVersion(&platform=:platform)",
    cache: [],
    schema: qg,
  }),
  Cm = q({ path: "/extension/me/change_inviter", cache: [] }),
  _m = q({ path: "/extension/billing/portal", cache: [] }),
  Fm = q({ path: "/extension/billing/request-paid-trial", cache: [] }),
  Mm = q({ path: "/extension/pushes/subscriptions", cache: [] });
var Va = class extends He {
  getMe() {
    return this.get({ route: ti });
  }
  getBillingUpgradePlanUrl(e) {
    return this.get({ route: fm, queryParams: e });
  }
  getTeamUpgradePlanUrl(e) {
    return this.get({
      route: Sm,
      queryParams: { id: e.teamUUID, plan_id: e.planId },
    });
  }
  deleteTeamPlanSubscription(e) {
    return this.delete({ route: wm, queryParams: { id: e.teamUUID } });
  }
  getBillingPlan() {
    return this.get({ route: zo });
  }
  getBillingPlans() {
    return this.get({ route: Qo });
  }
  getInvitationsStats() {
    return this.get({ route: Pm });
  }
  async getTeams() {
    try {
      return await this.get({ route: Ga });
    } catch (e) {
      if (e instanceof lt && e.status === 404) return [Ui];
      throw e;
    }
  }
  inviteToTeam(e, t) {
    return this.post({
      route: Am,
      payload: { emails: t },
      queryParams: { id: e },
    });
  }
  updateTeam(e, t) {
    return this.patch({ route: Ha, payload: t, queryParams: { id: e } });
  }
  createTeam(e) {
    return this.post({ route: Ga, payload: e });
  }
  getTeam(e) {
    return this.get({ route: Ha, queryParams: { id: e } });
  }
  getTeamPolicy(e) {
    return this.get({ route: Yo, queryParams: { id: e } });
  }
  getInvitationsPlans() {
    return this.get({ route: Rm });
  }
  getWallpapers() {
    return this.get({ route: Em });
  }
  getBrowserUpdate(e, t, r = !0) {
    return this.get({
      route: Bm,
      queryParams: {
        browserVersion: e,
        extVersion: t,
        platform: r ? "m1" : void 0,
      },
    });
  }
  updateGlobalSettings(e) {
    return this.patch({ route: ti, payload: { app_settings: e } });
  }
  updateUserDefaultBrowser(e) {
    return this.patch({ route: ti, payload: { sidekick_is_default: e } });
  }
  updateUserOnboarded() {
    return this.patch({ route: ti, payload: { onboarded: !0 } });
  }
  updateInviterCode(e) {
    return this.post({ route: Cm, payload: { code: e }, raw: !0 });
  }
  getStripePaidTrialUrl() {
    return this.post({ route: Fm, payload: {} });
  }
  getStripeCustomerPortalUrl() {
    return this.get({ route: _m });
  }
  postNotificationsToken(e) {
    return this.post({ route: Mm, payload: { token: e } });
  }
  postStartTrial() {
    return this.post({ route: km, payload: {} });
  }
  postStartInvitationsBonusTime() {
    return this.post({ route: Im, payload: {} });
  }
  dismissCancelDiscountOffer() {
    return this.patch({
      route: ti,
      payload: { cancel_discount_offer_dismissed: !0 },
    });
  }
  claimDiscountOffer(e) {
    return this.post({ route: Tm, payload: e });
  }
};
c();
var $a = class extends He {
  createPublicKey(e) {
    return (
      g(e.id, "Id should not be empty"),
      g(e.data, "Data should not be empty"),
      this.post({ route: nm, payload: e })
    );
  }
  getRecipients() {
    return this.get({ route: Di });
  }
  createRecipient(e) {
    return (
      g(e, "Payload should not be empty"), this.post({ route: Di, payload: e })
    );
  }
  updateRecipient({ id: e, data: t }) {
    return this.patch({ route: _a, queryParams: { id: e }, payload: t });
  }
  deleteRecipient(e) {
    return this.delete({ route: _a, queryParams: { id: e } });
  }
};
c();
var Lm = {};
Bo(Lm, {
  teamAppSharingCheckAccessRoute: () => Nm,
  teamAppSharingCredentialsRoute: () => Um,
  teamAppSharingKeysetByRecoveryKeyRoute: () => Dm,
  teamAppSharingKeysetRoute: () => Wm,
  teamAppSharingRequestAccessRoute: () => jm,
  teamAppSharingShareCredentialsRoute: () => Om,
});
c();
c();
var zg = J({
    record: J({
      public_key: J().required(),
      public_key_id: M().required().ensure(),
      private_key_data: J().required(),
      salt: M().required().ensure(),
    }).required(),
  }),
  BD = J({
    collection: We(
      J({
        credential_id: M().required().ensure(),
        access: J({
          status: M().required().ensure(),
          data: J().required(),
          key_data: J().required(),
        }).required(),
        pending_public_keys: We(
          J({ id: M().required().ensure(), data: J().required() })
        )
          .required()
          .default([]),
      })
    )
      .required()
      .default([]),
  });
var Wm = q({ path: "/desktop/key_set", cache: [], schema: zg }),
  Dm = q({ path: "/desktop/key_set?recovery_key=:recoveryKeyId", cache: [] }),
  Um = q({
    path: "/desktop/credentials?public_key_id=:publicKeyId",
    cache: [],
  }),
  Om = q({ path: "/desktop/credentials/share", cache: [] }),
  jm = q({ path: "/desktop/credentials/request_access", cache: [] }),
  Nm = q({
    path: "/desktop/credentials/:credentialId/check_access?public_key_id=:publicKeyId",
    cache: [],
  });
var Ka = class extends He {
  getKeyset(e) {
    return this.get({ route: Dm, queryParams: { recoveryKeyId: e } });
  }
  createKeyset(e) {
    return this.post({
      route: Wm,
      payload: {
        private_key: e.privateKey,
        public_key: e.publicKey,
        salt: e.salt,
        recovery_key: e.recoveryKeyId,
      },
    });
  }
  getCredentials(e) {
    return this.get({ route: Um, queryParams: { publicKeyId: e } });
  }
  shareCredentials(e) {
    return this.post({
      route: Om,
      payload: {
        accesses: e.accesses.map((t) => ({
          credential_id: t.credentialId,
          public_key_id: t.publicKeyId,
          data: t.data,
          key_data: t.keyData,
        })),
      },
    });
  }
  requestAccess(e, t) {
    return this.post({
      route: jm,
      payload: { credential_id: e, public_key_id: t },
    });
  }
  checkAccess(e, t) {
    return this.head({
      route: Nm,
      queryParams: { credentialId: e, publicKeyId: t },
    });
  }
};
c();
c();
var Qg = q({ path: "/oauth2/google/refresh", cache: [] });
var qa = class extends He {
  refreshGoogleToken(e) {
    return this.post({ route: Qg, payload: e });
  }
};
c();
c();
var Yg = q({ path: "/extension/sessions", cache: [] }),
  Xg = q({ path: "/extension/sessions?timestamp=:timestamp", cache: ["get"] }),
  Gm = q({ path: "/extension/sessions/:id", cache: [] });
var za = class extends He {
  postSession(e) {
    return this.post({ route: Yg, payload: e });
  }
  patchSession(e, t) {
    return this.patch({ route: Gm, payload: t, queryParams: { id: e } });
  }
  deleteSession(e) {
    return this.delete({ route: Gm, queryParams: { id: e } });
  }
  getSessions(e) {
    return this.get({ route: Xg, queryParams: e });
  }
};
var Qa = class {
  applications;
  collection;
  desktop;
  extension;
  oauth;
  sessions;
  sharing;
  teamAppSharing;
  constructor(e) {
    (this.applications = new Ua(e)),
      (this.collection = new Oa(e)),
      (this.desktop = new Na(e)),
      (this.extension = new Va(e)),
      (this.oauth = new qa(e)),
      (this.sessions = new za(e)),
      (this.sharing = new $a(e)),
      (this.teamAppSharing = new Ka(e));
  }
};
c();
var Ya = class {
  constructor(e) {
    this.browserService = e;
  }
  savedFs;
  async checkExistence(e) {
    return (
      this.savedFs ||
        (this.savedFs = await this.browserService.getPackageDirectory()),
      this.checkExistenceByFs(e, this.savedFs)
    );
  }
  checkExistenceByFs(e, t) {
    return new Promise((r) => {
      t.getFile(
        e,
        { create: !1 },
        () => r(!0),
        () => r(!1)
      );
    });
  }
};
c();
var Xa = class {
  constructor(e, t, r, i, s, a, n, p, d, u) {
    this.browserService = e;
    this.browserEventsService = t;
    this.extraDataService = r;
    this.featureFlagsRepository = i;
    this.userSettingsRepository = s;
    this.browserStorage = a;
    this.cpuPopupService = n;
    this.analyticsTracker = p;
    this.tabInfoFollowerService = d;
    this.popupService = u;
    (this.cpuMonitorConfig =
      this.featureFlagsRepository.getFeatureFlags().cpuMonitor),
      (this.cpuMonitorEnabled =
        this.featureFlagsRepository.getFeatureFlags().cpuMonitorEnabled ?? !0),
      this.featureFlagsRepository.onFeatureFlagsLoaded(() => {
        let m = this.featureFlagsRepository.getFeatureFlags().cpuMonitor,
          y =
            this.featureFlagsRepository.getFeatureFlags().cpuMonitorEnabled ??
            !0;
        (y === this.cpuMonitorEnabled && Ri(m, this.cpuMonitorConfig)) ||
          ((this.cpuMonitorEnabled = y),
          (this.cpuMonitorConfig = m),
          this.setCPUGreedyThresholds().catch(l));
      }),
      this.setCPUGreedyThresholds().catch(l);
  }
  hostname = null;
  tabsToBeDiscarded = [];
  waitingForUserAction = !1;
  cpuMonitorConfig;
  cpuMonitorEnabled = !0;
  unsubFn;
  getCurrentHostname() {
    return this.hostname;
  }
  async discardPendingTabs() {
    await Promise.all(
      this.tabsToBeDiscarded.map((e) =>
        e?.id ? this.browserService.discardTabById(e.id) : null
      )
    ),
      (this.waitingForUserAction = !1);
  }
  async setIgnoreFlag() {
    await this.browserStorage.setItem(
      "cpu-monitor-alarm-ignored-at",
      Date.now()
    );
  }
  async setCPUGreedyThresholds() {
    let {
        cpuThreshold: e,
        maxRetries: t,
        checkEverySeconds: r,
      } = this.cpuMonitorConfig,
      i = await this.checkStorageFlag();
    this.unsubFn?.(),
      this.cpuMonitorEnabled &&
        i &&
        e &&
        t &&
        r &&
        (this.browserService.setCPUGreedyThresholds(e, t, r),
        (this.unsubFn = this.browserEventsService.subscribeToGreedyProcessFound(
          (s, a) => {
            this.handleGreedyProcesses(s, a).catch(l);
          }
        )));
  }
  getTabsIdsFromProcesses(e) {
    let t = e.map((r) =>
      r.tasks
        .filter((i) => oe(i, "tabId") && i.windowType === "normal")
        .map((i) => i.tabId)
    );
    return gb(...t);
  }
  async checkStorageFlag() {
    let e = await this.browserStorage.getItem("cpu-monitor-alarm-ignored-at");
    if (!e) return !0;
    let t = Date.now();
    return Rr(t - e) >= 7
      ? (await this.browserStorage.removeItem("cpu-monitor-alarm-ignored-at"),
        !0)
      : !1;
  }
  checkDomainIsInWhitelist(e) {
    if (!e) return !1;
    let { domainsWhitelist: t } = this.cpuMonitorConfig,
      r = this.userSettingsRepository.getSettings().cpuAutoDiscardUserWhitelist;
    return [...t, ...r].some((a) => Qs(e, a));
  }
  getProcessTypes(e) {
    let t = new Set();
    return (
      e.forEach((r) => {
        r.type && t.add(r.type);
      }),
      Array.from(t).join(", ")
    );
  }
  async handleGreedyProcesses(e, t) {
    if (this.waitingForUserAction) return;
    let {
      enableAutoDiscard: r,
      enableNotifications: i,
      cpuThreshold: s,
      maxRetries: a,
      checkEverySeconds: n,
      inactiveTime: p,
    } = this.cpuMonitorConfig;
    if (!(await this.checkStorageFlag())) return;
    let u = await this.browserService.getProfileName(),
      m = this.userSettingsRepository.getSettings(),
      y = Object.values(t).filter(
        (E) => E.type === "renderer" && E.profile === u
      );
    if (!y?.length) return;
    let b = this.getTabsIdsFromProcesses(y);
    if (!b?.length || !b[0]) return;
    let v = Date.now(),
      S = (
        await Promise.all(
          b.map((E) => (E ? this.browserService.getTabById(E) : null))
        )
      ).filter(de),
      w = S.filter((E) =>
        !this.tabInfoFollowerService.getTabInfoById(E.id)?.wasLastActiveAt || !p
          ? !0
          : !E.active
      ),
      T = w[0],
      k = (() => {
        let E = this.tabInfoFollowerService.getTabInfoById(T?.id);
        return !E || !p
          ? !1
          : !T?.active && ur(Math.abs(v - E.wasLastActiveAt)) >= p;
      })(),
      _ = At(S.find((E) => E.pendingUrl || E.url)?.url ?? "") ?? null,
      O = w.some((E) => this.extraDataService.getTabExtraData(E)?.app ?? !1);
    if (
      (this.analyticsTracker.sendAnalyticsEvent("cpu-monitor.alarm", {
        "cpu-monitor.hostname": _,
        "cpu-monitor.tasks-num": y.reduce((E, f) => E + f.tasks.length, 0),
        "cpu-monitor.process-type": this.getProcessTypes(y),
        "cpu-monitor.is-contains-app-tab": O,
        "cpu-monitor.settings.cpu-threshold": s,
        "cpu-monitor.settings.max-retries": a,
        "cpu-monitor.settings.check-every-seconds": n,
      }),
      !this.checkDomainIsInWhitelist(_))
    ) {
      if (r && m.cpuAutoDiscardEnabledByUser && k) {
        i &&
          m.cpuMonitorNotificationsEnabledByUser &&
          (await this.popupService.toggleCpuMonitorNotificationPopup({
            hostname: _,
            discardedTabsCount: b.length,
            source: "cpu-monitor-service",
          }));
        let E = w.reduce((j, ue) => {
            let Q = this.tabInfoFollowerService.getTabInfoById(ue.id);
            if (!Q) return j;
            let C = Q.wasLastActiveAt ? ur(v - Q.wasLastActiveAt) : 1 / 0;
            return Math.min(j, C);
          }, 1 / 0),
          f = await Promise.all(
            w.map(async (j) => {
              if (!j.id) return null;
              try {
                return await this.browserService.discardTabById(j.id);
              } catch {
                throw new L(`Cannot discard tab with id ${j.id}`, {
                  extra: { tab: await this.browserService.getTabById(j.id) },
                });
              }
            })
          );
        this.analyticsTracker.sendAnalyticsEvent("cpu-monitor.tabs-discarded", {
          "cpu-monitor.hostname": _,
          "cpu-monitor.min-inactive-time": E,
          "cpu-monitor.total-tabs-in-process": b.length,
          "cpu-monitor.total-discarded-tabs-in-process": f.filter(de).length,
          "cpu-monitor.parent-process-tasks-num": t[e]?.tasks.length ?? -1,
        });
      }
      !m.cpuAutoDiscardEnabledByUser &&
        i &&
        m.cpuMonitorNotificationsEnabledByUser &&
        ((this.tabsToBeDiscarded = w),
        (this.waitingForUserAction = !0),
        await this.cpuPopupService.showCpuMonitorAlarmPopup(
          this.tabsToBeDiscarded.slice(0, 5)
        ));
    }
  }
};
c();
var Ja = class {
  constructor(e, t) {
    this.browserService = e;
    this.overlayService = t;
    this.popupsByWindowId = {};
  }
  popupsByWindowId;
  emitter = new A();
  onPopupChanged(e) {
    return this.emitter.on("popup-changed", e);
  }
  getPopupForWindow(e) {
    return this.popupsByWindowId[e];
  }
  async showCpuMonitorAlarmPopup(e) {
    return this.showPopup({ id: "cpu-monitor-alarm", tabs: e });
  }
  closePopup(e) {
    (this.popupsByWindowId = Ie(this.popupsByWindowId, e)),
      this.emitter.emit("popup-changed"),
      this.overlayService.toggleOverlayForModal(e, !1, !0);
  }
  async showPopup(e) {
    let t = await this.browserService.getLastFocusedWindowId();
    if (t && t !== -1) {
      if (this.getPopupForWindow(t)?.id === e.id) return;
      (this.popupsByWindowId[t] = e),
        this.emitter.emit("popup-changed"),
        this.overlayService.toggleOverlayForModal(t, !0, !0);
    }
  }
};
c();
c();
var Jg = async (o = 21) => {
  let e = "",
    t = crypto.getRandomValues(new Uint8Array(o));
  for (; o--; ) {
    let r = t[o] & 63;
    r < 36
      ? (e += r.toString(36))
      : r < 62
      ? (e += (r - 26).toString(36).toUpperCase())
      : r < 63
      ? (e += "_")
      : (e += "-");
  }
  return e;
};
c();
var Za = (o) => {
    let e = "";
    return (
      new Uint8Array(o).forEach((t) => {
        e += String.fromCharCode(t);
      }),
      globalThis.btoa(e)
    );
  },
  Hm = (o) => Uint8Array.from(atob(o), (e) => e.charCodeAt(0));
c();
var VI = new TextEncoder(),
  Vm = (o) => VI.encode(o),
  $I = new TextDecoder(),
  $m = (o) => $I.decode(o);
var en = class {
  constructor(e, t) {
    this.browserStorage = e;
    this.backendService = t;
    this.init().catch(l);
  }
  keyset = null;
  emitter = new A();
  onKeysetLoaded(e) {
    return this.emitter.on("encryption-keyset-update", e);
  }
  getKeyset() {
    return this.keyset;
  }
  async encryptRemote(e, t) {
    let r = { name: "RSA-OAEP" },
      i = await this.importKey(t),
      s = Vm(JSON.stringify(e)),
      a = await crypto.subtle.encrypt(r, i, s);
    return Za(a);
  }
  async decryptRemote(e) {
    g(this.keyset, "No keyset to decrypt remote");
    let t = { name: "RSA-OAEP" },
      r = await this.importKey(this.keyset.privateKey),
      i = Hm(e),
      s = await crypto.subtle.decrypt(t, r, i);
    return Oe($m(s));
  }
  async encryptLocal(e) {
    g(this.keyset, "No keyset to encrypt local");
    let { localKey: t } = this.keyset,
      r = { name: "AES-GCM", length: 256 },
      i = t.key_ops || [],
      s = await crypto.subtle.importKey("jwk", t, r, !0, i),
      a = Vm(JSON.stringify(e)),
      n = crypto.getRandomValues(new Uint8Array(12)),
      p = { name: "AES-GCM", iv: n },
      d = await crypto.subtle.encrypt(p, s, a);
    return [Za(d), Za(n)].join(".");
  }
  async decryptLocal(e) {
    g(this.keyset, "No keyset to decrypt local");
    let { localKey: t } = this.keyset,
      r = { name: "AES-GCM", length: 256 },
      i = t.key_ops || [],
      s = await crypto.subtle.importKey("jwk", t, r, !0, i),
      [a, n] = e.split(".").map((u) => Hm(u));
    g(a && n, "Failed to decrypt local");
    let p = { name: "AES-GCM", iv: n },
      d = await crypto.subtle.decrypt(p, s, a);
    return Oe($m(d));
  }
  async init() {
    let e = "credentials",
      t = await this.browserStorage.getItemFromSyncStorage("credentials");
    t
      ? (this.keyset = t)
      : (await this.generateKeyset(),
        await this.savePublicKeyToBackend(),
        this.saveKeysetToLs()),
      this.browserStorage.subscribe(
        e,
        (r) => {
          r &&
            ((this.keyset = r), this.emitter.emit("encryption-keyset-update"));
        },
        !1,
        "sync"
      ),
      this.emitter.emit("encryption-keyset-update");
  }
  importKey(e) {
    let t = { name: "RSA-OAEP", hash: { name: "SHA-256" } },
      r = e.key_ops || [];
    return crypto.subtle.importKey("jwk", e, t, !0, r);
  }
  async generateKeyset() {
    let e = {
        name: "RSA-OAEP",
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: { name: "SHA-256" },
      },
      t = ["encrypt", "decrypt"],
      { privateKey: r, publicKey: i } = await crypto.subtle.generateKey(
        e,
        !0,
        t
      ),
      s = { name: "AES-GCM", length: 256 },
      a = await crypto.subtle.generateKey(s, !0, t);
    g(i, "No public key to generate keyset"),
      g(r, "No private key to generate keyset"),
      (this.keyset = {
        id: await Jg(),
        synced: !1,
        localKey: await crypto.subtle.exportKey("jwk", a),
        publicKey: await crypto.subtle.exportKey("jwk", i),
        privateKey: await crypto.subtle.exportKey("jwk", r),
      });
  }
  saveKeysetToLs() {
    g(this.keyset, "No keyset to save"),
      this.browserStorage
        .setItemToSyncStorage("credentials", this.keyset)
        .catch(l);
  }
  async savePublicKeyToBackend() {
    !this.keyset ||
      this.keyset?.synced ||
      (await this.backendService.sharing.createPublicKey({
        id: this.keyset?.id,
        data: this.keyset?.publicKey,
      }),
      (this.keyset = { ...this.keyset, synced: !0 }));
  }
};
c();
c();
var Zg = (o) =>
    Ge(o) &&
    oe(o, "type") &&
    (typeof o.type == "string" || typeof o.type == "number"),
  ev = (o, e) => oe(o, "scriptName") && o.scriptName === e,
  tv = (o) => o.type === "BADGES",
  rv = (o) => o.type === "ACCOUNTS";
var iv = (o) => o.type === "PUT_RESOURCE",
  ov = (o) => o.type === "SEND_ANALYTICS",
  sv = (o) => o.type === "SEND_ERROR",
  av = (o) => o.type === "INJECT_FRAMES_REQUEST",
  nv = (o) => o.type === "SET_CUSTOM_SUBSCRIBER",
  cv = (o) => o.type === "CALL_CUSTOM_SUBSCRIBER";
c();
var { WINDOW_ID_NONE: Km } = chrome.windows,
  { ProcessType: tn } = chrome.processes,
  pv = chrome.sidekick.splitView.SplitRequestSource,
  { PasswordFormScheme: lv } = chrome.sidekick.system,
  { WindowRelativeAnchor: Ve } = chrome.sidekick.overlay;
c();
var dv = (o) => `recipe-${o}`;
var rn = class {
  constructor(e, t, r, i, s, a, n, p) {
    this.applicationRepository = e;
    this.browserService = t;
    this.recipesRepository = r;
    this.userSettingsRepository = i;
    this.featureFlagsRepository = s;
    this.windowHeadlessService = a;
    this.sidebarVisibilityManager = n;
    this.browserEventsService = p;
    this.browserEventsService.subscribeToTabCreated(({ windowId: d }) => {
      this.getIsWindowInFocusMode(d) &&
        this.disableWindowFocusMode(d).catch(fe);
    });
  }
  emitter = new A();
  windowsInFocusMode = new Set();
  windowsWithHiddenSidebar = new Set();
  getIsWindowInFocusMode(e) {
    return this.windowsInFocusMode.has(e);
  }
  subscribeToFocusModeChanged(e) {
    return this.emitter.on("focus-mode-changed", e);
  }
  sendFocusModeMessage(e, t) {
    let { autoSyncFocusMode: r, syncFocusMode: i } =
        this.featureFlagsRepository.getFeatureFlags(),
      s = r?.runEveryDaysFor?.[t] ?? r?.runEveryDays;
    this.browserService.sendMessageToTab(e, {
      type: "FOCUS_MODE",
      payload: {
        enabled: this.userSettingsRepository.getSettings().globalMute,
        shouldBeSilent: !0,
        dontClearStatus: i.dontClearStatus ?? !0,
        runEveryDays: s,
      },
      scriptName: dv(t),
    });
  }
  async toggleWindowFocusMode() {
    let e = await this.browserService.getNormalLastFocusedWindowId();
    if (!e) return Promise.resolve();
    if (this.windowsInFocusMode.has(e)) return this.disableWindowFocusMode(e);
    this.windowsInFocusMode.add(e),
      this.sidebarVisibilityManager.getVisibilityState(e)
        ? this.sidebarVisibilityManager.updateVisibilityState(e, !1)
        : this.windowsWithHiddenSidebar.add(e),
      this.emitter.emit("focus-mode-changed", e, !0);
    let r = "DESCRIBE_SHORTCUT";
    return this.windowHeadlessService.enableHeadlessMode(e, r);
  }
  async handleFocusMode() {
    (await this.browserService.getAllTabs()).forEach((t) =>
      this.trySendMessage(t)
    );
  }
  async handleTabFocusMode(e) {
    let t = await this.browserService.getTabById(e);
    t && this.trySendMessage(t);
  }
  trySendMessage(e) {
    let t = this.applicationRepository.getAppByTab(e);
    if (!t || !e.id) return;
    let r = this.recipesRepository.getRecipeForApp(t);
    !r.hasFocusMode ||
      !t.syncFocusMode ||
      this.sendFocusModeMessage(e.id, r.id);
  }
  disableWindowFocusMode(e) {
    this.windowsInFocusMode.delete(e),
      this.windowsWithHiddenSidebar.has(e) ||
        this.sidebarVisibilityManager.updateVisibilityState(e, !0),
      this.windowsWithHiddenSidebar.delete(e),
      this.emitter.emit("focus-mode-changed", e, !1);
    let t = !0;
    return this.windowHeadlessService.recalculateHeadlessMode(e, t);
  }
};
c();
var on = class {
  constructor(e) {
    this.browserService = e;
  }
  overlappingModalsCount = {};
  hasRegularModalOpened = !1;
  toggleOverlayForModal(e, t, r) {
    t
      ? (r
          ? (this.overlappingModalsCount[e] += 1)
          : (this.hasRegularModalOpened = !0),
        this.browserService.toggleOverlay(e, !0))
      : (r
          ? (this.overlappingModalsCount[e] -= 1)
          : (this.hasRegularModalOpened = !1),
        !this.overlappingModalsCount[e] &&
          !this.hasRegularModalOpened &&
          this.browserService.toggleOverlay(e, !1));
  }
  closeOverlayForRegularModals(e) {
    e.forEach((t) => {
      this.overlappingModalsCount[t] ||
        this.browserService.toggleOverlay(t, !1);
    });
  }
};
c();
var qm = (o, e, t) => o.startChild({ ...e, startTimestamp: Ue(t) }),
  sn = (o, e, t, r) => {
    let i = qm(o, e, t);
    return i.finish(Ue(r)), i;
  },
  zm = (o, e) => {
    o.setTag(e, !0);
  },
  rr = (o, e, t, r = "none") => {
    o.setMeasurement(e, t, r), o.setTag(e, t.toFixed(2));
  },
  mv = (o, e) => {
    o.forEach((t) => {
      t.startTimestamp = Ue(e);
    });
  },
  hv = (o, e) => {
    o.forEach((t) => {
      t.endTimestamp = Ue(e);
    });
  };
c();
c();
var re = new A(),
  Xo = ["workspaces-loaded", "workspaces-changed", "workspaces-changed-active"];
var qI = "extension",
  an = class {
    constructor(e, t, r) {
      this.performanceTransactionManager = e;
      this.startTrx = t;
      this.browserService = r;
      let i = t.startChild(Ee.LOAD_DATA),
        s = i.startChild(Ee.LOAD_WORKSPACES);
      re.once("workspaces-loaded", (a) => {
        rr(t, "workspaces", a.length), s.finish();
        let n = i.startChild(Ee.LOAD_APPS);
        D.once("apps-loaded", (p) => {
          rr(t, "apps", p.length), n.finish();
          let d = i.startChild(Ee.LOAD_ACCOUNTS);
          D.once("accounts-loaded", () => {
            d.finish(), i.finish(), this.tryFinish().catch(l);
          });
        });
      });
    }
    isFinishedLoadingDataOrInitServices = !1;
    async tryFinish() {
      if (!this.isFinishedLoadingDataOrInitServices) {
        this.isFinishedLoadingDataOrInitServices = !0;
        return;
      }
      let e = Date.now(),
        t = Number(ce(Ue(e) - this.startTrx.startTimestamp).toFixed(2)),
        [r, i] = await Promise.all([
          this.browserService.getAllProcesses(),
          this.browserService.getProfileName(),
        ]),
        s = r.filter((a) => a.type === qI && a.profile === i).length;
      rr(
        this.startTrx,
        "memory",
        sa(performance.memory.usedJSHeapSize),
        "megabyte"
      ),
        rr(this.startTrx, "extensions", s),
        this.performanceTransactionManager.finish(this.startTrx, e),
        console.log(
          `Start in: ${t} ms`,
          this.startTrx._measurements,
          this.startTrx.tags,
          this.startTrx.data
        );
    }
  };
c();
var nn = class {
  constructor(e) {
    this.sentry = e;
  }
  set = new Set();
  start(e) {
    let t = this.sentry.startTransaction(e);
    return this.set.add(t), t;
  }
  finish(e, t) {
    this.set.delete(e), e.finish(t);
  }
  forEach(e) {
    this.set.forEach((t) => e(t));
  }
  map(e) {
    let t = [];
    return this.forEach((r) => t.push(e(r))), t;
  }
};
c();
var cn = class {
  constructor(e) {
    this.browserEventsService = e;
    this.browserEventsService.subscribeToMessageExternal((t, r, i) =>
      this.handleExternalMessage(t, i)
    );
  }
  handleExternalMessage(e, t) {
    this.isSitePingMessage(e) && t();
  }
  isSitePingMessage(e) {
    return Ge(e) && oe(e, "type") && e.type === "SIDEKICK_SITE_PING";
  }
};
c();
var pn = "https://web.skype.com/",
  zI = "#sidekick_",
  ln = class {
    constructor(e) {
      this.browserEventsService = e;
      this.browserEventsService.subscribeToBeforeRedirect(
        (t) => {
          if (!t.url.startsWith(pn)) return;
          let r = Gt(t.url);
          !r?.hash || !r.hash.startsWith(zI) || (this.hash = r.hash);
        },
        { urls: [pn] }
      ),
        this.browserEventsService.subscribeToBeforeRequest(
          () => {
            if (!this.hash) return {};
            let { hash: t } = this;
            return (this.hash = null), { redirectUrl: `${pn}${t}` };
          },
          { urls: [pn] },
          ["blocking"]
        );
    }
    hash = null;
  };
c();
var dn = class {
  constructor(e, t, r, i) {
    this.browserService = e;
    this.featureFlagsRepository = t;
    this.userRepository = r;
    this.authService = i;
    this.featureFlagsRepository.onFeatureFlagsLoaded(async (s, a) => {
      a ||
        (await this.userRepository.getEnsuredUserInfo(),
        await this.handleSync());
    });
  }
  handleSync() {
    if (this.featureFlagsRepository.getFeatureFlags().sync) {
      let t = this.authService.getUserId(),
        r = this.userRepository.getUserInfo();
      return this.browserService.handleAuth({
        userId: t,
        avatar: r?.avatar,
        email: r?.email,
        name: r?.name,
      });
    }
    return this.browserService.resetAuth();
  }
};
c();
c();
c();
var yv = "default-browser-setup",
  QI = "system-error",
  YI = "token-expired",
  XI = "start-trial",
  JI = "billing-discount-offer",
  ZI = "gmail-signature",
  eA = "expire-soon-trial",
  tA = "sessions-become-pro",
  Qm = "task-tracker-timer",
  un = class {
    constructor(e, t, r) {
      this.popupService = e;
      this.browserService = t;
      r.subscribeToNormalWindowCreated((i) => {
        Object.keys(this.notifications).length &&
          i.id &&
          this.popupService.showNotificationsStackPopup([i.id], {
            shouldFocusOnShow: this.hasIncomingMeetingNotification(),
          });
      });
    }
    notifications = {};
    emitter = new A();
    onNotificationsChanged(e) {
      return this.emitter.on("changed", e);
    }
    getAllNotifications() {
      return Object.values(this.notifications);
    }
    showBillingStartTrialNotification(e) {
      let t = { id: XI, type: "billing-start-trial", ...e };
      this.showNotification(t);
    }
    showBillingEndTrialNotification(e) {
      let t = { id: eA, type: "billing-end-trial", ...e };
      this.showNotification(t);
    }
    showBillingDiscountOfferNotification(e) {
      let t = { id: JI, type: "billing-discount-offer", ...e };
      this.showNotification(t);
    }
    showGmailSignatureNotification() {
      let e = { id: ZI, type: "gmail-signature" };
      this.showNotification(e);
    }
    showCalendarsSetupNotification() {
      if (this.hasCalendarsSetupNotification()) return;
      let e = { id: le(), type: "calendars-setup" };
      this.showNotification(e);
    }
    showCalendarsSetupSkippedNotification() {
      let e = { id: le(), type: "calendars-setup-skipped" };
      this.showNotification(e);
    }
    showTaskTrackerTimerNotification(e, t, r) {
      let i = {
        id: Qm,
        taskName: e,
        currentSessionSeconds: t,
        maxSessionTimeSeconds: r,
        type: "task-tracker-timer",
        onlyOne: !0,
      };
      this.showNotification(i);
    }
    showDefaultBrowserSetupNotification(e) {
      let t = { id: yv, type: "default-browser-setup", currentShowNumber: e };
      this.showNotification(t);
    }
    showDefaultBrowserSkippedNotification() {
      let e = { id: yv, type: "default-browser-setup-skipped" };
      this.showNotification(e);
    }
    showCalendarsSystemAddedNotification() {
      let e = { id: le(), type: "calendars-system-added" };
      this.showNotification(e), this.scheduleClose(e.id, 1);
    }
    showCalendarsSystemErrorNotification() {
      let e = { id: QI, type: "calendars-system-error" };
      this.showNotification(e), this.scheduleClose(e.id, 1);
    }
    showCalendarsSystemTokenExpiredNotification(e) {
      let t = {
        id: YI,
        type: "calendars-system-token-expired",
        calendarName: e,
      };
      this.showNotification(t);
    }
    showCalendarNotification({
      title: e,
      email: t,
      eventId: r,
      attendees: i,
      exceedingAttendeesCount: s,
      startDateMs: a,
      startDate: n,
      endDate: p,
      callLink: d,
      meetingLink: u,
    }) {
      let m = {
        id: le(),
        title: e,
        email: t,
        eventId: r,
        attendees: i,
        exceedingAttendeesCount: s,
        startDateMs: a,
        startDate: n,
        endDate: p,
        meetingLink: Ht(u),
        callLink: Ht(d),
        type: "incoming-meeting",
      };
      this.showNotification(m),
        this.scheduleClose(m.id, 7),
        this.focusLastFocusedWindow().catch(l);
    }
    showInvitationsReachedFreePlan(e, t) {
      let i = {
        id: "invitations-reached-free-plan",
        type: "invitations-reached-free-plan",
        signUps: e,
        freeMonths: t,
      };
      this.showNotification(i);
    }
    showInvitationsReachedForeverFreePlan(e) {
      let r = {
        id: "invitations-reached-free-plan",
        type: "invitations-reached-forever-free",
        signUps: e,
      };
      this.showNotification(r);
    }
    showBeforeProductHuntNotification() {
      let t = { id: "before-product-hunt", type: "before-product-hunt" };
      this.showNotification(t);
    }
    showSessionsBecomeProNotification() {
      let e = { id: tA, type: "sessions-become-pro" };
      this.showNotification(e);
    }
    showProductHuntLiveNotification() {
      let t = { id: "product-hunt-live", type: "product-hunt-live" };
      this.showNotification(t);
    }
    showNotification(e) {
      if (this.notifications[e.id]) return;
      Object.keys(this.notifications).length ||
        this.showNotificationsStackPopup().catch(l),
        (this.notifications[e.id] = e),
        this.emitter.emit("changed");
    }
    hideNotification(e) {
      delete this.notifications[e],
        Object.keys(this.notifications).length
          ? this.emitter.emit("changed")
          : this.popupService.hideNotificationsStackPopup().catch(l);
    }
    async focusLastFocusedWindow() {
      let e = await this.browserService.getLastFocusedWindowId();
      e && (await this.browserService.focusWindow(e));
    }
    hasCalendarsSetupNotification() {
      return this.getAllNotifications().some(Bb);
    }
    hasIncomingMeetingNotification() {
      return this.getAllNotifications().some(Eb);
    }
    async showNotificationsStackPopup() {
      let e = await this.browserService.getNormalWindowsById(),
        t = Object.values(e).reduce((r, i) => (i.id && r.push(i.id), r), []);
      this.popupService.showNotificationsStackPopup(t, {
        shouldFocusOnShow: this.hasIncomingMeetingNotification(),
      });
    }
    scheduleClose(e, t) {
      setTimeout(() => this.hideNotification(e), ye(t));
    }
  };
var rA = 25,
  Ym = Ue(ye(rA));
var mn = class {
  constructor(e, t, r, i) {
    this.uiNotificationsManager = e;
    this.browserEventsService = t;
    this.browserService = r;
    this.themeService = i;
    this.browserEventsService.subscribeToMessageExternal((s, a, n) =>
      this.handleExternalMessage(s, n)
    ),
      this.browserEventsService.subscribeToWindowRemoved((s) => {
        this.clearCallbackByMessageForRemovedWindow(s);
      }),
      this.themeService.onThemeChanged(() => {
        this.handleThemeChanged(this.themeService.getTheme()).catch(l);
      });
  }
  emitter = new A();
  taskInfo = null;
  timerInterval = null;
  callbackByMessageByWindowId = new Map();
  toggleSiteTaskPauseHandler = null;
  siteDoneTaskHandler = null;
  subscribeTaskInfoUpdate(e) {
    return this.emitter.on("task-info-update", e);
  }
  subscribeToExternalMessageProcessed(e) {
    return this.emitter.on("message-processed", e);
  }
  getTaskInfo() {
    return this.taskInfo;
  }
  handleToggleTaskPause = () => {
    this.toggleSiteTaskPauseHandler?.();
  };
  handleDoneTask = () => {
    this.siteDoneTaskHandler?.();
  };
  handleStopTimer() {
    this.timerInterval &&
      (clearTimeout(this.timerInterval), (this.timerInterval = null));
  }
  handleCreateTask(e) {
    return this.handleCallbackAction("EXTENSION_CREATE_TASK", e);
  }
  handleThemeChanged(e) {
    return this.handleCallbackAction("GET_THEME", e);
  }
  handleExternalMessage(e, t) {
    if (this.isMessage(e))
      switch (e.type) {
        case "START_TRACK_TIMER":
          this.handleStartTimerMessage(e, t);
          break;
        case "PAUSE_TRACK_TIMER":
          this.handlePauseTimerMessage(e), t();
          break;
        case "STOP_TRACK_TIMER":
          this.handleStopTimerMessage(), t();
          break;
        case "EXTENSION_TOGGLE_PAUSE_TIMER":
          this.handleExtensionPauseTimerMessage(e, t);
          break;
        case "EXTENSION_DONE_TASK":
          this.handleExtensionDoneTaskMessage(t);
          break;
        case "SESSION_FINISHED":
          this.endTimerSession(), t();
          break;
        case "SEND_TIMER_VALUE":
          this.updateTimerValue(e.payload.elapsedTrackedTime), t();
          break;
        case "EXTENSION_CREATE_TASK":
          this.handleExtensionCreateTaskMessage(t);
          break;
        case "GET_THEME":
          this.handleGetThemeMessage(t, e.payload.isNeedToSendImmediately);
          break;
        default:
          break;
      }
  }
  async handleCallbackAction(e, t) {
    let r = await this.getCallbackByMessageForCurrentWindow(e);
    if (!r) {
      this.callBackWhenMessageReceived(e, t);
      return;
    }
    r(t);
  }
  callBackWhenMessageReceived(e, t) {
    let r = this.emitter.on("message-processed", (i) => {
      i === e &&
        this.getCallbackByMessageForCurrentWindow(i)
          .then((s) => s?.(t))
          .catch(l)
          .finally(r);
    });
  }
  handleGetThemeMessage(e, t = !1) {
    if (t) {
      e(this.themeService.getTheme());
      return;
    }
    this.setCallbackByMessageForCurrentWindow("GET_THEME", e).catch(l),
      this.emitter.emit("message-processed", "GET_THEME");
  }
  handleExtensionCreateTaskMessage(e) {
    this.setCallbackByMessageForCurrentWindow("EXTENSION_CREATE_TASK", e).catch(
      l
    ),
      this.emitter.emit("message-processed", "EXTENSION_CREATE_TASK");
  }
  async getCallbackByMessageForCurrentWindow(e) {
    let t = await this.browserService.getNormalLastFocusedWindowId();
    if (!t) return Promise.resolve();
    let r = this.callbackByMessageByWindowId.get(t);
    if (!r) return Promise.resolve();
    let i = r.get(e);
    return (
      i ||
      (l(new L("No handler for this window", { extra: { windowId: t } })),
      Promise.resolve())
    );
  }
  async setCallbackByMessageForCurrentWindow(e, t) {
    let r = await this.browserService.getNormalLastFocusedWindowId();
    if (!r) return;
    let i = this.callbackByMessageByWindowId.get(r);
    i ? i.set(e, t) : (i = new Map([[e, t]])),
      this.callbackByMessageByWindowId.set(r, i);
  }
  clearCallbackByMessageForRemovedWindow(e) {
    this.callbackByMessageByWindowId.delete(e);
  }
  handleStartTimerMessage(e, t) {
    (this.taskInfo = { ...e.payload, isPaused: !1 }),
      this.emitter.emit("task-info-update", this.taskInfo),
      this.uiNotificationsManager.showTaskTrackerTimerNotification(
        e.payload.taskName,
        e.payload.elapsedSessionTimeSeconds,
        Ym
      ),
      t();
  }
  handlePauseTimerMessage({ payload: e }) {
    if (!this.taskInfo) {
      g(e.taskName, "Task name should be provided"),
        (this.taskInfo = {
          taskName: e.taskName,
          isPaused: e.isPaused,
          elapsedSessionTimeSeconds: e.elapsedTime,
        }),
        this.emitter.emit("task-info-update", this.taskInfo);
      return;
    }
    (this.taskInfo = { ...this.taskInfo, isPaused: e.isPaused }),
      this.emitter.emit("task-info-update", this.taskInfo);
  }
  handleStopTimerMessage() {
    this.handleStopTimer(), this.uiNotificationsManager.hideNotification(Qm);
  }
  handleExtensionPauseTimerMessage(e, t) {
    this.taskInfo &&
      ((this.taskInfo = { ...this.taskInfo, isPaused: e.payload.isPaused }),
      this.emitter.emit("task-info-update", this.taskInfo)),
      (this.toggleSiteTaskPauseHandler = t);
  }
  handleExtensionDoneTaskMessage(e) {
    this.siteDoneTaskHandler = e;
  }
  endTimerSession() {
    this.uiNotificationsManager.showTaskTrackerTimerNotification(
      this.taskInfo?.taskName ?? "",
      this.taskInfo?.elapsedSessionTimeSeconds ?? Ym,
      Ym
    );
  }
  updateTimerValue(e) {
    g(this.taskInfo, "Task info cannot be empty"),
      (this.taskInfo = { ...this.taskInfo, elapsedSessionTimeSeconds: e }),
      this.emitter.emit("task-info-update", this.taskInfo);
  }
  isMessage(e) {
    return Ge(e) && Wo(e, "type");
  }
};
c();
var yS = Ii(hS(), 1);
c();
var W = new A(),
  Ce = ["user-settings-loaded", "user-settings-changed"];
var eE = "sidekick.forced_user_agent_product",
  tE = "sidekick.random_user_agent_whitelist",
  rE = "sidekick.random_user_agent",
  An = class {
    constructor(e, t, r, i) {
      this.browserService = e;
      this.featureFlagsRepository = t;
      this.systemInfoService = r;
      this.userSettingsRepository = i;
      this.featureFlagsRepository.onFeatureFlagsLoaded(
        this.setUserAgent.bind(this)
      ),
        W.on("user-settings-changed", this.setRandomUserAgent.bind(this)),
        this.setRandomUserAgent(),
        this.setUserAgent();
    }
    setRandomUserAgent() {
      this.browserService
        .setPref(rE, this.userSettingsRepository.getSettings().randomUserAgent)
        .catch(l);
    }
    setUserAgent() {
      this.browserService
        .setPref(eE, this.findUserAgentToForce() || "")
        .catch(l),
        this.browserService
          .setPref(
            tE,
            this.featureFlagsRepository.getFeatureFlags().randomUserAgent
              .disabledDomains || []
          )
          .catch(l);
    }
    extractMajorVersion(e) {
      let t = yS.default.coerce(e);
      return (
        g(t, "Could not extract major version: failed to coerce fillVersion", {
          fullVersion: e,
        }),
        t.major
      );
    }
    findUserAgentToForce() {
      let e = this.featureFlagsRepository.getFeatureFlags().forcedUserAgents;
      if (!e) return null;
      let t = this.extractMajorVersion(this.systemInfoService.browserVersion),
        r = e?.[t];
      if (!r) return null;
      let i = this.isRuleMatchedByAppInfo.bind(this),
        s = r.find(i);
      return s ? s.value : null;
    }
    isRuleMatchedByAppInfo(e) {
      switch (e.platform) {
        case "win":
          return this.systemInfoService.isWindows;
        case "linux":
          return this.systemInfoService.isLinux;
        case "mac":
          return (
            this.systemInfoService.isMac && !this.systemInfoService.isMacM1
          );
        case "arm64":
          return this.systemInfoService.isMacM1;
        default:
          return !1;
      }
    }
  };
c();
var ir = (o, e, t = Ve.LEFT_TOP) => ({
    x: o,
    y: e,
    anchor: { windowRelativeAnchor: t },
  }),
  Pn = class {
    constructor(e, t, r, i, s) {
      this.browserService = e;
      this.popupService = t;
      this.walkthroughService = r;
      this.userSettingsRepository = i;
      this.helpServiceV2 = s;
      this.walkthroughService.onUpdate(() => ee(this.handleUpdate()));
    }
    async handleUpdate() {
      let e = this.walkthroughService.getCurrentStep();
      if (!e) return;
      let t = await this.browserService.getLastFocusedWindowId();
      if (e.step === "multiAccount") {
        let { index: i } =
          this.walkthroughService.findFirstMultiAccountAppPosition(t);
        if (i === -1) {
          this.walkthroughService.markStepAsPassed(e.step).catch(l);
          return;
        }
      }
      let r = this.getPosition(e, t);
      r && this.popupService.toggleWalkthroughPopup(e, r).catch(l);
    }
    getPosition({ step: e, context: t }, r) {
      switch (e) {
        case "sidebar":
          return ir(0, 100);
        case "multiAccount": {
          if (t) return;
          let { index: i } =
            this.walkthroughService.findFirstMultiAccountAppPosition(r);
          g(
            i !== -1,
            "Failed to get Step.MultiAccount position: first multiaccount position not found fot windowId",
            { windowId: r }
          );
          let s = this.userSettingsRepository.getSidebarWidth(),
            a = 10;
          return ir(0, i * s - 2 * a);
        }
        case "sessions":
          return t ? ir(291, 100) : ir(0, 0, Ve.LEFT_BOTTOM);
        case "tasks":
          return ir(0, 0, Ve.LEFT_BOTTOM);
        case "collections":
          return ir(0, 0, Ve.LEFT_BOTTOM);
        case "splitView":
          return ir(0, 0, Ve.RIGHT_TOP);
        case "search":
          return t ? void 0 : ir(0, 0, Ve.LEFT_BOTTOM);
        case "final":
          return this.helpServiceV2.getIsNtpMode()
            ? ir(-16, -64, Ve.RIGHT_BOTTOM)
            : ir(0, 0, Ve.LEFT_BOTTOM);
        default:
          return;
      }
    }
  };
c();
var gS = [
    "sidebar",
    "multiAccount",
    "sessions",
    "collections",
    "tasks",
    "splitView",
    "final",
  ],
  Rn = class {
    constructor(e, t, r, i, s, a, n, p, d, u, m, y) {
      this.onboardingDataService = e;
      this.browserService = t;
      this.modalService = r;
      this.sidecarService = i;
      this.browserStorage = s;
      this.popupService = a;
      this.workspaceRepository = n;
      this.appRepository = p;
      this.browserEventsService = d;
      this.featureFlagsRepository = u;
      this.analyticsTracker = m;
      this.helpServiceV2 = y;
      u.onFeatureFlagsLoaded(() => this.tryInit()),
        this.onboardingDataService.getIsInitialOnboarding()
          ? (D.once("apps-added-after-onboarding", (b) => {
              this.loadNewState(b).catch(l);
            }),
            this.markAsReady())
          : D.once("apps-loaded", () => {
              this.tryLoadFromSavedState().catch(l);
            });
    }
    switchWalkthrough = this.wrap(this.switchWalkthroughSync.bind(this));
    markStepAsPassed = this.wrap(this.markStepAsPassedSync.bind(this));
    handleSidecarChange = this.wrap(this.handleSidecarChangeSync.bind(this));
    handleSplitViewChange = this.wrap(
      this.handleSplitViewChangeSync.bind(this)
    );
    isReady = !1;
    isPostponed = !1;
    isInitialized = !1;
    steps = [];
    currentStep = null;
    state = null;
    emitter = new A();
    tryInit() {
      this.isInitialized ||
        !this.getIsAvailable() ||
        ((this.isInitialized = !0),
        this.modalService.subscribeToModalChanged((e, t) => {
          t && this.handleModalChange(e, t);
        }),
        this.sidecarService.onSidecarChanged(() =>
          ee(this.handleSidecarChange())
        ),
        this.popupService.subscribeToPopupChanged((e) =>
          this.handlePopupChange(e)
        ),
        this.browserEventsService.subscribeToSplitViewChange(async (e) => {
          ee(this.handleSplitViewChange(e));
          let t = (await this.browserService.getActiveTab())?.id;
          !e.locals.some(({ splitPair: i }) => i.left === t || i.right === t) &&
            this.currentStep?.step === "splitView" &&
            (await this.markStepAsPassed("splitView"));
        }),
        this.runAfterHooks());
    }
    onUpdate(e) {
      return this.emitter.on("walkthrough-updated", e);
    }
    getIsAvailable() {
      return (
        this.isReady &&
        this.featureFlagsRepository.getFeatureFlag("walkthrough") &&
        this.hasUncompletedSteps()
      );
    }
    getIsPostponed() {
      return this.isPostponed;
    }
    getSteps() {
      return this.steps.filter((e) => e.key !== "help");
    }
    getCurrentStepNumber() {
      return !this.currentStep || this.currentStep?.step === "final"
        ? null
        : this.getFinishedSteps().length + 1;
    }
    getCurrentStep() {
      return this.currentStep;
    }
    async markAsPassedWithUpdate(e) {
      (this.getCurrentStep()?.step === e ||
        this.getSteps().find(({ finished: t }) => !t)?.key === e) &&
        (await this.markStepAsPassed(e)),
        this.runAfterHooks();
    }
    isFinished() {
      return !this.hasUncompletedSteps();
    }
    hasUncompletedSteps() {
      return this.steps.some((e) => !e.finished);
    }
    getFinishedSteps() {
      return this.getSteps().filter((e) => e.finished);
    }
    updateSteps(e) {
      return (
        (this.steps = e), this.browserStorage.setItem("walkthrough-steps", e)
      );
    }
    updatePostponed(e) {
      return (
        (this.isPostponed = e),
        this.browserStorage.setItem("walkthrough-postponed", e)
      );
    }
    markAsReady() {
      (this.isReady = !0), this.tryInit();
    }
    async switchWalkthroughSync(e = !1) {
      await this.browserStorage.setItem(
        "walkthrough-postponed",
        (this.isPostponed = !e)
      );
    }
    async markStepAsPassedSync(e) {
      this.isPostponed ||
        (await this.updateSteps(
          this.steps.map((t) => (t.key === e ? { key: e, finished: !0 } : t))
        ),
        this.analyticsTracker.sendAnalyticsEvent("walkthrough.step-passed", {
          step: e,
        }),
        this.isFinished() &&
          this.helpServiceV2.getIsNtpMode() &&
          this.helpServiceV2.setItemCompleted(
            "productivity",
            "finish-walkthrough"
          ));
    }
    markGlobalSearchInLaunchpadAsCompleted(e, t) {
      (!this.state && !t) ||
        ((this.state = t ? "globalSearchLaunchpad" : null),
        t && this.popupService.hidePopup(e, "walkthrough"),
        this.runAfterHooks());
    }
    findFirstMultiAccountAppPosition(e) {
      let t = { appId: null, index: -1 },
        r = this.workspaceRepository.getWorkspaceForWindow(e);
      if (!r) return t;
      let { pinnedOrderAppIds: i } = r,
        s = i.findIndex(
          (a) => this.appRepository.getAppById(a)?.recipeMetaData.accountsType
        );
      return s === -1 ? t : { appId: i[s] ?? null, index: s };
    }
    evaluate() {
      if (
        ((this.currentStep = null),
        !(this.getIsPostponed() || !this.getIsAvailable()))
      )
        switch (this.state) {
          case "applicationPopup":
            this.setCurrentStepIfAvailable("multiAccount", "popup", !0);
            break;
          case "sessions":
            this.setCurrentStepIfAvailable("sessions", "sidecar", !0);
            break;
          case "marketplace":
            this.setCurrentStepIfAvailable("customApps", "modal", !0);
            break;
          case "globalSearchModal":
            this.setCurrentStepIfAvailable("search", "modal", !0);
            break;
          case "splitView":
            this.setCurrentStepIfAvailable("splitView", "splitView", !1);
            break;
          case "help":
            this.setCurrentStepIfAvailable("help", "sidecar", !0);
            break;
          case "addApplicationModal":
            this.setCurrentStepIfAvailable("customApps", "appSaveModal", !1);
            break;
          default:
            this.setCurrentStepIfAvailable();
        }
    }
    setCurrentStepIfAvailable(e, t, r) {
      if (e) {
        let s = this.steps.find(({ key: a }) => a === e)?.finished;
        if ((s || (this.currentStep = { step: e, context: t }), !s || r))
          return;
      }
      let i = this.steps.find(({ finished: s }) => !s);
      this.currentStep = i ? { step: i.key } : null;
    }
    async tryLoadFromSavedState() {
      let e = await this.browserStorage.getItem("walkthrough-steps");
      if (!e?.length) return;
      let t = await this.browserStorage.getItem("walkthrough-postponed");
      (this.steps = e), (this.isPostponed = t ?? !1), this.markAsReady();
    }
    createSteps(e) {
      let t = new Array();
      return (
        gS.forEach((r) => {
          (!e && r === "multiAccount") ||
            (!this.featureFlagsRepository.getFeatureFlag("tasksEnabled") &&
              r === "tasks") ||
            (!this.featureFlagsRepository.getFeatureFlag(
              "collectionsEnabled"
            ) &&
              r === "collections") ||
            t.push({ key: r, finished: !1 });
        }),
        this.analyticsTracker.sendAnalyticsEvent("walkthrough.first-shown", {
          step: gS[0],
        }),
        t
      );
    }
    async loadNewState(e) {
      let t = e.some(({ app: r }) => r.recipeMetaData.accountsType);
      await this.updateSteps(this.createSteps(t)),
        await this.updatePostponed(!1),
        this.tryInit();
    }
    handleModalChange(e, t) {
      if (!(!this.state && !e)) {
        switch (e) {
          case "global-search":
            this.state = "globalSearchModal";
            break;
          case "marketplace":
            this.state = "marketplace";
            break;
          case "add-application":
            this.state = "addApplicationModal";
            break;
          default:
            this.state = null;
        }
        e && this.popupService.hidePopup(t, "walkthrough"),
          this.runAfterHooks();
      }
    }
    async handleSidecarChangeSync() {
      this.state = null;
      let e = await this.browserService.getLastFocusedWindowId();
      if (!e) return;
      let t = this.sidecarService.getSidecarForWindow(e);
      if (t?.mode)
        switch ((this.popupService.hidePopup(e, "walkthrough"), t.mode)) {
          case "sessions":
            this.state = "sessions";
            break;
          case "tasks":
            this.state = "tasks";
            break;
          case "collections":
            this.state = "collections";
            break;
          case "help":
            if (this.getCurrentStep()?.step === "final") {
              await this.markStepAsPassed("final");
              return;
            }
            this.state = "help";
            break;
          default:
        }
    }
    handlePopupChange(e) {
      let t = this.state === "applicationPopup";
      if (this.state && !t) return;
      let i = this.popupService.getVisiblePopupIds(e).includes("application");
      t !== i &&
        ((this.state = i ? "applicationPopup" : null),
        i && this.popupService.hidePopup(e, "walkthrough"),
        this.runAfterHooks());
    }
    handleSplitViewChangeSync(e) {
      this.state = e.locals.length ? "splitView" : null;
    }
    runAfterHooks() {
      this.evaluate(), this.emitter.emit("walkthrough-updated");
    }
    wrap(e) {
      return async (...t) => {
        this.getIsAvailable() && (await e.apply(this, t), this.runAfterHooks());
      };
    }
  };
c();
c();
var En = class {
  constructor(e, t) {
    this.modalApi = e;
    this.adblockerService = t;
  }
  addAdblockerDomain(e) {
    return this.adblockerService.addAdblockerDomain(e);
  }
  removeAdblockerDomain(e) {
    return this.adblockerService.removeAdblockerDomain(e);
  }
  openAdBlockerSettings() {
    return this.modalApi.showGlobalSettingsModal({
      source: "adblocker-popup.manage-clicked",
      tabId: "ad-blocker",
    });
  }
};
c();
c();
c();
var sE = (o) => {
    o.forEach((e) => e()), (o.length = 0);
  },
  F = (o) => () => sE(o);
var Bn = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m, y, b) {
    this.analytics = e;
    this.applicationApi = t;
    this.popupService = r;
    this.featureFlagsRepository = i;
    this.shortcutService = s;
    this.workspaceApi = a;
    this.userSettingsRepository = n;
    this.modalService = p;
    this.billingApi = d;
    this.workspaceRepository = u;
    this.billingRepository = m;
    this.applicationRepository = y;
    this.hintsApi = b;
  }
  showInvitationsPopup() {
    return this.billingApi.showInvitationsPopup();
  }
  startPlanUpgrade(e) {
    return this.billingApi.startPlanUpgrade(e);
  }
  createAccount(e, t) {
    let r = this.workspaceRepository.getWorkspaceIdForWindow(e);
    r && this.applicationApi.createAccount(r, t);
  }
  deleteAccount(e, t, r) {
    let i = this.workspaceRepository.getWorkspaceIdForWindow(e);
    i && this.applicationApi.deleteAccount(i, t, r).catch(l);
  }
  editAccount(e, t, r) {
    let i = this.workspaceRepository.getWorkspaceIdForWindow(e);
    i && this.applicationApi.updateAccount(i, t, r);
  }
  changeAppIcon(e, t) {
    return this.applicationApi.changeIcon(e, t);
  }
  changeAppName(e, t) {
    this.applicationApi.changeAppName(e, t);
  }
  changeDisableNotificationBadgeNumber(e, t) {
    this.applicationApi.changeDisableNotificationBadgeNumber(e, t);
  }
  changeDisableNotificationMessages(e, t) {
    this.applicationApi.changeDisableNotificationMessages(e, t);
  }
  changeDoNotSuspend(e, t) {
    this.applicationApi.changeDoNotSuspend(e, t);
  }
  changeIsMuted(e, t) {
    return this.applicationApi.changeIsMuted(e, t);
  }
  changeIsNotificationBadgeEnabled(e, t) {
    this.applicationApi.changeIsNotificationBadgeEnabled(e, t);
  }
  changeIsNotificationEnabled(e, t) {
    return this.applicationApi.changeIsNotificationEnabled(e, t);
  }
  changeIsPinned(e, t, r) {
    return this.workspaceApi.changeAppIsPinned(e, t, r);
  }
  changeShowAsSidecarPanel(e, t) {
    return this.applicationApi.changeShowAsSidecarPanel(e, t);
  }
  closeAppById(e) {
    return this.applicationApi.closeApplicationTab(e);
  }
  removeAppFromWorkspace(e, t) {
    return this.workspaceApi.removeAppFromWorkspace(e, t);
  }
  resetAppIcon(e) {
    return this.applicationApi.resetIcon(e);
  }
  changeSyncFocusMode(e, t) {
    this.applicationApi.changeSyncFocusModeEnabled(e, t);
  }
  activateAccountToAppById(e, t, r, i) {
    let s = this.applicationApi.getRecipeIdByAppId(e);
    g(s, "Failed to activate account for app: no recipeId");
    let a = this.applicationRepository.getAppById(e);
    g(a, "Failed to activate account for app: no app");
    let n = this.workspaceRepository.getWorkspaceById(a.workspaceId);
    if (
      (this.analytics.sendAnalyticsEvent(
        r ? "app.activated-as-tab" : "app.activated",
        {
          source: i,
          "app.recipe-id": s,
          "app.is-team-app": a.isTeamApp,
          "app.is-shared": a.sharedToMe,
          "team.uuid": n?.teamUuid ?? null,
        }
      ),
      r)
    ) {
      this.applicationApi
        .activateApplicationsAsTab(e, { accountId: t })
        .catch(l);
      return;
    }
    this.applicationApi.activateAccountToAppById(e, t);
  }
  showShareApplicationModal(e, t) {
    return this.billingApi.showLimitPopupIfBlocked(
      this.billingRepository.canShareApp,
      "add-app-popup-accounts"
    )
      ? Promise.resolve()
      : this.modalService.showShareApplicationModal(e, t);
  }
  showLimitsReachedModal(e, t) {
    return this.modalService.showBillingLimitsReachedModal(e, t);
  }
  subscribeAppPopup(e, t) {
    let r = () => t(this.loadAppPopup(e));
    this.hintsApi.closeHintManually("settings_app_menu");
    let i = [
        "apps-loaded",
        "accounts-loaded",
        "apps-changed",
        "accounts-changed",
      ],
      s = [
        this.featureFlagsRepository.onFeatureFlagsLoaded(r),
        D.onSeveral(i, r),
        re.on("workspaces-changed", r),
        this.popupService.subscribeToPopupChanged((a) => {
          e === a && r();
        }),
      ];
    return r(), F(s);
  }
  loadAppPopup(e) {
    let t = this.popupService.getPopupInfo(e, "application");
    if (t?.id !== "application") return null;
    let r = this.workspaceRepository.getWorkspaceForWindow(e);
    if (!r) return null;
    let i = this.applicationApi.composeAppForAppPopup(e, t.payload.appId);
    if (!i) return null;
    let s = this.featureFlagsRepository.getFeatureFlag(
        "isHoverAppMenuSidebarEnabled"
      ),
      { closingTime: a, autoClosingTime: n } =
        this.featureFlagsRepository.getFeatureFlag("hoverAppMenuSidebar"),
      {
        browserCloseTab: p,
        browserCopy: d,
        openInSplitView: u,
      } = this.shortcutService.getShortcuts(),
      { sidebarSize: m } = this.userSettingsRepository.getSettings(),
      y = this.billingRepository.canAddAccount(i.accounts.length),
      b = r.pinnedOrderAppIds.findIndex((I) => I === t.payload.appId),
      v = b < 10 ? this.shortcutService.getAppShortcut(b) : void 0,
      S = s ? a : null,
      w = this.billingRepository.getShouldUseProBadgesForUI(),
      T = this.billingRepository.canUseSplitView();
    return {
      ...i,
      appShortcut: v,
      areMultipleAccountsAllowed: y,
      autoClosingTime: n,
      browserCloseTabShortcutKeys: p.keys,
      copyShortcutKeys: d.keys,
      hasSharingAppsFeature: Boolean(
        this.featureFlagsRepository.getFeatureFlags().sharingApps
      ),
      hoverClosingTime: S,
      isHoverAppMenuSidebarEnabled: s,
      openInSplitViewShortcutKeys: u.keys,
      sidebarSize: m,
      useProBadges: w,
      isSplitViewAllowed: T,
    };
  }
};
c();
var _n = class {
  constructor(e) {
    this.exploredFeaturesService = e;
  }
  explore(e) {
    return this.exploredFeaturesService.explore(e);
  }
};
c();
var Fn = class {
  constructor(e, t, r, i, s, a, n, p, d) {
    this.helpService = e;
    this.helpServiceV2 = t;
    this.helpExperimentalLayer = r;
    this.shortcutService = i;
    this.systemInfo = s;
    this.videosService = a;
    this.userApi = n;
    this.featureFlagsRepository = p;
    this.billingApi = d;
  }
  subscribeHelpState(e, t) {
    let r = () => t(this.loadHelpState(e)),
      i = [
        ...this.helpExperimentalLayer.onHelpStateChanged(r),
        this.shortcutService.onShortcutsUpdated(r),
        this.videosService.onVideosUpdate(r),
        this.featureFlagsRepository.onFeatureFlagsLoaded(r),
      ];
    return r(), F(i);
  }
  setHelpChecklistItemCompleted(e, t) {
    return this.helpServiceV2.setItemCompleted(e, t);
  }
  addFeatureToChecklist(e) {
    return this.helpService.addItemCompleteList(e);
  }
  toggleExploreSidekickPopup(e) {
    this.helpServiceV2.toggleExploreSidekickPopup(e).catch(l);
  }
  showInvitationsPopup() {
    return this.billingApi.showInvitationsPopup();
  }
  loadHelpState(e) {
    let {
        globalSearch: t,
        switchSession: r,
        manageSession: i,
        openInSplitView: s,
        switchTab: a,
        activateServiceRange: n,
        toggleLastSplitPanel: p,
        openSplitMenu: d,
        browserCloseTab: u,
        createNewTab: m,
        help: y,
        toggleSidebar: b,
        switchFocusMode: v,
      } = this.shortcutService.getShortcuts(),
      { browserVersion: S, extensionVersion: w } = this.systemInfo,
      T = this.featureFlagsRepository.getFeatureFlag("helpLinks"),
      I = this.featureFlagsRepository.getFeatureFlag("enableExploreSidekickV2");
    return {
      activateServiceShortcutKeys: n.keys,
      browserCloseTabShortcutKeys: u.keys,
      browserVersion: S,
      completedList: this.helpService.getCompletedList(),
      createNewTabShortcutKeys: m.keys,
      feedbackUrl: this.userApi.generateFeedbackUrl(),
      productivityChecklistState: {
        checklist: this.helpServiceV2.getProductivityChecklist(),
        switchTabShortcutKeys: a.keys,
        globalSearchShortcutKeys: t.keys,
        openInSplitViewShortcutKeys: s.keys,
        videosData: this.videosService.getVideos(),
      },
      focusAndDisciplineChecklistState: {
        checklist: this.helpServiceV2.getFocusAndDisciplineChecklist(),
        manageSessionShortcutKeys: i.keys,
        switchFocusModeShortcutKeys: v.keys,
        videosData: this.videosService.getVideos(),
      },
      superheroModeChecklistState: {
        checklist: this.helpServiceV2.getSuperheroModeChecklist(),
        isSuperheroModeLocked: !this.helpServiceV2.getIsSuperheroModeUnlocked(),
      },
      gettingThingsDoneChecklistState: {
        checklist: this.helpServiceV2.getGettingThingsDoneChecklist(),
        tasksAndCollectionsButtonName:
          this.helpServiceV2.getTasksAndCollectionsButtonText(e),
      },
      extensionVersion: w,
      globalSearchShortcutKeys: t.keys,
      helpLinks: T,
      manageSessionShortcutKeys: i.keys,
      openHelpShortcutKeys: y.keys,
      openInSplitViewShortcutKeys: s.keys,
      openLastSplitPanelShortcutKeys: p.keys,
      openSplitMenuShortcutKeys: d.keys,
      progress: this.helpExperimentalLayer.getProgress(),
      switchFocusModeShortcutKeys: v.keys,
      switchSessionShortcutKeys: r.keys,
      switchTabShortcutKeys: a.keys,
      toggleSidebarShortcutKeys: b.keys,
      useExploreSidekickV2: I,
      isNtpMode: this.helpServiceV2.getIsNtpMode(),
      videosReadyToUse: this.videosService.getVideos(),
    };
  }
};
c();
var Mn = class {
  constructor(e, t, r, i) {
    this.modalService = e;
    this.billingApi = t;
    this.billingRepository = r;
    this.externalAuthService = i;
  }
  showDistractionBlockerIntroModal(e) {
    return this.modalService.showDistractionBlockerIntroModal(e);
  }
  showAddApplicationModal(e) {
    return this.modalService.showAddApplicationModal(e);
  }
  showMarketplaceModal(e) {
    return this.modalService.showMarketplaceModal(e);
  }
  showGlobalSettingsModal(e) {
    return this.modalService.showGlobalSettingsModal(e);
  }
  showAccountSettingsPopup(e) {
    return this.modalService.showAccountSettingsPopup(e);
  }
  showVerticalTabsModal(e) {
    return this.modalService.showVerticalTabsModal(e);
  }
  showShareApplicationModal(e, t) {
    return this.billingApi.showLimitPopupIfBlocked(
      () => this.billingRepository.canShareApp(),
      "application-popup-accounts"
    )
      ? Promise.resolve()
      : this.modalService.showShareApplicationModal(e, t);
  }
  showCpuMonitorSettingPopup(e) {
    return this.modalService.showCpuMonitorSettingPopup(e);
  }
  showVideoModal(e) {
    return this.modalService.showVideoModal(e);
  }
  showCalendarModal(e) {
    return this.modalService.showCalendarModal(e);
  }
  showIntegrationSettingsPopup(e) {
    return this.modalService.showIntegrationsSettingsPopup(e);
  }
  showUpgradeModal(e) {
    return this.billingApi.startPlanUpgrade(e);
  }
  showLimitsReachedModal(e) {
    return this.modalService.showBillingLimitsReachedModal(e);
  }
  showWorkspaceCreationModal(e, t) {
    return this.billingApi.showLimitPopupIfBlocked(
      () => this.billingApi.canAddWorkspace(),
      "application-popup-accounts"
    )
      ? Promise.resolve()
      : this.modalService.showWorkspaceCreationModal(e, t);
  }
  showWorkspacesManagementModal(e, t) {
    return this.modalService.showWorkspacesManagementModal(e, t);
  }
  showWorkspaceEditingModal(e) {
    return this.modalService.showWorkspaceEditingModal(e);
  }
  showCollectionShareModal(e) {
    return this.modalService.showCollectionShareModal(e);
  }
  closeModal(e) {
    this.modalService.closeModal(e);
  }
  closeAllModalsById(e) {
    this.modalService.closeAllModalsById(e);
  }
  loadOauthData(e, t, r = !1) {
    let i = this.externalAuthService.getLastCredentialsByScope(e, t);
    return i && !r
      ? { success: !0, key: i[0] }
      : { url: this.externalAuthService.getOauthUrl(e, t), success: !1 };
  }
  saveOauthData(e, t, r) {
    return this.externalAuthService.setOauthData(e, t, r);
  }
  subscribeCurrentModal(e, t) {
    let r = this.modalService.subscribeToModalChanged(() =>
      t(this.loadCurrentModal(e))
    );
    return t(this.loadCurrentModal(e)), r;
  }
  loadCurrentModal(e) {
    return this.modalService.getModalForWindow(e) ?? null;
  }
};
c();
var xn = class {
  constructor(e, t) {
    this.systemInfoService = e;
    this.browserService = t;
  }
  openTab(e) {
    this.browserService.createActiveTab(e);
  }
  openChromeImport() {
    this.openTab(mr.importData);
  }
  openChromeShortcuts() {
    this.openTab(mr.shortcuts);
  }
  openManageColors() {
    this.openTab(mr.manageProfile);
  }
  subscribePlatform(e) {
    return e({ isMac: this.systemInfoService.isMac }), () => {};
  }
};
c();
var Wn = class {
  constructor(e) {
    this.popupService = e;
  }
  showApplicationPopupSilently(e) {
    return this.popupService.showApplicationPopupSilently(e);
  }
  async showApplicationPopupSettings(e) {
    let r = {
      silent: !1,
      settingsView: !0,
      ...(this.popupService.getLastActivatedAppPopupInfo(e) || {}),
    };
    return this.popupService.showApplicationPopup(e, r);
  }
  hidePopup(e, t, r) {
    this.popupService.hidePopup(e, t, r);
  }
  subscribePopupInfo(e, t, r) {
    let i = () => r(this.popupService.getPopupInfo(e, t)),
      s = this.popupService.subscribeToPopupChanged((a) => {
        e === a && i();
      });
    return i(), s;
  }
};
c();
c();
var Dn = class {
  constructor(e, t) {
    this.productHuntService = e;
    this.platformApi = t;
  }
  openBeforeLanding() {
    this.platformApi.openTab(
      "https://www.meetsidekick.com/we-need-your-support"
    ),
      this.productHuntService.disableBeforeLandingPopup();
  }
  openLiveLanding() {
    this.platformApi.openTab(this.productHuntService.getProductHuntLink()),
      this.productHuntService.disableProductHuntLivePopup();
  }
  closeProductHuntPopup() {
    this.productHuntService.closeProductHuntPopup();
  }
  subscribePopupState(e) {
    let t = () => e(this.loadPopupState()),
      r = [this.productHuntService.onStateChanged(t)];
    return t(), F(r);
  }
  loadPopupState() {
    let e = this.productHuntService.getCurrentPopup();
    return {
      beforeProductHuntPopupVisible: e === 1,
      productHuntLivePopupVisible: e === 2,
    };
  }
};
c();
var Un = class {
  constructor(e, t, r, i, s, a) {
    this.searchService = e;
    this.shortcutService = t;
    this.exploredFeaturesService = r;
    this.userApi = i;
    this.userSettingsRepository = s;
    this.commandsService = a;
  }
  searchInApp(...e) {
    return this.searchService.searchInApp(...e);
  }
  searchGlobally(...e) {
    return this.searchService.searchGlobally(...e);
  }
  openSearchItem(e) {
    return this.searchService.openSearchItem(e);
  }
  activateCommand(e, t) {
    this.commandsService.activateCommand(e, t);
  }
  loadGlobalSearchState() {
    let { browserCopy: e, globalSearch: t } =
        this.shortcutService.getShortcuts(),
      r = this.userSettingsRepository.getSettings();
    return {
      isUnexplored: !this.exploredFeaturesService.getIsFeatureExplored(
        "performed_global_search"
      ),
      isHiddenWelcomeGlobalSearch: r.isHiddenWelcomeGlobalSearch,
      shortcutCommands: this.commandsService.getShortcutCommands(),
      commands: this.commandsService.getCommands(),
      globalSearchShortcutKeys: t.keys,
      copyShortcutKeys: e.keys,
    };
  }
  changeIsHiddenWelcomeGlobalSearch(e) {
    this.userApi.changeIsHiddenWelcomeGlobalSearch(e);
  }
  subscribeGlobalSearchState(e) {
    let t = () => e(this.loadGlobalSearchState()),
      r = [W.on("user-settings-changed", t)];
    return t(), F(r);
  }
};
c();
c();
var jn = class {
  constructor(e, t, r, i, s, a, n) {
    this.popupService = e;
    this.sidebarVisibilityManager = t;
    this.sessionApi = r;
    this.sessionRepository = i;
    this.tasksContextMenuService = s;
    this.collectionsContextMenuService = a;
    this.analyticsTracker = n;
  }
  emitter = new A();
  subscribeToTabMenuState(e, t) {
    let r = (s, a) => {
        t(this.loadTabMenuState(s, a));
      },
      i = [
        this.popupService.subscribeToPopupChanged(r),
        this.subscribeToTabMenuHover((s) => r(e, s)),
      ];
    return r(e), F(i);
  }
  subscribeToTabGroupMenuState(e, t) {
    let r = (s, a) => {
        t(this.loadTabGroupMenuState(s, a));
      },
      i = [
        this.popupService.subscribeToPopupChanged(r),
        this.subscribeToTabGroupMenuHover((s) => r(e, s)),
      ];
    return r(e), F(i);
  }
  addTabToTasks(e, t) {
    this.tasksContextMenuService.createTask(e, t).catch(l);
  }
  addTabToCollection(e, t) {
    let { collectionId: r, tab: i } = e;
    this.collectionsContextMenuService
      .createLink(r, i.url, i.title || i.url, t)
      .catch(l);
  }
  async showTabContextMenu(e, t) {
    let r = !this.sidebarVisibilityManager.getVisibilityState(t);
    await this.popupService.showTabContextMenuPopup(
      e.position,
      this.getContextMenuPayload(e.sessionId, e.tab, t, e.topOffset),
      r,
      t
    );
  }
  async showTabGroupContextMenu(e, t) {
    let r = !this.sidebarVisibilityManager.getVisibilityState(t);
    await this.popupService.showTabGroupContextMenuPopup(e.position, e, r, t);
  }
  hideTabContextMenu(e) {
    this.popupService.hideVerticalTabContextMenuPopup(e);
  }
  hideTabGroupContextMenu(e) {
    this.popupService.hideVerticalTabGroupContextMenuPopup(e);
  }
  ungroupTabsFromTabGroup(e, t) {
    return (
      this.analyticsTracker.sendAnalyticsEvent(
        "system.vertical-tabs.tab-group-deleted",
        void 0
      ),
      this.sessionApi.ungroupTabsFromTabGroup(e, t)
    );
  }
  closeTabGroup(e, t) {
    return (
      this.analyticsTracker.sendAnalyticsEvent(
        "system.vertical-tabs.tab-group-deleted",
        void 0
      ),
      this.sessionApi.closeTabGroup(e, t)
    );
  }
  updateTabGroup(e, t, r) {
    return (
      this.analyticsTracker.sendAnalyticsEvent(
        "system.vertical-tabs.tab-group-updated",
        void 0
      ),
      this.sessionApi.updateTabGroup(e, t, r)
    );
  }
  async addNewTabToTabGroup(e, t) {
    return this.sessionApi.openNewTabInTabGroup(e, t);
  }
  async addTabToNewTabGroup(e, t, r) {
    let i = this.sessionRepository.getTab(t, r);
    if (!i?.browserId) return;
    let s = {
      id: le(),
      collapsed: !1,
      color: "grey",
      title: "Untitled",
      tabIds: [i.browserId],
    };
    return (
      this.analyticsTracker.sendAnalyticsEvent(
        "system.vertical-tabs.tab-group-created",
        void 0
      ),
      this.sessionApi.createTabGroup(e, t, s)
    );
  }
  async addTabToTabGroup(e, t, r) {
    return this.sessionApi.addTabToTabGroup(e, t, r);
  }
  removeTabFromTabGroup(e, t) {
    return this.sessionApi.removeTabFromTabGroup(e, t);
  }
  notifyTabContextMenuHovered(e) {
    this.emitter.emit("tab-menu-hover", e);
  }
  notifyTabGroupContextMenuHovered(e) {
    this.emitter.emit("tab-group-menu-hover", e);
  }
  subscribeToTabMenuHover(e) {
    return this.emitter.on("tab-menu-hover", e);
  }
  subscribeToTabGroupMenuHover(e) {
    return this.emitter.on("tab-group-menu-hover", e);
  }
  loadTabMenuState(e, t = null) {
    return {
      idWithActiveMenu: this.popupService.getPopupInfo(
        e,
        "vertical-tab-context-menu"
      )?.payload?.tab.id,
      isHovered: t?.isHovered ?? !1,
    };
  }
  loadTabGroupMenuState(e, t = null) {
    return {
      idWithActiveMenu: this.popupService.getPopupInfo(
        e,
        "vertical-tab-group-context-menu"
      )?.payload?.tabGroup.id,
      isHovered: t?.isHovered ?? !1,
    };
  }
  getContextMenuPayload(e, t, r, i) {
    let s = this.sessionApi.mapSessionsToUI(
        this.sessionRepository
          .getSessionsArray()
          .filter((u) => !u.isTemporary && u.id !== e)
      ),
      a = this.collectionsContextMenuService.getContextMenuRootFolders(r),
      n = this.sessionRepository.getSessionById(e);
    g(n, "No session for context menu");
    let p = this.sessionRepository.getTabGroupForTabBySessionId(e, t.id),
      d = this.getAvailableTabGroupsToMoveInto(n, p?.id);
    return {
      sessionId: e,
      tab: t,
      groupId: p?.id ?? null,
      availableSessionsToMoveInto: s,
      availableTabGroupsToMoveInto: d,
      collectionItems: a,
      topOffset: i,
    };
  }
  getAvailableTabGroupsToMoveInto(e, t) {
    return Object.keys(e.tabGroupsById).reduce((r, i) => {
      if (i === t) return r;
      let s = this.sessionRepository.getTabGroup(e.id, i);
      return s && r.push(s), r;
    }, []);
  }
};
c();
var Nn = class {
  constructor(e) {
    this.signUpService = e;
  }
  showModal(e) {
    return this.signUpService.showModal(e);
  }
};
c();
var Ln = class {
  constructor(e) {
    this.themeService = e;
  }
  subscribeTheme(e) {
    let t = () => e(this.loadTheme()),
      r = this.themeService.onThemeChanged(t);
    return t(), r;
  }
  loadTheme() {
    return this.themeService.getTheme();
  }
};
c();
c();
var cE = {
    ["unset"]: 45,
    ["small"]: 35,
    ["medium"]: 45,
    ["large"]: 55,
    ["huge"]: 65,
  },
  pE = {
    ["0"]: "small",
    ["50"]: "medium",
    ["100"]: "large",
    ["unset"]: "unset",
    ["small"]: "small",
    ["medium"]: "medium",
    ["large"]: "large",
    ["huge"]: "huge",
  },
  fS = (o) => pE[o],
  Hi = (o) => cE[o];
var Gn = class {
  constructor(e, t, r, i, s, a, n, p, d) {
    this.walkthroughService = e;
    this.sidecarService = t;
    this.modalService = r;
    this.popupService = i;
    this.shortcutService = s;
    this.userSettingsRepository = a;
    this.splitViewService = n;
    this.browserService = p;
    this.helpExperimentalLayer = d;
  }
  subscribeState(e) {
    let t = () => e(this.loadState());
    return t(), this.walkthroughService.onUpdate(t);
  }
  switchWalkthrough(e) {
    return this.walkthroughService.switchWalkthrough(e);
  }
  confirmWalkthrough(e, { step: t, context: r }) {
    t === "sessions" && !r
      ? this.sidecarService.toggleSessions({ source: "walkthrough" }).catch(l)
      : t === "customApps" && !r
      ? this.modalService
          .showMarketplaceModal({ source: "walkthrough" })
          .catch(l)
      : t === "multiAccount" && !r
      ? this.handleMultiAccountStep(e)
      : t === "splitView"
      ? this.handleSplitViewStep(r).catch(l)
      : t === "search" && !r
      ? this.modalService
          .showGlobalSearchModal({ source: "walkthrough" })
          .catch(l)
      : t === "final"
      ? this.handleFinalStep(e).catch(l)
      : t === "tasks" && !r
      ? (this.sidecarService.toggleTasks({ source: "walkthrough" }).catch(l),
        this.walkthroughStepPassed(t).catch(l))
      : t === "collections" && !r
      ? (this.sidecarService
          .toggleCollections({ source: "walkthrough" })
          .catch(l),
        this.walkthroughStepPassed(t).catch(l))
      : t && this.walkthroughStepPassed(t).catch(l),
      this.runAfterConfirmHook(t, r).catch(l);
  }
  async confirmWalkthroughStep(e) {
    await this.walkthroughService.markAsPassedWithUpdate(e);
  }
  markGlobalSearchInLaunchpadAsCompleted(e, t) {
    return this.walkthroughService.markGlobalSearchInLaunchpadAsCompleted(e, t);
  }
  async handleFinalStep(e) {
    this.helpExperimentalLayer.getIsNtpMode()
      ? (await this.walkthroughStepPassed("final"),
        this.popupService.hidePopup(e, "walkthrough"))
      : (await this.sidecarService.toggleHelp({ source: "walkthrough" }),
        await this.walkthroughStepPassed("final"));
  }
  async runAfterConfirmHook(e, t) {
    let r = this.walkthroughService.getSteps(),
      i = r.findIndex((a) => a.key === e) + 1,
      s = r[i];
    this.helpExperimentalLayer.getIsNtpMode() &&
      t &&
      s?.key === "final" &&
      (await this.browserService.openHomeTab());
  }
  handleMultiAccountStep(e) {
    let { appId: t, index: r } =
      this.walkthroughService.findFirstMultiAccountAppPosition(e);
    if (!t) {
      this.walkthroughService.markStepAsPassed("multiAccount").catch(l);
      return;
    }
    let i = Hi(this.userSettingsRepository.getSettings().sidebarSize);
    this.popupService.showApplicationPopup(t, { x: 0, y: i * r }).catch(l);
  }
  async handleSplitViewStep(e) {
    if (e) await this.walkthroughService.markStepAsPassed("splitView");
    else {
      let t = await this.browserService.createTab({
          url: "https://www.meetsidekick.com/being-productive-at-work/",
        }),
        r = await this.browserService.createTab({
          url: "https://pushplaylabs.notion.site/d91e655fe5af46fe8054cb74bc0b7f02",
          active: !1,
        });
      t?.id && r?.id && this.splitViewService.addLocalSplitView(t.id, r.id);
    }
  }
  walkthroughStepPassed(e) {
    return this.walkthroughService.markStepAsPassed(e);
  }
  loadState() {
    let e = this.shortcutService.getShortcuts();
    return {
      steps: this.walkthroughService.getSteps(),
      currentStepNumber: this.walkthroughService.getCurrentStepNumber(),
      currentStep: this.walkthroughService.getCurrentStep(),
      isPostponed: this.walkthroughService.getIsPostponed(),
      isAvailable: this.walkthroughService.getIsAvailable(),
      activateServiceShortcutKeys: e.activateServiceRange.keys,
      manageSessionShortcutKeys: e.manageSession.keys,
      openAppContextPopupShortcutKeys: e.appContextPopup.keys,
      viewInSplitShortcutKeys: e.openInSplitView.keys,
      globalSearchShortcutKeys: e.globalSearch.keys,
      collectionOpenShortcutKeys: e.toggleCollectionsSidecar.keys,
    };
  }
};
c();
var lE = [
    "workspaces",
    "apps-per-workspace",
    "pinned-apps",
    "accounts-per-app",
    "split-view",
    "adblock",
    "sessions",
  ],
  dE = ["pre-installed-apps", "shared-apps", "users", "team-roles"],
  Hn = class {
    constructor(e, t, r, i, s, a, n, p, d) {
      this.billingRepository = e;
      this.workspaceRepository = t;
      this.invitationsRepository = r;
      this.featureFlagsRepository = i;
      this.billingApi = s;
      this.teamApi = a;
      this.gmailSignatureService = n;
      this.applicationRepository = p;
      this.sessionRepository = d;
    }
    startPlanUpgrade(e) {
      return this.billingApi.startPlanUpgrade(e);
    }
    startTrial() {
      return this.billingApi.startTrial();
    }
    startPersonalPlanUpgrade(e) {
      return this.billingApi.startPersonalPlanUpgrade(e);
    }
    startTeamPlanUpgrade(e) {
      return this.billingApi.startTeamPlanUpgrade(e);
    }
    startInvitesBonusTime() {
      return this.billingApi.startInvitesBonusTime();
    }
    loadInvitationsStats() {
      return this.billingApi.loadInvitationsStats();
    }
    openPaidAccountManagingPortal() {
      return this.billingApi.openCustomerPortal();
    }
    makeGmailSignature(e, t) {
      return this.gmailSignatureService.makeGmailSignature(e, t);
    }
    subscribeBillingDetailsPopupState(e, t) {
      let r = () => t(this.loadDetailsPopupState(e)),
        i = [
          se.onSeveral(Qb, r),
          this.featureFlagsRepository.onFeatureFlagsLoaded(r),
        ];
      return r(), F(i);
    }
    loadDetailsPopupState(e) {
      let t = this.billingRepository.getBillingPlan();
      return t
        ? {
            canManagePlan:
              t.options.isPaid || this.billingRepository.getCanManagePlan(),
            planName: this.getPlanName(t),
            planDetailsBlock: this.getPlanDetailsBlock(t, e),
            invitationsBlockState: this.getInvitationsBlockState(t),
            buyProPlanBlockState: this.getBuyProPlanBlockState(t),
            buyTeamProPlanBlockState: this.getBuyTeamProPlanBlockState(t),
            isTeamBlockEnabled: this.getIsTeamBlockEnabled(e),
          }
        : null;
    }
    getPlanName({ options: { isTeam: e, planName: t } }) {
      return { prefix: e ? "Team" : "", name: t };
    }
    getIsTeamBlockEnabled(e) {
      let t = Boolean(this.teamApi.getTeamForWorkspaceByWindowId(e)),
        r = this.teamApi.getUserInvitePermissionForTeamInWindow(e),
        i = !t || r;
      return this.featureFlagsRepository.getFeatureFlag("b2bEnabled") && i;
    }
    getPlanDetailsBlock(
      { options: { isTrial: e, isPro: t, isTeam: r }, planOptions: i },
      s
    ) {
      if (e) {
        let p = this.billingRepository.getSubscriptionTimeLeftDays() ?? 1,
          d = aa(
            p,
            P("background_launchpad__day"),
            P("background_launchpad__days"),
            !0
          );
        return { type: 2, expirationText: d, expirationValue: p };
      }
      let a = this.workspaceRepository.getWorkspaceIdForWindow(s),
        n = this.getLimits(r, i, a);
      return { type: t ? 1 : 0, limits: n };
    }
    getLimits(e, t, r) {
      return e ? this.getLimitsForTeam(t) : this.getLimitsForSingleUser(t, r);
    }
    getLimitsForTeam({ preInstalledAppsLimit: e }) {
      let t = P("background_launchpad__unlimited");
      return [
        { feature: "shared-apps", value: e ?? t, current: 0 },
        { feature: "shared-tasks", value: t, current: null },
        { feature: "shared-collections", value: t, current: null },
        { feature: "workspaces", value: t, current: null },
      ];
    }
    getLimitsForSingleUser(
      {
        pinnedAppsLimit: e,
        totalAppsLimit: t,
        workspacesLimit: r,
        accountsLimitPerApp: i,
        sessionsPerWorkspaceLimit: s,
      },
      a
    ) {
      let n = P("background_launchpad__unlimited");
      return [
        {
          feature: "pinned-apps",
          value: e ?? n,
          current:
            a && t ? this.workspaceRepository.getPinnedCountById(a) : null,
        },
        {
          feature: "apps-per-workspace",
          value: t ?? n,
          current: a && e ? this.workspaceRepository.getTotalAppsById(a) : null,
        },
        { feature: "workspaces", value: r ?? n, current: r || null },
        { feature: "accounts-per-app", value: i ?? n, current: null },
        {
          feature: "sessions",
          value: s ?? n,
          current: a
            ? this.sessionRepository.getSessionsByWorkspaceId(a).length
            : null,
        },
      ];
    }
    getBuyProPlanBlockState({
      options: { isTeam: e, isPro: t, isPaid: r, isTrialExpired: i },
    }) {
      if (t || (e && r)) return null;
      let { monthlyPlan: s, yearlyPlan: a } =
        this.billingApi.getPlansForUpgrade();
      return {
        planName: { prefix: "Sidekick", name: "Pro" },
        canBuyPlan: !0,
        canStartTrial: !i,
        isTrialExpired: i,
        features: lE,
        price: {
          baseMonthlyPrice: Number(s.monthlyPrice),
          specialMonthlyPrice: a.monthlyPrice,
        },
      };
    }
    getBuyTeamProPlanBlockState({
      options: { isTeam: e, isPro: t, isPaid: r },
    }) {
      return t || !e
        ? null
        : {
            planName: { prefix: "Team", name: "Pro" },
            canBuyPlan: r || this.billingRepository.getCanManagePlan(),
            features: dE,
          };
    }
    getInvitationsBlockState({ options: { isPaid: e } }) {
      let t = this.invitationsRepository.getInvitationsStats();
      if (!t) return null;
      let r = this.invitationsRepository.getInvitationsPlans() ?? [],
        i = e
          ? r.filter((d) => d.wasActivated || d.durationInMonths === null)
          : r,
        s = this.invitationsRepository.getForeverFreePlanRequiredActivations(),
        a = this.invitationsRepository.isForeverFreePlanActive(),
        n = this.invitationsRepository.getBestAvailablePlanForUpgrade(),
        p = i.filter((d) =>
          d.wasActivated || !n || d.durationInMonths === null
            ? !0
            : n.durationInMonths === null
            ? !1
            : d.durationInMonths >= n.durationInMonths
        );
      return {
        activations: t.statistics.activations ?? 0,
        downloads: t.statistics.downloads ?? 0,
        invitationLink: t.inviteLink ?? "",
        breakpoints: p,
        bestBreakpoint: n ?? null,
        foreverFreeInvitesCount: s,
        isGmailSectionEnabled: this.featureFlagsRepository.getFeatureFlag(
          "gmailSignatureEnabled"
        ),
        isForeverFreePlanActive: a,
      };
    }
  };
c();
c();
var _e = new A();
var Vn = class {
  constructor(
    e,
    t,
    r,
    i,
    s,
    a,
    n,
    p,
    d,
    u,
    m,
    y,
    b,
    v,
    S,
    w,
    T,
    I,
    k,
    _,
    O,
    E,
    f,
    j,
    ue,
    Q,
    C
  ) {
    this.analytics = e;
    this.userSettingsRepository = t;
    this.applicationRepository = r;
    this.adBlockerService = i;
    this.wallpaperService = s;
    this.connectionService = a;
    this.featureFlagsRepository = n;
    this.applicationApi = p;
    this.workspaceApi = d;
    this.userApi = u;
    this.savedMemoryStatistic = m;
    this.sidecarService = y;
    this.teamApi = b;
    this.teamRepository = v;
    this.browserUpdaterService = S;
    this.userRepository = w;
    this.searchService = T;
    this.accountRepository = I;
    this.workspaceRepository = k;
    this.shortcutService = _;
    this.actualUsageDaysRepository = O;
    this.billingRepository = E;
    this.billingApi = f;
    this.popupService = j;
    this.helpExperimentalLayer = ue;
    this.specialOfferService = Q;
    this.verticalTabsService = C;
  }
  totalHistoryCount = null;
  loadFeedbackInfo() {
    let { discordCommunity: e } =
      this.featureFlagsRepository.getFeatureFlag("helpLinks");
    return {
      feedbackUrl: this.userApi.generateFeedbackUrl(),
      userId: this.userApi.getUserId(),
      userInfo: this.userApi.getUserInfo(),
      discordCommunityLink: e,
    };
  }
  async activateAppAsTabById(e, t, r) {
    if (
      this.billingApi.showLimitPopupIfBlocked(
        () => this.billingApi.canOpenLaunchpadApp(t),
        "marketplace-tabs-badges"
      )
    )
      return;
    let s = this.applicationApi.getRecipeIdByAppId(e);
    g(s, "Failed to activate app as tab: no recipeId");
    let a = this.applicationRepository.getAppById(e);
    g(a, "Failed to activate app as tab: no app");
    let n = this.workspaceRepository.getWorkspaceById(a.workspaceId);
    this.analytics.sendAnalyticsEvent("app.activated-as-tab", {
      source: r,
      "app.recipe-id": s,
      "app.is-team-app": a.isTeamApp,
      "app.is-shared": a.sharedToMe,
      "team.uuid": n?.teamUuid ?? null,
    }),
      await this.applicationApi.activateApplicationsAsTab(e);
  }
  async activateAppById(e, t, r) {
    if (
      this.billingApi.showLimitPopupIfBlocked(
        () => this.billingApi.canOpenLaunchpadApp(t),
        "marketplace-tabs-badges"
      )
    )
      return;
    let s = this.applicationApi.getRecipeIdByAppId(e);
    g(s, "Failed to activate app: no recipeId");
    let a = this.applicationRepository.getAppById(e);
    g(a, "Failed to activate app: no app");
    let n = this.workspaceRepository.getWorkspaceById(a.workspaceId);
    this.analytics.sendAnalyticsEvent("app.activated", {
      source: r,
      "app.recipe-id": s,
      "app.is-team-app": a.isTeamApp,
      "app.is-shared": a.sharedToMe,
      "team.uuid": n?.teamUuid ?? null,
    }),
      await this.applicationApi.activateApplication(e, { keepReusableTab: !0 });
  }
  changeBackground(e, t) {
    return this.workspaceApi.changeBackground(e, t);
  }
  changeBackgroundEmoji(e, t) {
    return this.workspaceApi.changeBackgroundEmoji(e, t);
  }
  changeAppPositionInOrderById(e, t, r) {
    return this.workspaceApi.changeAppPositionInOrderById(e, t, r);
  }
  changeName(e, t) {
    return this.workspaceApi.changeName(e, t);
  }
  setWorkspaceMinimized(e, t) {
    return this.workspaceApi.setWorkspaceMinimized(e, t);
  }
  retryAllRequests() {
    return this.connectionService.retryAll();
  }
  hideBillingButtonAnimation() {
    return this.userApi.tryHideLaunchpadTeamsBillingAnimation();
  }
  toggleHelp(e) {
    return this.sidecarService.toggleHelp(e);
  }
  deleteWorkspace(e) {
    return this.workspaceApi.deleteWorkspaceById(e);
  }
  setShortcutsPopupClosed() {
    this.userApi.setShortcutsPopupClosed();
  }
  subscribeCurrentWallpaper(e, t) {
    let r = this.wallpaperService.onWallpaperChanged(() =>
      t(this.loadCurrentWallpaper(e))
    );
    return t(this.loadCurrentWallpaper(e)), r;
  }
  subscribeLaunchpadMainState(e) {
    let t = () => e(this.loadLaunchpadMainState()),
      r = [
        W.on("user-settings-changed", t),
        this.verticalTabsService.onBannerVisibilityChanged(t),
        this.browserUpdaterService.onUpdateStatusChanged(t),
        this.browserUpdaterService.onAvailableUpdateChanged(t),
        ...this.helpExperimentalLayer.onHelpStateChanged(t),
      ];
    return t(), F(r);
  }
  subscribeClockState(e) {
    let t = () => e(this.loadClockState()),
      r = W.onSeveral(Ce, t);
    return e(this.loadClockState()), r;
  }
  subscribeLaunchpadPopup(e, t) {
    let r = this.popupService.subscribeToLaunchpadPopup((i, s) => {
      i === e && t({ openPopup: s });
    });
    return t({ openPopup: void 0 }), r;
  }
  subscribeHeaderState(e) {
    let t = () => e(this.loadLaunchpadHeaderState()),
      r = (n) => {
        (this.totalHistoryCount = n), t();
      },
      i = ["actual-usage-days-updated", "user-loaded", "user-activated", ...Ce],
      s = ["teams-loaded", "team-created"],
      a = [
        this.adBlockerService.onStatsChanged(t),
        this.featureFlagsRepository.onFeatureFlagsLoaded(t),
        this.savedMemoryStatistic.onSavedMemoryUpdated(t),
        this.searchService.history.subscribeTotalHistoryCount(r),
        D.onSeveral(Ks, t),
        _e.onSeveral(s, t),
        W.onSeveral(i, t),
        re.onSeveral(Xo, t),
        se.on("billing-plan-loaded", t),
      ];
    return t(), F(a);
  }
  subscribeConnectionState(e) {
    let t = () => e(this.loadConnectionState()),
      r = [
        this.connectionService.onConnectionChanged(t),
        this.connectionService.onIsOnlineChanged(t),
      ];
    return e(this.loadConnectionState()), F(r);
  }
  subscribeWorkspaceList(e, t) {
    let r = () => t(this.loadWorkspaceList(e)),
      i = [...Ce, "user-loaded"],
      s = [
        "apps-changed",
        "apps-loaded",
        "apps-removed",
        "accounts-loaded",
        "accounts-changed",
      ],
      a = [
        D.onSeveral(s, r),
        W.onSeveral(i, r),
        re.onSeveral(Xo, r),
        _e.onSeveral(["teams-loaded", "team-created"], r),
        se.on("billing-plan-loaded", r),
        this.featureFlagsRepository.onFeatureFlagsLoaded(r),
      ];
    return r(), F(a);
  }
  subscribeIsIntercomAvailable(e) {
    let t = () => e(this.loadIsIntercomAvailable()),
      r = [
        this.featureFlagsRepository.onFeatureFlagsLoaded(t),
        se.on("billing-plan-loaded", t),
      ];
    return t(), F(r);
  }
  subscribeToSpecialOfferPopupState(e) {
    let t = this.specialOfferService.subscribeToOpenOfferPopup(() => e(!0)),
      r = this.specialOfferService.subscribeToCloseOfferPopup(() => e(!1));
    return e(this.specialOfferService.getShouldBeVisible()), F([t, r]);
  }
  switchFromMonthlyToYearlyPlan() {
    return this.specialOfferService.switchFromMonthlyToYearlyPlan();
  }
  hideLaunchpadVerticalTabsBanner() {
    return this.verticalTabsService.hideVerticalTabsBanner();
  }
  closeYearlyOfferPopup() {
    return this.specialOfferService.closeYearlyOfferPopup();
  }
  continueUpdating() {
    this.browserUpdaterService.continueUpdating();
  }
  changeIsHeadlessModeEnabled(e) {
    this.userApi.changeIsHeadlessModeEnabled(e);
  }
  changeWasInvitationBannerClosed() {
    this.userApi.setInvitationBannerClosed();
  }
  loadCurrentWallpaper(e) {
    let t = this.workspaceRepository.getWorkspaceIdForWindow(e),
      r = this.workspaceRepository.getDefaultWorkspaceId();
    return t !== r
      ? this.wallpaperService.getDefaultWallpaper()
      : this.wallpaperService.getCurrentWallpaper();
  }
  loadClockState() {
    return {
      use12Format: this.userSettingsRepository.getSettings().use12Format,
    };
  }
  loadLaunchpadHeaderState() {
    let e = this.userSettingsRepository.getSettings(),
      t = this.adBlockerService.getStats(),
      i = this.billingRepository.getBillingPlan()?.options,
      s = this.billingRepository.getSubscriptionTimeLeftDays(),
      { daysBeforeShowingExpireSoon: a } =
        this.featureFlagsRepository.getFeatureFlag("newBilling"),
      n = aa(
        s ?? 0,
        P("background_launchpad__day"),
        P("background_launchpad__days")
      ),
      p = s && s <= a ? `${P("background_launchpad__ends_in")} ${n}` : "",
      d =
        this.featureFlagsRepository.getFeatureFlag("b2bEnabled") &&
        !this.userSettingsRepository.getSettings()
          .isHiddenLaunchpadTeamsBillingAnimation,
      { yearlySavings: u } = this.billingApi.getYearlyPlan();
    return {
      totalHistoryCount: this.totalHistoryCount,
      useAdBlocker: e.useAdBlocker,
      blockedAdsCount: t.block_count,
      blockedRequests: t.percent,
      savedTabsMemory: this.savedMemoryStatistic.getSavedMemory(),
      isTemporaryUser: this.userRepository.getIsTemporaryUser(),
      billing: {
        isHidden: !this.userSettingsRepository.getSettings().wasActivated,
        planName: this.billingRepository.getBillingPlanName(),
        additionalText: p,
        isProPlan: i?.isPro ?? !1,
        isAnimated: d,
        yearlyPlanSavings: u,
      },
    };
  }
  loadLaunchpadMainState() {
    let {
        showPhotoBackground: e,
        isHeadlessModeEnabled: t,
        wasShortcutPopupClosed: r,
        wasInvitationBannerClosed: i,
      } = this.userSettingsRepository.getSettings(),
      s = this.browserUpdaterService.getUpdateInfo(),
      {
        openSplitMenu: a,
        toggleLastSplitPanel: n,
        switchTab: p,
        globalSearch: d,
        openInSplitView: u,
      } = this.shortcutService.getShortcuts(),
      m = this.actualUsageDaysRepository.getCount() ?? 0,
      { shortcutsPopup: y, shortcutsPopupEnabled: b } =
        this.featureFlagsRepository.getFeatureFlags(),
      v = m <= y.limitDaysForPopup && b;
    return {
      hasBackground: e,
      updateInfo: s,
      userInfo: this.userApi.getUserInfo(),
      userId: this.userApi.getUserId(),
      isExploreSidekickNtpMode: this.helpExperimentalLayer.getIsNtpMode(),
      wasInvitationBannerClosed: i,
      shouldShowVerticalTabsBanner:
        this.verticalTabsService.isVerticalTabsBannerVisible(),
      shortcutsPopupData: v
        ? {
            isHeadlessModeEnabled: t,
            openSplitMenuKeys: a.keys,
            openLastSplitPanelKeys: n.keys,
            switchTabKeys: p.keys,
            globalSearchKeys: d.keys,
            openInSplitViewKeys: u.keys,
            isShortcutsPopupClosed: r,
          }
        : null,
    };
  }
  loadConnectionState() {
    return {
      isOnline: this.connectionService.getIsOnline(),
      isReconnecting: this.connectionService.getIsReconnecting(),
      reconnectionCounter: this.connectionService.getReconnectionCounter(),
    };
  }
  mapApplicationsWithAccounts(e) {
    let t = this.applicationRepository.getAppsById(),
      r = new Set(e),
      i = [],
      s = [];
    return (
      r.forEach((a) => {
        let n = t[a];
        if (!n) return;
        let p = this.accountRepository.getAccountForAppAvatar(n),
          d = { application: n, account: p };
        if (n.isTeamApp) {
          i.push(d);
          return;
        }
        s.push(d);
      }),
      [i, s]
    );
  }
  loadWorkspaceList(e) {
    let t = this.workspaceRepository.getWorkspaceForWindow(e);
    if (!t) return null;
    let { globalMute: r } = this.userSettingsRepository.getSettings(),
      [i, s] = this.mapApplicationsWithAccounts(t.orderAppIds),
      a = this.billingRepository.getBillingPlanOption("totalAppsLimit") ?? null,
      n = this.teamApi.getMembersCountForTeamInWindow(e),
      p = this.teamApi.getUserInvitePermissionForTeamInWindow(e),
      d = this.teamApi.getTeamAdminLinks(),
      u = this.featureFlagsRepository.getFeatureFlag("b2bEnabled"),
      m = this.featureFlagsRepository.getFeatureFlag("b2b"),
      y = u && n >= m.minInvitationLimitForNewTeam,
      b = this.teamRepository.canAddNewTeamApplications(t.teamUuid);
    return {
      currentWorkspace: t,
      teamServices: i,
      teamAdminLinks: d,
      personalServices: s,
      personalServicesLimit: a,
      settings: { globalMute: r, canInvite: p },
      isB2BEnabled: u,
      canManageTeamApplications: y,
      canAddNewTeamApplications: b,
    };
  }
  loadIsIntercomAvailable() {
    if (!this.featureFlagsRepository.getFeatureFlag("intercomEnabled"))
      return !1;
    let { disableForTrialUsers: t } =
      this.featureFlagsRepository.getFeatureFlag("intercom");
    return this.billingRepository.canUseIntercom(t);
  }
};
c();
var $n = class {
  constructor(e, t, r) {
    this.pmfSurveyService = e;
    this.featureFlagsRepository = t;
    this.exploredFeaturesService = r;
  }
  submit() {
    this.pmfSurveyService.setDataAsExplored();
  }
  ignore() {
    this.pmfSurveyService.setDataAsIgnored();
  }
  subscribeVisibleState(e) {
    let t = () => e(this.pmfSurveyService.shouldBeVisible()),
      r = [
        this.featureFlagsRepository.onFeatureFlagsLoaded(t),
        W.on("actual-usage-days-updated", t),
        this.exploredFeaturesService.onExploredUpdated(t),
        this.exploredFeaturesService.onExploredLoaded(t),
        this.pmfSurveyService.onDataUpdated(t),
      ];
    return t(), F(r);
  }
  loadPopupState() {
    return {
      url: this.featureFlagsRepository.getFeatureFlags().pmfSurvey.surveyUrl,
    };
  }
};
c();
var Kn = class {
  constructor(e, t, r, i, s, a, n, p) {
    this.modalService = e;
    this.recipesRepository = t;
    this.accountRepository = r;
    this.workspaceApi = i;
    this.applicationRepository = s;
    this.applicationApi = a;
    this.workspaceRepository = n;
    this.billingRepository = p;
  }
  subscribeAddApplication(e, t) {
    return (
      t(this.loadState(e)), D.on("accounts-changed", () => t(this.loadState(e)))
    );
  }
  addApp(e, t, r) {
    return this.workspaceApi.addApp(e, t, r);
  }
  addCustomApp(e, t) {
    return this.workspaceApi.addCustomApp(e, t);
  }
  createAccount(e, t) {
    let r = this.workspaceRepository.getWorkspaceIdForWindow(e);
    r && this.applicationApi.createAccount(r, t);
  }
  deleteAccount(e, t, r) {
    let i = this.workspaceRepository.getWorkspaceIdForWindow(e);
    if (!i) return Promise.resolve();
    let s = this.recipesRepository.getRecipeByIdSafely(r);
    return this.applicationApi.deleteAccount(i, t, s);
  }
  editAccount(e, t, r) {
    let i = this.workspaceRepository.getWorkspaceIdForWindow(e);
    if (!i) return;
    let s = this.recipesRepository.getRecipeByIdSafely(r);
    this.applicationApi.updateAccount(i, t, s);
  }
  loadState(e) {
    let t = this.modalService.getModalForWindow(e);
    if (t?.id !== "add-application") return null;
    let r = this.billingRepository.getShouldUseProBadgesForUI(),
      i = this.recipesRepository.getRecipeByIdSafely(t.payload.recipeId);
    if (i.id === Pt.id) {
      let u = t.payload.name ? Ei(t.payload.name) : void 0;
      return {
        ...t.payload,
        areMultipleAccountsAllowed: this.billingRepository.canAddAccount(1),
        name: u,
        recipe: i,
        shouldCreateAccountsLocal: !0,
        useProBadges: r,
      };
    }
    let s = this.workspaceRepository.getWorkspaceIdForWindow(e);
    if (!s) return null;
    let a = this.accountRepository.getAccountsByRecipeSorted(s, i),
      n =
        this.applicationRepository.getIsApplicationAlreadyAddedByRecipeIdInWorkspace(
          i.id,
          s
        ),
      p = !a.length,
      d = this.billingRepository.canAddAccount(a.length);
    return {
      accounts: a,
      areMultipleAccountsAllowed: d,
      isAlreadyAdded: n,
      name: i.name,
      recipe: i,
      recipeId: i.id,
      shouldCreateAccountsLocal: p,
      source: t.payload.source,
      url: i.startURL,
      useProBadges: r,
      icon: { name: "icon", src: i.icons.svg ?? i.icons.png ?? "" },
    };
  }
};
c();
var qn = class {
  constructor(e, t, r, i, s, a, n) {
    this.teamApi = e;
    this.modalService = t;
    this.contactsInviterService = r;
    this.userRepository = i;
    this.workspaceRepository = s;
    this.featureFlagsRepository = a;
    this.analytics = n;
  }
  async createTeamWorkspaceAndContinueFlow(e, t) {
    await this.teamApi.createTeamWorkspace(e, t),
      await this.showInvitationModal(t, []);
  }
  async confirmTeamCreation(e, t) {
    await this.showInvitationModal(t, [], e);
  }
  async handleInviteToTeam(e, t) {
    let r = this.getInviteAction(e, t);
    try {
      return (
        await r,
        await this.modalService.showInviteTeammatesSuccessModal(
          { manageWorkspaceLink: this.teamApi.getManageLinkForWindow(t) },
          t
        )
      );
    } catch (i) {
      l(i);
      let s = this.modalService.getModalForWindow(t),
        a = Wb;
      return (
        s?.id === "contacts-picker-for-team" && (a = s.payload.type),
        await this.modalService.showInviteTeammatesFailModal(
          {
            from: a,
            initialEmails: e.emails,
            teamCreationInfo: e.teamCreationInfo,
          },
          t
        )
      );
    }
  }
  async continueFlowAfterIntro(e) {
    await this.teamApi.setIsIntroFinished(!0);
    let t = this.workspaceRepository.getWorkspaceForWindow(e);
    return !this.teamApi.getTeamForWorkspaceByWindowId(e) && t
      ? this.showTeamCreateModal({ currentWorkspace: t }, e)
      : this.showInvitationModal(e, []);
  }
  async startInvitationFlow(e, t) {
    if (
      (this.analytics.sendAnalyticsEvent("b2b.invitation-flow-started", {
        source: e.source,
      }),
      !(await this.teamApi.getIsIntroFinished()))
    ) {
      let i = await this.teamApi.getLastViewedIntroStep();
      return this.showB2bIntroModal({ source: e.source, step: i }, t);
    }
    return this.continueFlowAfterIntro(t);
  }
  async showB2bIntroModal(e, t) {
    return (
      await this.teamApi.setLastViewedIntroStep(e.step),
      this.modalService.showB2bIntroModal(e, t)
    );
  }
  async showInvitationModal(e, t = [], r = null, i = void 0) {
    let s = this.getB2bFlowState(e);
    s &&
      (await this.modalService.showInviteTeammatesModal(
        { ...s, initialEmails: t, teamCreationInfo: r, chosenOauthType: i },
        e
      ));
  }
  async showGoogleContactsPicker(e, t, r = [], i = null) {
    let s = this.getB2bFlowState(e);
    if (s)
      try {
        await this.contactsInviterService.showGoogleContactsPicker(t, {
          ...s,
          teamCreationInfo: i,
          initialEmails: r,
        });
      } catch {
        await this.showInvitationModal(e, r, i, "google");
      }
  }
  async showSlackContactsPicker(e, t = [], r = null) {
    let i = this.getB2bFlowState(e);
    if (i)
      try {
        await this.contactsInviterService.showSlackContactsPicker({
          ...i,
          teamCreationInfo: r,
          initialEmails: t,
        });
      } catch {
        await this.showInvitationModal(e, t, r, "slack");
      }
  }
  showTeamCreateModal(e, t) {
    return this.modalService.showTeamCreateModal(e, t);
  }
  getB2bFlowState(e) {
    let t = this.userRepository.getUserInfo();
    return t
      ? {
          teamId: this.teamApi.getTeamForWorkspaceByWindowId(e)?.uuid || null,
          userDomain: t.registeredDomain || "",
          isGSuite: this.userRepository.getIsUserAuthorizedWithGSuite(),
          minInvitationThreshold: this.getLowerLimitForInvitations(e),
        }
      : null;
  }
  getLowerLimitForInvitations(e) {
    let t = this.teamApi.getTeamForWorkspaceByWindowId(e),
      r =
        this.featureFlagsRepository.getFeatureFlag(
          "b2b"
        ).minInvitationLimitForNewTeam;
    return !t?.membersCount || t.membersCount < r ? r : 1;
  }
  getInviteAction(e, t) {
    let r;
    if (e.teamId) r = this.teamApi.inviteToTeam(e, t);
    else {
      let { teamCreationInfo: i, emails: s, allowApprovedDomains: a = !1 } = e;
      if (!i)
        return Promise.reject(
          new L(
            "Step with team creation was skipped, and user does not have one"
          )
        );
      r = this.teamApi.createTeamWorkspace(
        { name: i.teamName, allowApprovedDomains: a, invites: s },
        t
      );
    }
    return r;
  }
};
c();
c();
var ns = {
  ["shared-apps"]: 5,
  ["pre-installed-apps"]: 10,
  ["pinned-apps"]: 5,
  ["apps-per-workspace"]: 10,
  ["accounts-per-app"]: 1,
  ["workspaces"]: 1,
};
var zn = class {
  constructor(e, t, r, i) {
    this.billingApi = e;
    this.modalService = t;
    this.billingRepository = r;
    this.teamApi = i;
  }
  openTeamUpgradePlanTab(e) {
    let t = this.teamApi.getTeamForWorkspaceByWindowId(e);
    if (!t) {
      l(new L("No team for windowId while upgrading"));
      return;
    }
    this.billingApi.openTeamUpgradePlanTab(t.uuid).catch(l);
  }
  deleteTeamPlanSubscription(e) {
    let t = this.teamApi.getTeamForWorkspaceByWindowId(e);
    if (!t) {
      l(new L("No team for windowId while downgrading"));
      return;
    }
    this.billingApi.deleteTeamPlanSubscription(t.uuid).catch(l);
  }
  openLaunchpadWithInvitations() {
    return this.billingApi.showInvitationsPopup();
  }
  openPaidTrialPortal() {
    this.billingApi.openPaidTrialPortal().catch(l);
  }
  openNotReadyModalParentModal(e) {
    let t = "not-ready-to-upgrade-popup";
    return e === "billing-plan-expire-soon"
      ? this.billingApi.showBillingPlanExpireSoonModal(t)
      : e === "billing-plan-has-expired"
      ? this.billingApi.showBillingPlanHasExpiredModal(t)
      : this.modalService.showBillingLimitsReachedModal({ source: t });
  }
  showNotReadyModal(e) {
    let t = this.billingRepository.getBillingPlan();
    if (!t) return Promise.resolve();
    let { isPro: r } = t.options,
      i = this.billingRepository.getIsTeam(),
      s = i ? "Team" : "Sidekick",
      a = {
        limits: this.getLimits(i, r, t.planOptions),
        previousModal: e,
        isTeamVersion: i,
        planName: { prefix: s },
      };
    return this.modalService.showBillingNotReadyModal(a);
  }
  getLimits(e, t, r) {
    return e ? this.getTeamLimits(t, r) : this.getSingleUserLimits(t, r);
  }
  getTeamLimits(e, { appSharingLimit: t, preInstalledAppsLimit: r }) {
    return e
      ? this.generateDefaultsMap(["shared-apps", "pre-installed-apps"])
      : { ["shared-apps"]: t, ["pre-installed-apps"]: r };
  }
  getSingleUserLimits(e, t) {
    return e
      ? this.generateDefaultsMap([
          "pinned-apps",
          "apps-per-workspace",
          "accounts-per-app",
          "workspaces",
        ])
      : {
          ["pinned-apps"]: t.pinnedAppsLimit,
          ["apps-per-workspace"]: t.totalAppsLimit,
          ["accounts-per-app"]: t.accountsLimitPerApp,
          ["workspaces"]: t.workspacesLimit,
        };
  }
  generateDefaultsMap(e) {
    return e.reduce((t, r) => ((t[r] = ns[r] ?? null), t), {});
  }
  disableShowingPaidTrialModal() {
    return this.billingApi.disableShowingPaidTrialModal();
  }
  updatePaidTrialModalShowedDay() {
    return this.billingApi.updatePaidTrialModalShowedDay();
  }
  dismissCancelDiscountOffer() {
    return this.billingApi.dismissCancelDiscountOffer();
  }
  claimCancelDiscountOffer() {
    this.billingApi.claimCancelDiscountOffer().catch(l);
  }
};
c();
var Qn = class {
  constructor(e) {
    this.calendarIntegrationService = e;
  }
  addCalendar(e, t) {
    return this.calendarIntegrationService.addNewGoogleCalendar(e, t);
  }
  updateCalendarInfo(e, t, r) {
    this.calendarIntegrationService.updateCalendar(e, t, r);
  }
  removeCalendar(e) {
    this.calendarIntegrationService.removeCalendar(e);
  }
};
c();
c();
var we = new A();
var Yn = class {
  constructor(e, t, r, i) {
    this.modalService = e;
    this.collectionsApi = t;
    this.teamApi = r;
    this.collectionRepository = i;
  }
  subscribeCollectionShareState(e, t) {
    let r = async () => t(await this.loadCollectionShareState(e)),
      i = [
        we.on("collection-public-changed", () => {
          r().catch(l);
        }),
        we.on("recipients-updated", () => {
          r().catch(l);
        }),
        _e.on("teams-loaded", () => {
          r().catch(l);
        }),
        _e.on("team-created", () => {
          r().catch(l);
        }),
        we.on("recipients-updated", () => {
          r().catch(l);
        }),
      ];
    return r().catch(l), F(i);
  }
  async loadCollectionShareState(e) {
    let t = this.modalService.getModalForWindow(e);
    if (t?.id !== "share-collection") return null;
    let r = this.collectionRepository.getCollectionById(t.payload.uuid);
    return {
      ...t.payload,
      shareLink: r?.publicUrl,
      sharingRecipients:
        await this.collectionRepository.getRecipientsForCollection(
          t.payload.uuid
        ),
      team: this.teamApi.getTeamForWorkspaceByWindowId(e),
    };
  }
  loadSharedRecipients(e) {
    return this.collectionsApi.getSharedRecipients(e);
  }
};
c();
var Jn = class {
  constructor(e, t, r) {
    this.cpuPopupService = e;
    this.cpuMonitorService = t;
    this.popupService = r;
  }
  discardTabs() {
    this.cpuMonitorService.discardPendingTabs().catch(l);
  }
  ignoreHighLoadTabs() {
    this.cpuMonitorService.setIgnoreFlag().catch(l);
  }
  closePopup(e) {
    this.cpuPopupService.closePopup(e);
  }
  subscribeCurrentPopup(e, t) {
    let r = this.cpuPopupService.onPopupChanged(() =>
      t(this.loadCurrentPopup(e))
    );
    return t(this.loadCurrentPopup(e)), r;
  }
  loadNotificationsSettings(e) {
    let t = this.popupService.getPopupInfo(e, "cpu-monitor-notification");
    return t?.id !== "cpu-monitor-notification"
      ? null
      : {
          currentHostname: t.payload.hostname,
          discardedTabsCount: t.payload.discardedTabsCount,
        };
  }
  loadAlarmSettings(e) {
    let t = this.cpuPopupService.getPopupForWindow(e);
    return t?.id !== "cpu-monitor-alarm" ? null : { tabs: t.tabs };
  }
  loadCurrentPopup(e) {
    return this.cpuPopupService.getPopupForWindow(e)?.id ?? null;
  }
};
c();
var Zn = class {
  constructor(
    e,
    t,
    r,
    i,
    s,
    a,
    n,
    p,
    d,
    u,
    m,
    y,
    b,
    v,
    S,
    w,
    T,
    I,
    k,
    _,
    O,
    E,
    f
  ) {
    this.userSettingsRepository = e;
    this.userRepository = t;
    this.teamApi = r;
    this.themeService = i;
    this.featureFlagsRepository = s;
    this.wallpaperService = a;
    this.userApi = n;
    this.adBlockerService = p;
    this.tabsDiscarderService = d;
    this.savedMemoryStatistic = u;
    this.billingRepository = m;
    this.billingApi = y;
    this.authService = b;
    this.sidebarVisibilityManager = v;
    this.proxyService = S;
    this.calendarsIntegrationService = w;
    this.sessionApi = T;
    this.browserService = I;
    this.defaultBrowserService = k;
    this.distractionBlockerService = _;
    this.toolbarHoverIconsService = O;
    this.invitationsRepository = E;
    this.gmailSignatureService = f;
  }
  makeGmailSignature(e, t) {
    return this.gmailSignatureService.makeGmailSignature(e, t);
  }
  changeIsHiddenWelcomeToDistractionBlocker(e) {
    this.userApi.changeIsHiddenWelcomeToDistractionBlocker(e);
  }
  changeEnableDistractionBlocker(e) {
    this.userApi.changeEnableDistractionBlocker(e);
  }
  markDistractionBlockerIntroShowed() {
    this.userApi.markDistractionBlockerIntroShowed();
  }
  addAdBlockerDomain(e) {
    this.userApi.addAdBlockerDomain(e);
  }
  changeDistractionBlockerRules(e) {
    this.userApi.changeDistractionBlockerRules(e);
  }
  changeDistractionBlockerSchedule(e) {
    this.userApi.changeDistractionBlockerSchedule(e);
  }
  removeAdBlockerDomain(e) {
    this.userApi.removeAdBlockerDomain(e);
  }
  makeSidekickDefaultBrowser() {
    return this.defaultBrowserService.makeBrowserDefault();
  }
  addCpuMonitorDomain(e) {
    this.userApi.addCpuMonitorDomain(e);
  }
  removeCpuMonitorDomain(e) {
    this.userApi.removeCpuMonitorDomain(e);
  }
  changeEnableCpuMonitorNotification(e) {
    this.userApi.changeEnableCpuMonitorNotification(e);
  }
  changeEnableCpuMonitorAutoDiscard(e) {
    this.userApi.changeEnableCpuMonitorAutoDiscard(e);
  }
  addNonDiscardableDomain(e) {
    this.userApi.addNonDiscardableDomain(e);
  }
  removeNonDiscardableDomain(e) {
    this.userApi.removeNonDiscardableDomain(e);
  }
  changeMinutesBeforeDiscard(e) {
    this.userApi.changeMinutesBeforeDiscard(e);
  }
  changePreferredWallpaperId(e) {
    this.userApi.changePreferredWallpaperSettings(e, !1),
      this.wallpaperService.updateCurrentWallpaper().catch(l);
  }
  changeSidebarSize(e) {
    this.userApi.changeSidebarSize(e);
  }
  changeTheme(e) {
    return this.themeService.updateTheme(e);
  }
  changeUseAdBlocker(e) {
    this.userApi.changeUseAdBlocker(e);
  }
  enableWallpapersRotate() {
    this.wallpaperService.rotateWallpaper(!0).catch(l);
  }
  changeInteractiveServiceGrayscale(e) {
    this.userApi.changeInteractiveServiceGrayscale(e);
  }
  showPhotoBackground(e) {
    this.userApi.showPhotoBackground(e);
  }
  changeShowSidebar(e, t) {
    this.sidebarVisibilityManager.updateVisibilityState(e, t);
  }
  changeDisableDiscarding(e) {
    this.userApi.changeDisableDiscarding(e);
  }
  changeUse12Format(e) {
    this.userApi.changeUse12Format(e);
  }
  changeRandomUserAgent(e) {
    this.userApi.changeRandomUserAgent(e);
  }
  changeIsHeadlessModeEnabled(e) {
    this.userApi.changeIsHeadlessModeEnabled(e);
  }
  changeIsHideToolbarIconsOnHoverEnabled(e) {
    return this.toolbarHoverIconsService.handleHoverEnabledChanges(e);
  }
  changeCtrlTabOrder(e) {
    this.userApi.changeCtrlTabOrder(e);
  }
  confirmLocalLawsForVPN() {
    this.userApi.confirmLocalLawsForVPN();
  }
  toggleSelectedSites(e) {
    this.userApi.toggleSelectedSites(e);
  }
  toggleUseProxy(e) {
    this.userApi.toggleUseProxy(e);
  }
  toggleCalendarsIntegration(e) {
    this.userApi.toggleCalendarsIntegration(e);
  }
  updateInviterCode(e) {
    return this.userApi.updateInviterCode(e);
  }
  loadDefaultBrowserQuery() {
    return this.browserService.isDefaultBrowser();
  }
  startPlanUpgrade(e) {
    return this.billingApi.startPlanUpgrade(e);
  }
  signOut(e) {
    return (
      this.sessionApi.saveSessionBeforeSignOut(e), this.authService.signOut()
    );
  }
  async signOutWithClearData() {
    return this.authService.signOut(!0);
  }
  loadInvitationsStats() {
    return this.billingApi.loadInvitationsStats();
  }
  openCustomerPortal() {
    return this.billingApi.openCustomerPortal();
  }
  subscribeGlobalSettings(e) {
    let t = () => e(this.loadGlobalSettings()),
      r = this.featureFlagsRepository.onFeatureFlagsLoaded(t);
    return t(), r;
  }
  subscribeAccountTab(e, t) {
    let r = () => {
        this.loadAccountTab(e).then(t).catch(l);
      },
      i = [
        W.onSeveral(Ce, r),
        se.onSeveral(["invitations-stats-loaded", "billing-plan-loaded"], r),
      ];
    return r(), F(i);
  }
  subscribeAdBlockerTab(e) {
    let t = () => e(this.loadAdBlockerTab()),
      r = [
        this.adBlockerService.onStatsChanged(t),
        W.onSeveral(Ce, t),
        this.featureFlagsRepository.onFeatureFlagsLoaded(t),
      ];
    return t(), F(r);
  }
  subscribeDistractionBlockerTab(e) {
    let t = () => e(this.loadDistractionBlockerTab()),
      r = [
        this.featureFlagsRepository.onFeatureFlagsLoaded(t),
        W.onSeveral(Ce, t),
      ];
    return t(), F(r);
  }
  subscribeCpuMonitorTab(e) {
    let t = () => e(this.loadCpuMonitorTab()),
      r = [
        this.featureFlagsRepository.onFeatureFlagsLoaded(t),
        W.onSeveral(Ce, t),
      ];
    return t(), F(r);
  }
  subscribeAppearanceTab(e, t) {
    let r = () => t(this.loadAppearanceTab(e)),
      i = [
        this.themeService.onThemeChanged(r),
        this.wallpaperService.onThumbnailsLoaded(r),
        W.onSeveral(Ce, r),
        this.sidebarVisibilityManager.onVisibilityChanged(r),
      ];
    return r(), F(i);
  }
  subscribePrivacyTab(e) {
    let t = () => e(this.loadPrivacyTab()),
      r = [
        this.featureFlagsRepository.onFeatureFlagsLoaded(t),
        W.onSeveral(Ce, t),
      ];
    return e(this.loadPrivacyTab()), F(r);
  }
  subscribeOtherTab(e) {
    let t = () => {
        e(this.loadOtherTab());
      },
      r = [W.onSeveral(Ce, t)];
    return t(), F(r);
  }
  subscribeSuspenderTab(e) {
    let t = () => e(this.loadSuspenderTab()),
      r = [
        this.savedMemoryStatistic.onSavedMemoryUpdated(t),
        W.onSeveral(Ce, t),
      ];
    return t(), F(r);
  }
  subscribeIntegrationsTab(e) {
    let t = () => e(this.loadIntegrationsTab()),
      r = [
        W.onSeveral(Ce, t),
        this.calendarsIntegrationService.onCalendarsChanged(t),
      ];
    return t(), F(r);
  }
  async getProfileStatistics() {
    return this.browserService.getProfileStatistics();
  }
  loadGlobalSettings() {
    let e = this.featureFlagsRepository.getFeatureFlags();
    return {
      cpuMonitorEnabled: Boolean(e.cpuMonitorEnabled),
      isDistractionBlockerEnabled: Boolean(e.isDistractionBlockerEnabled),
      calendarIntegrationsEnabled: Boolean(e.calendarsIntegrationEnabled),
    };
  }
  async loadAccountTab(e) {
    let t = this.userRepository.getUserInfo(),
      r = this.teamApi.getTeamForWorkspaceByWindowId(e),
      i = this.invitationsRepository.getInvitationsStats(),
      s = this.billingRepository.getBillingPlan(),
      n = (i?.inviteLink ?? "").split("/").at(-1),
      p = Boolean(t?.hasStripeCustomerId),
      d = await this.getProfileStatistics(),
      m = (this.invitationsRepository.getInvitationsPlans() ?? []).filter(
        (v) => v.wasActivated
      ),
      y = this.billingRepository.getIsGift(),
      b = !t?.hasTemporaryEmail;
    return {
      userName: t?.name ?? null,
      userEmail: t?.email ?? null,
      userAvatar: t?.avatar ?? null,
      teamName: r?.name,
      accountType: !r || r.isJustMe ? "Personal" : "Team",
      billingPlanName: this.billingRepository.getPlanName(),
      activations: i?.statistics.activations ?? 0,
      downloads: i?.statistics.downloads ?? 0,
      requiredActivations: i?.requiredActivations ?? 0,
      cancelLink: s?.planOptions.cancelLink,
      isTemporaryUser: this.userRepository.getIsTemporaryUser(),
      inviterCode: t?.inviterCode ?? null,
      userReferralCode: n,
      showCustomerPortalButton: p,
      hasActiveInvitesBonus: y,
      profileStatistics: d,
      obtainedBonusesByInvites: m,
      canInviteUsers: b,
    };
  }
  loadAdBlockerTab() {
    let e = this.userSettingsRepository.getSettings(),
      t = this.adBlockerService.getStats(),
      r = this.billingRepository.canUseAdblock(),
      i = this.billingRepository.getShouldUseProBadgesForUI(),
      { whySidekickFast: s } =
        this.featureFlagsRepository.getFeatureFlag("helpLinks");
    return {
      useAdBlocker: e.useAdBlocker,
      blockedAdsCount: t.block_count,
      adBlockerWhiteList: e.adBlockerWhiteList,
      canUseAdblockerByPlan: r,
      whySidekickFast: s,
      useProBadges: i,
    };
  }
  loadDistractionBlockerTab() {
    let e = this.userSettingsRepository.getSettings();
    return {
      isHiddenWelcome: e.isHiddenWelcomeToDistractionBlocker,
      enabled: e.isDistractionBlockerEnabled,
      rules:
        e.distractionBlockerRules ??
        this.distractionBlockerService.getDefaultRules(),
      schedule:
        e.distractionBlockerSchedule ??
        this.distractionBlockerService.getDefaultSchedule(),
    };
  }
  loadAppearanceTab(e) {
    let t = this.userSettingsRepository.getSettings(),
      r = this.themeService.getTheme(),
      i = this.wallpaperService.getGradients(),
      s = this.wallpaperService.getThumbnails(),
      a = this.wallpaperService.getPreferredWallpaperId(),
      n = this.sidebarVisibilityManager.getVisibilityState(e);
    return {
      theme: r,
      sidebarSize: t.sidebarSize,
      showSidebar: n,
      inactiveServiceGrayscale: t.inactiveServiceGrayscale,
      use12Format: t.use12Format,
      showPhotoBackground: t.showPhotoBackground,
      gradients: i,
      wallpapers: s,
      preferredWallpaperId: t.preferredWallpaperId ?? a,
      rotateWallpapersEnabled: t.rotateWallpapersEnabled,
      isHeadlessModeEnabled: t.isHeadlessModeEnabled,
      isToolbarIconsHideOnHoverEnabled:
        this.toolbarHoverIconsService.getIsHoverEnabled(),
    };
  }
  loadPrivacyTab() {
    let e = this.userSettingsRepository.getSettings(),
      t = Boolean(
        this.featureFlagsRepository.getFeatureFlags().randomUserAgent
          .disabledDomains
      ),
      { proxyEnabled: r } = this.featureFlagsRepository.getFeatureFlags();
    return {
      useRandomUserAgent: e.randomUserAgent,
      canUseRandomUserAgent: t,
      canUseProxy: r,
      isConfirmedLocalLawsForVPN: e.isConfirmedLocalLawsForVPN,
      proxySites: this.proxyService.getProxySites(),
      useProxy: e.useProxy,
    };
  }
  loadOtherTab() {
    return {
      ctrlTabOrder: this.userSettingsRepository.getSettings().ctrlTabOrder,
    };
  }
  loadSuspenderTab() {
    let e = this.userSettingsRepository.getSettings(),
      t = this.tabsDiscarderService.getStats();
    return {
      useTabsDiscarding: !e.disableDiscarding,
      minutesBeforeDiscard: e.minutesBeforeDiscard,
      noneDiscardableDomains: e.noneDiscardableDomains,
      savedTabsMemory: this.savedMemoryStatistic.getSavedMemory(),
      discardedTabsCount: t.discardedTabsCount,
    };
  }
  loadCpuMonitorTab() {
    let e = this.userSettingsRepository.getSettings(),
      t = this.featureFlagsRepository.getFeatureFlags().cpuMonitor;
    return {
      enableAutoDiscard: e.cpuAutoDiscardEnabledByUser,
      enableHighCpuNotifications: e.cpuMonitorNotificationsEnabledByUser,
      cpuMonitorWhitelistDomains: e.cpuAutoDiscardUserWhitelist,
      configEnableHighCpuNotifications: t.enableNotifications ?? !1,
      configEnableAutoDiscard: t.enableAutoDiscard ?? !1,
    };
  }
  loadIntegrationsTab() {
    let e = this.userSettingsRepository.getSettings(),
      t = this.calendarsIntegrationService.getUserCalendars();
    return {
      enableCalendarsIntegration: e.enableCalendarsIntegration,
      calendars: t,
      isGmailSectionEnabled: this.featureFlagsRepository.getFeatureFlag(
        "gmailSignatureEnabled"
      ),
    };
  }
};
c();
c();
c();
c();
var $i = ((r) => (
  (r.INFO = "info"), (r.WARN = "warn"), (r.ERROR = "error"), r
))($i || {});
var ec = class {
  constructor(e, t, r) {
    this.serviceName = e;
    this.enabled = t;
    this.settingsRepository = r;
  }
  info(...e) {
    this.isLogEnabled("info") &&
      console.info(this.generatePrefix("info"), ...e);
  }
  warn(...e) {
    this.isLogEnabled("warn") &&
      console.warn(this.generatePrefix("warn"), ...e);
  }
  error(...e) {
    this.isLogEnabled("error") &&
      console.error(this.generatePrefix("error"), ...e);
  }
  generatePrefix(e) {
    return `[${e.toUpperCase()}] ${this.serviceName.toUpperCase()}:`;
  }
  isLogEnabled(e) {
    return this.checkLogPermission(e) && this.enabled;
  }
  checkLogPermission(e) {
    return (
      this.settingsRepository.getSettings()?.enabledLogLevels.includes(e) || !1
    );
  }
};
c();
var bh = me.ENABLE_LOG?.toLowerCase() === "true" ? ["error"] : [],
  tc = class {
    settings = { enabledLogLevels: bh };
    constructor() {
      this.loadSettingsFromStorage((e) => {
        this.settings = e || { enabledLogLevels: bh };
      });
    }
    getSettings() {
      return this.settings;
    }
    addLogLevel(e) {
      if (this.settings.enabledLogLevels.includes(e)) {
        console.warn("This level is already enabled.");
        return;
      }
      this.changeSettings([...this.settings.enabledLogLevels, e]);
    }
    setLogLevels(...e) {
      if (!this.isLogLevel(...e)) {
        console.warn(
          `No such level. Use one of: "${Object.values($i).join(", ")}".`
        );
        return;
      }
      this.changeSettings(e);
    }
    removeLogLevel(e) {
      if (!this.settings.enabledLogLevels.includes(e)) {
        console.warn("This level is already disabled.");
        return;
      }
      this.changeSettings(
        this.settings.enabledLogLevels.filter((t) => t !== e)
      );
    }
    resetLogLevels() {
      this.changeSettings(bh);
    }
    isLogLevel(...e) {
      return e.every((t) => Object.values($i).includes(t));
    }
    loadSettingsFromStorage(e) {
      na("log-level-setting", e);
    }
    changeSettings(e) {
      (this.settings = { ...this.settings, enabledLogLevels: e }),
        Bi("log-level-setting", this.settings);
    }
  };
var hE = me.ENABLE_LOG?.toLowerCase() === "true",
  x = class {
    static createInstance(e, t = hE) {
      let r = this.instances?.[e];
      if (r) return r;
      let i = new ec(e, t, this.settingsRepository);
      return (
        (this.instances[e] = i),
        this.isLoaded ||
          console.warn(
            `Logger for "${e}" was created before loading instances from storage`
          ),
        i
      );
    }
    static getAvailableInstances() {
      return Object.values(this.instances).reduce(
        (e, t) => ((e[t.serviceName] = t.enabled), e),
        {}
      );
    }
    static enableInstance(e) {
      this.changeEnable(e, !0);
    }
    static disableInstance(e) {
      this.changeEnable(e, !1);
    }
    static changeEnable(e, t) {
      let r = this.instances[e];
      r && ((r.enabled = t), this.saveInstancesToStorage());
    }
    static saveInstancesToStorage() {
      Bi("logger-instances-settings", this.instances);
    }
    static async loadInstancesFromStorage() {
      if (!this.isLoaded)
        try {
          let e = await this.getInstancesFromStorage();
          if (!e) return;
          (this.isLoaded = !0),
            Object.entries(e).forEach(([t, r]) => {
              let i = this.instances[t] ?? this.createInstance(t);
              i.enabled = r.enabled;
            });
        } catch (e) {
          console.error(e);
        } finally {
          this.isLoaded = !0;
        }
    }
    static getInstancesFromStorage() {
      return new Promise((e) => {
        na("logger-instances-settings", e);
      });
    }
  };
lr(x, "settingsRepository", new tc()),
  lr(x, "instances", {}),
  lr(x, "isLoaded", !1);
var rc = class {
  loggerSettings;
  constructor() {
    this.loggerSettings = x.settingsRepository;
  }
  setLogLevels(...e) {
    return (
      this.loggerSettings.setLogLevels(...e), this.loggerSettings.getSettings()
    );
  }
  enableInfoLog() {
    return (
      this.loggerSettings.addLogLevel("info"), this.loggerSettings.getSettings()
    );
  }
  logOnlyInfo() {
    return (
      this.loggerSettings.setLogLevels("info"),
      this.loggerSettings.getSettings()
    );
  }
  disableInfoLog() {
    return (
      this.loggerSettings.removeLogLevel("info"),
      this.loggerSettings.getSettings()
    );
  }
  enableWarnLog() {
    return (
      this.loggerSettings.addLogLevel("warn"), this.loggerSettings.getSettings()
    );
  }
  logOnlyWarn() {
    return (
      this.loggerSettings.setLogLevels("warn"),
      this.loggerSettings.getSettings()
    );
  }
  disableWarnLog() {
    return (
      this.loggerSettings.removeLogLevel("warn"),
      this.loggerSettings.getSettings()
    );
  }
  enableErrorLog() {
    return (
      this.loggerSettings.addLogLevel("error"),
      this.loggerSettings.getSettings()
    );
  }
  logOnlyError() {
    return (
      this.loggerSettings.setLogLevels("error"),
      this.loggerSettings.getSettings()
    );
  }
  disableErrorLog() {
    return (
      this.loggerSettings.removeLogLevel("error"),
      this.loggerSettings.getSettings()
    );
  }
  resetLogLevels() {
    return (
      this.loggerSettings.resetLogLevels(), this.loggerSettings.getSettings()
    );
  }
  getSettings() {
    return this.loggerSettings.getSettings();
  }
  getAvailableServices() {
    return x.getAvailableInstances();
  }
  enableServices(...e) {
    return (
      e.forEach((t) => {
        x.enableInstance(t);
      }),
      this.getAvailableServices()
    );
  }
  enableAllServices() {
    Object.keys(this.getAvailableServices()).forEach((e) => {
      x.enableInstance(e);
    });
  }
  disableServices(...e) {
    return (
      e.forEach((t) => {
        x.disableInstance(t);
      }),
      this.getAvailableServices()
    );
  }
  disableAllServices() {
    Object.keys(this.getAvailableServices()).forEach((e) => {
      x.disableInstance(e);
    });
  }
};
c();
var ic = class {
  constructor(e, t, r, i, s) {
    this.modalService = e;
    this.recipesRepository = t;
    this.browserService = r;
    this.browserEventsService = i;
    this.endpoint = s;
  }
  subscribeTabsLoading(e) {
    let t = () => {
        this.getTabs()
          .then((i) => e(this.tabsFilter(i)))
          .catch(l);
      },
      r = [this.browserEventsService.subscribeToTabUpdated(t)];
    return t(), F(r);
  }
  loadMarketplaceData(e) {
    if (!this.modalService.getModalForWindow(e)) return null;
    let r = this.recipesRepository.getRecipes(),
      i = this.recipesRepository.getPopularRecipes();
    return {
      allRecipes: r.map((s) => this.recipeViewModelMapper(s)),
      popularRecipes: i.map((s) => this.recipeViewModelMapper(s)),
      endpoint: this.endpoint,
    };
  }
  openBillingLimitsModal() {
    return this.modalService.showBillingLimitsReachedModal({
      source: "marketplace-tabs-badges",
    });
  }
  recipeViewModelMapper(e) {
    return {
      id: e.id,
      name: e.name,
      firstIconToShow: e?.icons.svg || e?.icons.png,
    };
  }
  async getTabs() {
    return this.browserService.getTabsForMarketplace();
  }
  tabsFilter(e) {
    return e.filter((t) => !t.hidden);
  }
};
c();
var oc = class {
  constructor(e, t, r, i, s, a, n, p) {
    this.appSharingService = e;
    this.appSharingRecipients = t;
    this.appSharingCredentials = r;
    this.featureFlagsRepository = i;
    this.videosService = s;
    this.modalService = a;
    this.applicationRepository = n;
    this.workspaceRepository = p;
  }
  changeSelectedApp(e, t) {
    return this.appSharingService.updateSelectedApp(e, t);
  }
  shareApp(e) {
    this.appSharingService.shareApp(e).catch(l);
  }
  removeRecipient(e) {
    this.appSharingRecipients.removeRecipient(e).catch(l);
  }
  clearSelectedApp(e) {
    this.appSharingService.clearSelectedApp(e);
  }
  updateAppCredentials(e) {
    this.appSharingCredentials.updateCredentials({
      id: e.id,
      username: e.username,
      password: e.password || "",
      note: e.note,
      updateSilently: !1,
    });
  }
  subscribeShareDataState(e, t) {
    let r = () => t(this.loadShareDataState(e)),
      i = [
        this.appSharingService.onPopupDataUpdate(r),
        this.appSharingRecipients.onRecipientsUpdate(r),
        this.appSharingRecipients.onRecipientsLoaded(r),
        this.appSharingCredentials.onCredentialsLoaded(r),
        this.appSharingCredentials.onCredentialsUpdated(r),
        this.videosService.onVideosUpdate(r),
        D.onSeveral(Ks, r),
      ];
    return r(), F(i);
  }
  subscribeCanBeShared(e) {
    let t = () => e(this.loadCanBeShared()),
      r = this.featureFlagsRepository.onFeatureFlagsLoaded(t);
    return t(), r;
  }
  loadShareDataState(e) {
    let t = this.modalService.getModalForWindow(e),
      r =
        this.appSharingService.getSelectedAppForWindow(e) ??
        (t?.id === "share-application" ? t.payload.appId : void 0),
      i = this.applicationRepository.getAllApps(),
      s = this.videosService.getVideos(),
      a = r ? this.applicationRepository.getAppById(r) : void 0,
      n = a ? this.prepareAppSharingApp(a) : null,
      p = this.workspaceRepository.getWorkspaceIdForWindow(e),
      d = i.reduce(
        (m, y) => (
          !y.sharedToMe &&
            y.workspaceId === p &&
            m.push(this.prepareAppSharingApp(y)),
          m
        ),
        []
      ),
      u = this.appSharingRecipients
        .getRecipients()
        .filter((m) => a && m.service_id === a.id);
    return {
      apps: d,
      recipients: u,
      howToWorksVideo: s?.p2pSharing.videoUrl ?? null,
      selectedApp: n,
    };
  }
  prepareAppSharingApp(e) {
    let t = this.appSharingCredentials.getCredentials();
    return {
      id: e.id,
      appName: e.name,
      appIcon: e.iconUrl || "",
      username: t?.[e.id]?.username || "",
      note: t?.[e.id]?.note || "",
      isShared: e.sharedByMe,
      hasPassword: Boolean(t?.[e.id]?.password) || !1,
      password: t?.[e.id]?.password || "",
    };
  }
  loadCanBeShared() {
    return {
      hasSharingAppsFeature: Boolean(
        this.featureFlagsRepository.getFeatureFlags().sharingApps
      ),
    };
  }
};
c();
c();
var Qt = (o, e) => (o >= 0 ? (e + o) % e : Qt(e - Qt(Math.abs(o), e), e));
var sc = class {
  constructor(e, t) {
    this.tabSwitcherService = e;
    this.shortcutService = t;
  }
  incrementIndex() {
    return this.tabSwitcherService.incrementCurrentIndex();
  }
  decrementIndex() {
    return this.tabSwitcherService.decrementCurrentIndex();
  }
  activateTab(e, t) {
    return this.tabSwitcherService.activateSelectedTab(e, t);
  }
  closeTab(e, t) {
    return this.tabSwitcherService.closeSelectedTab(e, t);
  }
  subscribeTabSwitcherModalState(e, t) {
    let r = () => {
        this.loadTabSwitcherModalState(e).then(t).catch(l);
      },
      i = [
        this.tabSwitcherService.onIndexChanged(r),
        this.tabSwitcherService.onTabsChanged(r),
        this.shortcutService.onShortcutsUpdated(r),
      ];
    return r(), F(i);
  }
  async loadTabSwitcherModalState(e) {
    let t = await this.tabSwitcherService.getOpenedTabs(e),
      {
        browserCopy: r,
        closeOpenedTab: i,
        globalSearch: s,
      } = this.shortcutService.getShortcuts(),
      a = Qt(this.tabSwitcherService.getIndex(), t.length);
    return {
      openedTabs: t,
      globalSearchShortcutKeys: s.keys,
      copyShortcutKeys: r.keys,
      closeOpenedTabShortcutKeys: i.keys,
      activeIndex: a,
    };
  }
};
c();
var ac = class {
  constructor(e, t) {
    this.tabsDiscarderService = e;
    this.browserService = t;
  }
  async getReasons() {
    let t = (await this.browserService.getAllTabs()).reduce((r, i) => {
      if (!i.id) return r;
      let s = this.tabsDiscarderService.getDiscardedTabsInfo()[i.id];
      return (
        (r[i.id] = {
          discarded: i.discarded,
          reason: s?.lastReason || "No reason yet",
          url: i.url,
          discardedMemoryMb: (s?.memoryBeforeDiscard ?? 0) / 1024 / 1024,
        }),
        r
      );
    }, {});
    console.table(t);
  }
  setCustomTimeouts(e, t) {
    this.tabsDiscarderService.setCustomTimeouts(e, t);
  }
  resetCustomTimeouts() {
    this.tabsDiscarderService.setCustomTimeouts(null, null);
  }
};
c();
var nc = class {
  constructor(e) {
    this.billingApi = e;
  }
  openUpgradePlanTab(e) {
    return this.billingApi.openUpgradePlanTab(e);
  }
  loadUpgradePlanModalState() {
    return this.billingApi.getPlansForUpgrade();
  }
};
c();
var cc = class {
  constructor(e, t, r) {
    this.modalService = e;
    this.workspaceRepository = t;
    this.workspaceApi = r;
  }
  async editWorkspaceData(e, { name: t, avatar: r }) {
    if ((await this.workspaceApi.changeNameForWorkspace(e, t), !!r?.value)) {
      if (r.type === "Emoji") {
        await this.workspaceApi.changeBackgroundEmojiForWorkspace(e, r.value);
        return;
      }
      r.type === "Color" &&
        (await this.workspaceApi.changeBackgroundForWorkspace(e, r.value));
    }
  }
  subscribeEditWorkspace(e, t) {
    let r = () => t(this.loadState(e));
    t(this.loadState(e));
    let i = [
      re.on("workspaces-changed", r),
      this.modalService.subscribeToModalChanged(r),
    ];
    return F(i);
  }
  loadState(e) {
    let t = this.modalService.getModalForWindow(e);
    if (t?.id !== "workspace-editing") return null;
    let r = this.workspaceRepository.getWorkspaceById(t.payload.workspaceId);
    return r ? { workspace: r } : null;
  }
};
c();
var pc = class {
  constructor(e, t, r, i, s, a, n, p) {
    this.workspaceRepository = e;
    this.workspaceApi = t;
    this.sessionRepository = r;
    this.applicationRepository = i;
    this.accountRepository = s;
    this.billingRepository = a;
    this.teamRepository = n;
    this.teamApi = p;
  }
  openWorkspace(e) {
    return this.workspaceApi.openWorkspace(e);
  }
  closeWorkspace(e) {
    return this.workspaceApi.closeWorkspace(e);
  }
  deleteWorkspace(e) {
    return this.workspaceApi.deleteWorkspaceById(e);
  }
  createWorkspace(e, t) {
    return this.workspaceApi.createWorkspace(e, t);
  }
  changeBackgroundEmojiForWorkspace(e, t) {
    return this.workspaceApi.changeBackgroundEmojiForWorkspace(e, t);
  }
  changeBackgroundForWorkspace(e, t) {
    return this.workspaceApi.changeBackgroundForWorkspace(e, t);
  }
  subscribeWorkspaceManagmentState(e) {
    let t = () => e(this.loadState()),
      r = [re.onSeveral(Xo, t), se.on("billing-plan-loaded", t)];
    return t(), F(r);
  }
  loadWorkspaceStatisticsState(e) {
    let t = this.sessionRepository.getSessionsByWorkspaceId(e),
      r = this.applicationRepository.getAppsByWorkspaceId(e),
      i = r.reduce((s, a) => {
        let n = this.accountRepository.getAccountsByApp(a);
        return s + n.length;
      }, 0);
    return {
      sessionsCount: t.length,
      applicationsAccountCount: i,
      applicationsCount: r.length,
    };
  }
  loadState() {
    let e = this.workspaceRepository.getWorkspacesArray().map((s) => {
        let a = this.workspaceRepository.getIsWorkspaceActive(s.id),
          n = this.teamRepository.getIsOwner(s.teamUuid) || s.isRemovable,
          d =
            this.teamRepository.canAddNewTeamApplications(s.teamUuid) &&
            s.isTeamWorkspace
              ? this.teamApi.getManageLinkForTeam(s.teamUuid)
              : null;
        return {
          ...s,
          shouldShowRemoveBtn: n,
          manageButtonLink: d,
          isActive: a,
        };
      }),
      t = this.billingRepository.getBillingPlan(),
      r = t?.planOptions.workspacesLimit,
      i = t?.options.isTrial;
    return { workspaces: e, billingWorkspacesLimit: r, showProBadge: i };
  }
};
c();
var lc = class {
  constructor(e, t, r) {
    this.uiHintsManager = e;
    this.hintsApi = t;
    this.featureFlagsRepository = r;
  }
  closeHintManually(e) {
    this.hintsApi.closeAndMarkHintAsShowed(e);
  }
  closeHintAutomatically(e, t) {
    this.uiHintsManager.hideHint(e, t);
  }
  subscribeHintsState(e, t) {
    let r = () => t(this.loadState(e)),
      i = this.uiHintsManager.onHintsChanged(r);
    return r(), i;
  }
  loadState(e) {
    let t = this.uiHintsManager.getHintsForWindow(e);
    if (!t) return { closeDelayInSeconds: 0, hints: [] };
    let r = this.hintsApi.getShortcutByHintMap(),
      i = new Array();
    t.forEach((a) => {
      i.push({ hintId: a, shortcut: r[a] });
    });
    let { autoCloseHintDelaySeconds: s } =
      this.featureFlagsRepository.getFeatureFlag("hintsV2");
    return { hints: i, closeDelayInSeconds: s };
  }
};
c();
var dc = class {
  constructor(e, t, r, i, s, a, n) {
    this.notificationManager = e;
    this.calendarIntegrationService = t;
    this.modalService = r;
    this.defaultBrowserService = i;
    this.taskTrackerService = s;
    this.billingApi = a;
    this.gmailSignatureService = n;
  }
  makeGmailSignature(e, t) {
    return this.gmailSignatureService.makeGmailSignature(e, t);
  }
  async activateCalendarsFeature(e, t) {
    return (
      this.hideNotification(e),
      await this.calendarIntegrationService.markCalendarsSetupAsShown(),
      this.modalService.showIntegrationsSettingsPopup({ source: t })
    );
  }
  makeBrowserDefault(e) {
    this.hideNotification(e), this.defaultBrowserService.makeBrowserDefault();
  }
  showTrialExpireSoonModal() {
    return this.billingApi.showBillingPlanExpireSoonModal(
      "trial-end-notification"
    );
  }
  skipCalendarsFeature(e) {
    return (
      this.hideNotification(e),
      this.notificationManager.showCalendarsSetupSkippedNotification(),
      this.calendarIntegrationService.markCalendarsSetupAsShown()
    );
  }
  skipDefaultBrowserNotifications(e) {
    this.hideNotification(e),
      this.notificationManager.showDefaultBrowserSkippedNotification();
  }
  hideNotification(e) {
    this.notificationManager.hideNotification(e);
  }
  startInvitesBonusTime() {
    return this.billingApi.startInvitesBonusTime();
  }
  toggleSiteTaskPause() {
    this.taskTrackerService.handleToggleTaskPause();
  }
  markTaskAsDoneAndCloseTimer(e) {
    this.taskTrackerService.handleDoneTask(), this.hideNotification(e);
  }
  subscribeNotifications(e) {
    let t = () => e(this.loadNotifications()),
      r = this.notificationManager.onNotificationsChanged(t);
    return t(), r;
  }
  subscribeTaskTrackerInfo(e) {
    let t = () => e(this.loadTaskTrackerInfo()),
      r = this.taskTrackerService.subscribeTaskInfoUpdate(t);
    return t(), r;
  }
  loadNotifications() {
    return { notifications: this.notificationManager.getAllNotifications() };
  }
  loadTaskTrackerInfo() {
    return this.taskTrackerService.getTaskInfo();
  }
};
c();
var uc = class {
  constructor(e, t, r, i, s, a) {
    this.notificationsSettingsApi = e;
    this.notificationsSettingsRepository = t;
    this.modalApi = r;
    this.featureFlagsRepository = i;
    this.shortcutService = s;
    this.userSettingsRepository = a;
  }
  muteForHour() {
    return this.notificationsSettingsApi.muteForHour();
  }
  muteUntilEvening() {
    return this.notificationsSettingsApi.muteUntilEvening();
  }
  muteUntilNight() {
    return this.notificationsSettingsApi.muteUntilNight();
  }
  muteUntilThisMorning() {
    return this.notificationsSettingsApi.muteUntilThisMorning();
  }
  muteUntilTomorrowMorning() {
    return this.notificationsSettingsApi.muteUntilTomorrowMorning();
  }
  openDistractionBlockerSettings() {
    return this.modalApi.showGlobalSettingsModal({
      source: "notifications-settings.distraction-blocker-clicked",
      tabId: "distraction-blocker",
    });
  }
  enableFocusMode() {
    return this.notificationsSettingsApi.enableFocusMode();
  }
  toggleMute() {
    return this.notificationsSettingsApi.toggleGlobalMute();
  }
  subscribeNotificationsSettingsPopupState(e) {
    let t = () => {
      let { delayBeforeAutoHiding: i, delayBeforeHiding: s } =
        this.featureFlagsRepository.getFeatureFlag("muteNotificationsPopup");
      e({
        showDistractionBlocker: this.featureFlagsRepository.getFeatureFlag(
          "isDistractionBlockerEnabled"
        ),
        focusModeShortcut: this.shortcutService.getShortcuts().switchFocusMode,
        currentMuteMode:
          this.notificationsSettingsRepository.getCurrentMuteMode(),
        use12Format: this.userSettingsRepository.getSettings().use12Format,
        delayBeforeHiding: s,
        delayBeforeAutoHiding: i,
      });
    };
    t();
    let r = [
      this.featureFlagsRepository.onFeatureFlagsLoaded(t),
      this.notificationsSettingsRepository.onMuteModeChange(t),
      W.onSeveral(Ce, t),
    ];
    return F(r);
  }
};
c();
c();
var SS = [
    "session-loaded",
    "session-changed",
    "session-tab-changed",
    "session-tab-group-changed",
  ],
  pe = new A();
var mc = class {
  constructor(e, t, r, i) {
    this.quickSessionSwitcherService = e;
    this.sessionApi = t;
    this.featureFlagsRepository = r;
    this.billingApi = i;
  }
  resetIndex() {
    this.quickSessionSwitcherService.resetCurrentIndex();
  }
  revealSessionWindow(e) {
    return this.sessionApi.focusSessionWindow(e);
  }
  createWindowForSession(e) {
    return this.sessionApi.createWindowForSession(e);
  }
  switchSessionOfWindow(e, t) {
    return this.sessionApi.switchWindowSession(e, t);
  }
  subscribeSessionSwitcherPopupState(e, t) {
    let r = () => t(this.loadSessionSwitcherPopupState(e)),
      i = [
        this.quickSessionSwitcherService.onIndexChanged(r),
        pe.on("session-changed", r),
      ];
    return t(this.loadSessionSwitcherPopupState(e)), F(i);
  }
  loadSessionSwitcherPopupState(e) {
    let t =
        this.quickSessionSwitcherService.getSessionsByLastUsedWithHeadCurrent(
          e
        ),
      r = Qt(this.quickSessionSwitcherService.getIndex(), t.length),
      i = this.featureFlagsRepository.getFeatureFlag(
        "isHoverSessionSwitcherSidebarEnabled"
      ),
      { delayBeforeHiding: s, delayBeforeAutoHiding: a } =
        this.featureFlagsRepository.getFeatureFlag(
          "hoverSessionSwitcherSidebar"
        ),
      n = i ? s : null,
      p = this.sessionApi.mapSessionsToUI(t);
    return {
      activeIndex: r,
      currentSession: p[0],
      sessions: p,
      delayBeforeAutoHiding: a,
      delayBeforeHiding: n,
      isHoverModeEnabled: i,
      maxSessionsCount: this.billingApi.getMaxSessionsAvailable(),
    };
  }
};
c();
var hc = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m) {
    this.teamApi = e;
    this.userApi = t;
    this.collectionsApi = r;
    this.collectionsRepository = i;
    this.userSettingsRepository = s;
    this.shortcutService = a;
    this.workspaceRepository = n;
    this.featureFlagsRepository = p;
    this.collectionsBookmarksRepository = d;
    this.collectionsBookmarksApi = u;
    this.collectionsBookmarksService = m;
  }
  createTab(e) {
    return this.collectionsApi.createTab(e);
  }
  createCollection(e) {
    return this.collectionsApi.createCollection(e);
  }
  deleteCollection(e) {
    return this.collectionsApi.deleteCollection(e);
  }
  renameCollection(e, t) {
    return this.collectionsApi.renameCollection(e, t);
  }
  shareCollection(e, t, r) {
    return this.collectionsApi.shareCollection(e, t, r);
  }
  unshareCollection(e, t, r) {
    return this.collectionsApi.unshareCollection(e, t, r);
  }
  updateCollection(e, t, r) {
    return this.collectionsApi.updateCollection(e, t, r);
  }
  createLink(e, t, r) {
    return this.collectionsApi.createLink(e, t, r);
  }
  deleteLink(e) {
    return this.collectionsApi.deleteLink(e);
  }
  updateLink(e, t) {
    return this.collectionsApi.updateLink(e, t);
  }
  addCurrentTabToCollection(e, t) {
    return this.collectionsApi.addCurrentTabToCollection(e, t);
  }
  changeIsHiddenWelcomeToCollections(e) {
    return this.userApi.changeIsHiddenWelcomeToCollections(e);
  }
  addCurrentTabToBookmarksCollection(e) {
    return this.collectionsBookmarksApi.addCurrentTabToBookmarksCollection(e);
  }
  addLinkToBookmarksCollection(e, t, r) {
    return this.collectionsBookmarksApi.addLinkToBookmarksCollection(e, t, r);
  }
  createBookmarkFolder(e) {
    return this.collectionsBookmarksService.createBookmarkFolder(e);
  }
  removeBookmark(e) {
    return this.collectionsBookmarksApi.removeBookmark(e);
  }
  removeBookmarkFolder(e) {
    return this.collectionsBookmarksApi.removeBookmarkFolder(e);
  }
  moveBookmark(e, t) {
    return this.collectionsBookmarksApi.moveBookmark(e, t);
  }
  updateBookmark(e, t) {
    return this.collectionsBookmarksApi.updateBookmark(e, t);
  }
  importBookmarks() {
    return this.collectionsBookmarksApi.importBookmarks();
  }
  closeSuccessPopup() {
    return this.collectionsBookmarksApi.closeSuccessPopup();
  }
  subscribeCollections(e, t) {
    let r = () => {
        t(this.loadCollections(e));
      },
      i = [
        we.on("collections-loaded", r),
        we.on("collections-updated", r),
        W.on("user-settings-changed", (s) => {
          s.isHiddenWelcomeToCollections !== void 0 && r();
        }),
        _e.on("teams-loaded", r),
        _e.on("team-created", r),
        this.featureFlagsRepository.onFeatureFlagsLoaded(r),
      ];
    return r(), F(i);
  }
  subscribeCollectionsBookmarks(e) {
    let t = () => {
        e(this.loadCollectionsBookmarks());
      },
      r = [
        this.collectionsBookmarksRepository.onBookmarksLoaded(t),
        this.collectionsBookmarksService.subscribeImportFinished(t),
      ];
    return t(), F(r);
  }
  subscribeCollectionError(e) {
    return we.on("request-error", (t) => {
      e({ message: t });
    });
  }
  subscribeLastCreatedCollection(e) {
    return we.on("collection-created", e);
  }
  loadCollections(e) {
    let t = this.teamApi.getTeamForWorkspaceByWindowId(e),
      r = this.workspaceRepository.getWorkspaceForWindow(e),
      i = this.featureFlagsRepository.getFeatureFlag("b2bEnabled");
    return {
      ...this.collectionsRepository.getCollectionsForWorkspaceByWindowId(e),
      teamId: t && !t.isJustMe ? t.uuid : null,
      isHiddenWelcomeToCollections:
        this.userSettingsRepository.getSettings().isHiddenWelcomeToCollections,
      collectionsPanelShortcut:
        this.shortcutService.getShortcuts().toggleCollectionsSidecar.keys,
      alwaysShowTeamSection: r?.isTeamWorkspace ?? !1,
      isB2bEnabled: i,
    };
  }
  loadCollectionsBookmarks() {
    return {
      bookmarks: this.collectionsBookmarksRepository.getAllBookmarks(),
      areBookmarksImported:
        this.collectionsBookmarksService.getAreBookmarksImported(),
      isImportSuccessPopupShown:
        this.collectionsBookmarksService.getIsImportSuccessPopupShown(),
    };
  }
};
c();
var yc = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m, y) {
    this.sessionRepository = e;
    this.browserService = t;
    this.shortcutService = r;
    this.sessionApi = i;
    this.userApi = s;
    this.userSettingsRepository = a;
    this.workspaceRepository = n;
    this.popupService = p;
    this.billingRepository = d;
    this.billingApi = u;
    this.applicationPopupApi = m;
    this.featureFlagsRepository = y;
  }
  changeSessionTabPinning(e, t, r) {
    return this.sessionApi.changeSessionTabPinning(e, t, r);
  }
  changeSessionTabMuting(e, t, r) {
    return this.sessionApi.changeSessionTabMuting(e, t, r);
  }
  closeSession(e) {
    return this.sessionApi.deactivateSession(e);
  }
  createUserSession(e, t) {
    let r = this.workspaceRepository.getWorkspaceIdForWindow(e);
    r && this.sessionApi.createSession({ workspaceId: r, id: t });
  }
  createNewTab(e) {
    return this.browserService.createNTP(e);
  }
  changeIsHiddenWelcomeToSessions(e) {
    this.userApi.changeIsHiddenWelcomeToSessions(e);
  }
  createWindowForSession(e) {
    return this.sessionApi.createWindowForSession(e);
  }
  openSessionTab(e, t) {
    return this.sessionApi.openSessionTab(e, t);
  }
  removeSessionById(e) {
    this.sessionApi.deleteSession(e);
  }
  moveSessionTabToSession(e, t, r, i) {
    return this.sessionApi.moveSessionTabToAnotherSession(e, t, r, i);
  }
  renameSession(e, t) {
    this.sessionApi.renameSession(e, t);
  }
  reorderSessionTab(e, t, r, i) {
    return this.sessionApi.reorderSessionTab(e, t, r, i);
  }
  revealSessionWindow(e) {
    return this.sessionApi.focusSessionWindow(e);
  }
  saveSession(e) {
    this.sessionApi.saveSession(e);
  }
  switchSessionOfWindow(e, t) {
    return this.sessionApi.switchWindowSession(e, t);
  }
  reloadSessionTab(e, t) {
    return this.sessionApi.reloadSessionTab(e, t);
  }
  removeSessionTab(e, t) {
    return this.sessionApi.deleteSessionTab(e, t);
  }
  removeOtherSessionTabs(e, t) {
    return this.sessionApi.deleteOtherSessionTabs(e, t);
  }
  duplicateSessionTab(e, t) {
    return this.sessionApi.duplicateSessionTab(e, t);
  }
  subscribeSessionList(e, t) {
    let r = () => t(this.loadSessionList(e)),
      i = [
        pe.onSeveral(SS, r),
        W.on("user-settings-changed", (s) => {
          s.isHiddenWelcomeToSessions !== void 0 && r();
        }),
        this.popupService.subscribeToPopupChanged(r),
        this.shortcutService.onShortcutsUpdated(r),
        se.on("billing-plan-loaded", r),
        this.featureFlagsRepository.onFeatureFlagsLoaded(r),
      ];
    return r(), F(i);
  }
  startPlanUpgrade(e) {
    return this.applicationPopupApi.startPlanUpgrade(e);
  }
  subscribeActiveTab(e, t) {
    let r = () => {
        this.loadActiveTab(e).then(t).catch(l);
      },
      i = [pe.on("session-changed", r), D.on("apps-activated", r)];
    return r(), F(i);
  }
  loadSessionList(e) {
    let t = this.sessionRepository.getSessionByWindowId(e);
    if (!t) return null;
    let r = this.workspaceRepository.getWorkspaceIdForWindow(e);
    if (!r) return null;
    let i = this.sessionRepository.getSessionsByLastUsedByWorkspaceId(r),
      {
        switchSession: s,
        createNewTab: a,
        pinVerticalTabsSidecar: n,
      } = this.shortcutService.getShortcuts(),
      p = this.sessionApi.mapSessionsToUI(i),
      { pinnedTabs: d, regularTabs: u } =
        this.sessionApi.getPinnedAndRegularSessionTabs(t),
      { shouldOpenNewTabsOnTop: m } =
        this.featureFlagsRepository.getFeatureFlag("verticalTabs"),
      y = {
        ...t,
        tabsList: this.sessionRepository.getOrderedTabs(t.id),
        tabGroups: this.sessionApi.getUITabGroupsForSession(t),
        pinnedTabs: d,
        regularTabs: u,
        windowId: e,
      },
      b = this.billingRepository.getShouldUseProBadgesForUI();
    return {
      switchSessionShortcutKeys: s.keys,
      createNewTabShortcutKeys: a.keys,
      pinVerticalTabsSidecarKeys: n.keys,
      currentSession: y,
      sessions: p,
      isHiddenWelcomeToSessions:
        this.userSettingsRepository.getSettings().isHiddenWelcomeToSessions,
      useProBadges: b,
      canAddSessions: this.billingApi.canAddSession(e),
      maxSessionsAvailable: this.billingApi.getMaxSessionsAvailable() ?? null,
      shouldOpenNewTabsOnTop: m,
    };
  }
  async loadActiveTab(e) {
    return { tabId: (await this.browserService.getActiveTab(e))?.id ?? null };
  }
};
c();
var bc = class {
  constructor(e, t, r, i, s, a) {
    this.sidecarService = e;
    this.sidecarAppearanceService = t;
    this.themeService = r;
    this.shortcutService = i;
    this.featureFlagsRepository = s;
    this.collectionsRepository = a;
  }
  closeSidecar(e) {
    this.sidecarService.closeSidecar(e);
  }
  hideSidecar(e, t) {
    this.sidecarService.hideSidecar(e, t);
  }
  pinSidecar(e) {
    this.sidecarService.pinSidecar(e);
  }
  unpinSidecar(e) {
    this.sidecarService.unpinSidecar(e);
  }
  toggleSessions(e, t) {
    return this.sidecarService.toggleSessions(e, t);
  }
  toggleCollections(e, t) {
    return this.sidecarService.toggleCollections(e, t);
  }
  toggleTasks(e, t) {
    return this.sidecarService.toggleTasks(e, t);
  }
  toggleFullscreen(e, t) {
    return this.sidecarService.toggleFullscreen(e, t);
  }
  subscribeCollectionsAndTasksEnableState(e, t) {
    let r = () => t(this.loadCollectionsAndTasksState(e));
    return r(), this.featureFlagsRepository.onFeatureFlagsLoaded(r);
  }
  subscribeSidecar(e, t) {
    let r = () => t(this.loadSidecar(e)),
      i = [
        this.sidecarService.onSidecarChanged(r),
        this.sidecarAppearanceService.onSidecarModeChanged(r),
        this.themeService.onThemeChanged(r),
      ];
    return r(), F(i);
  }
  loadSidecar(e) {
    let t = this.sidecarService.getSidecarForWindow(e),
      { manageSession: r } = this.shortcutService.getShortcuts();
    if (!t) return null;
    let i = this.sidecarAppearanceService.getIsVerticalTabsModeEnabled();
    return {
      ...t,
      theme: this.themeService.getTheme(),
      chromeColor: this.themeService.getChromeTheme(),
      sessionShortcutKeys: r.keys,
      isPinned: this.sidecarAppearanceService.isSidecarPinned(e),
      isVerticalTabsModeEnabled: i,
    };
  }
  tryShowVerticalSidecarView(e) {
    this.sidecarAppearanceService.getIsModeSwitchingEnabled() &&
      (this.sidecarAppearanceService.switchToVerticalTabs(),
      this.toggleSessions({ source: "sidecar" }, e).catch(l));
  }
  loadCollectionsAndTasksState(e) {
    let t =
        this.collectionsRepository.isCollectionsEnabledForWorkspaceByWindowId(
          e
        ),
      r = this.featureFlagsRepository.getFeatureFlag("tasksEnabled");
    return { isCollectionsEnabled: t, isTasksEnabled: r };
  }
};
var wS = (
  o,
  e,
  t,
  r,
  i,
  s,
  a,
  n,
  p,
  d,
  u,
  m,
  y,
  b,
  v,
  S,
  w,
  T,
  I,
  k,
  _,
  O,
  E,
  f,
  j,
  ue,
  Q,
  C,
  G,
  K,
  B,
  X,
  ie,
  Z,
  ve,
  Qe,
  St,
  wt,
  kt,
  Me,
  Ye,
  Jt,
  ar,
  Ke,
  fo,
  nu,
  N,
  Ts,
  Is,
  cu,
  pu,
  As,
  lu,
  nr,
  Lt,
  ne,
  Or,
  du,
  mt,
  Ft,
  Zt,
  Si,
  uu,
  Xe,
  Ps,
  mu,
  jr,
  cr,
  Rs,
  hu,
  ht,
  wi,
  Le,
  So,
  Nr,
  ki,
  Lr,
  Tt
) => {
  let Je = new Qn(o),
    er = new dc(e, o, t, Or, mu, mt, Nr),
    It = new lc(Si, uu, v),
    yu = new _n(r),
    bu = new ac(i, s),
    gu = new rc(),
    Ti = new Fn(n, p, a, d, u, m, w, v, mt),
    vu = new pc(y, b, Ke, ue, Qe, Ft, X, ht),
    Gr = new cc(t, y, b),
    Es = new Un(S, d, r, w, T, Zt),
    fu = new Ln(I),
    wo = new Mn(t, mt, Ft, Le),
    ko = new En(wo, Q),
    Bs = new uc(Xe, Ps, wo, v, d, T),
    Su = new Gn(k, _, t, E, d, T, f, s, a),
    wu = new Vn(
      j,
      T,
      ue,
      Q,
      C,
      G,
      v,
      K,
      b,
      w,
      B,
      _,
      ht,
      X,
      Z,
      ve,
      S,
      Qe,
      y,
      d,
      du,
      Ft,
      mt,
      E,
      a,
      wi,
      Tt
    ),
    To = new Hn(Ft, y, So, v, mt, ht, Nr, ue, Ke),
    Cs = new $n(St, v, r),
    Ar = new Zn(
      T,
      ve,
      ht,
      I,
      v,
      C,
      w,
      Q,
      i,
      B,
      Ft,
      mt,
      ie,
      wt,
      kt,
      o,
      Ye,
      s,
      Or,
      jr,
      Rs,
      So,
      Nr
    ),
    Io = new Bn(j, K, E, v, d, b, T, t, mt, y, Ft, ue, It),
    ku = new Kn(t, Me, Qe, b, ue, K, y, Ft),
    Hr = new ic(t, Me, s, Jt, me.SIDEKICK_API || ""),
    Tu = new nc(mt),
    Ao = new Nn(ar),
    Vr = new yc(Ke, s, d, Ye, w, T, y, E, Ft, mt, Io, v),
    _s = new sc(fo, d),
    Iu = new mc(nu, Ye, v, mt),
    Fs = new bc(_, O, I, d, v, Lt),
    pr = new Jn(N, Ts, E),
    Ms = new xn(u, s),
    Po = new Dn(cr, Ms),
    xs = new oc(Is, cu, pu, v, m, t, ue, y),
    Ws = new Wn(E),
    Au = new zn(mt, t, Ft, ht),
    Pu = new hc(ht, w, As, Lt, T, d, y, v, ne, nr, lu),
    Ds = new Yn(t, As, ht, Lt),
    Us = new qn(ht, t, hu, ve, y, v, j),
    Ro = new jn(E, wt, Ye, Ke, ki, Lr, j);
  return {
    adblockerPopupApi: ko,
    addApplicationModalApi: ku,
    applicationPopupApi: Io,
    b2bModalApi: Us,
    billingDetailsPopupApi: To,
    billingModalsApi: Au,
    calendarModalApi: Je,
    collectionModalApi: Ds,
    collectionsListApi: Pu,
    cpuMonitorPopupApi: pr,
    exploreApi: yu,
    globalSettingsApi: Ar,
    helpApi: Ti,
    hintsApi: It,
    launchpadApi: wu,
    loggerApi: gu,
    marketplaceModalApi: Hr,
    modalApi: wo,
    notificationsApi: er,
    notificationsSettingsPopupApi: Bs,
    platformApi: Ms,
    pmfSurveyApi: Cs,
    popupApi: Ws,
    productHuntApi: Po,
    quickSessionSwitcherPopupApi: Iu,
    searchApi: Es,
    sessionContextMenuApi: Ro,
    sessionListApi: Vr,
    shareApplicationModalApi: xs,
    sidecarApi: Fs,
    signUpModalApi: Ao,
    tabSwitcherModalApi: _s,
    tabsDiscarderDebugApi: bu,
    themeApi: fu,
    upgradePlanModalApi: Tu,
    walkthroughApi: Su,
    workspaceEditModalApi: Gr,
    workspaceManagementModalApi: vu,
  };
};
c();
var gc = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m, y) {
    this.applicationActivationService = e;
    this.applicationService = t;
    this.onboardingAppsService = r;
    this.workspaceRepository = i;
    this.billingApi = s;
    this.accountService = a;
    this.accountRepository = n;
    this.applicationRepository = p;
    this.runningApplicationsObserver = d;
    this.browserService = u;
    this.analytics = m;
    this.billingRepository = y;
  }
  composeAppForAppPopup(e, t) {
    if (!t) return null;
    let r = this.workspaceRepository.getWorkspaceIdForWindow(e);
    if (!r) return null;
    let i = this.applicationService.composeAppForAppPopup(t);
    if (!i) return null;
    let s = this.runningApplicationsObserver.getIsRunningApp(t),
      a = this.workspaceRepository.getHasAppPinned(r, t);
    return { ...i, isRunning: s, isPinned: a };
  }
  async addApp(e, t, r, i) {
    return this.addNewApp(
      e,
      t,
      r,
      i.isPinned,
      i.currentAccountId,
      i.accountsForCreating
    );
  }
  addCustomApp(e, t, r) {
    return this.addNewApp(
      e,
      Pt.id,
      t,
      r.isPinned,
      r.currentAccountId,
      r.accountsForCreating,
      r.details
    );
  }
  addAppsAfterOnboarding(e) {
    let t = this.workspaceRepository.getDefaultWorkspace()?.id;
    return (
      g(t, "Workspace is not loaded"),
      this.onboardingAppsService.addAppsAfterOnboarding(t, e)
    );
  }
  async activatePinnedApplication(e) {
    let t = await this.browserService.getLastFocusedWindowId();
    if (!t) return;
    let r = this.workspaceRepository.getWorkspaceIdForWindow(t);
    if (!r) return;
    let i = this.workspaceRepository.getPinnedAppIdByIndex(r, e);
    if (
      !i ||
      this.billingApi.showLimitPopupIfBlocked(
        () => this.billingApi.canOpenSidebarApp(e),
        "add-app-popup-accounts"
      )
    )
      return;
    let a = this.appActivationBillingGuard(i);
    if (!a) return;
    let n = this.workspaceRepository.getWorkspaceById(a.workspaceId);
    this.analytics.sendAnalyticsEvent("app.activated", {
      source: "shortcut",
      "app.pinned-index": e,
      "app.recipe-id": a.recipeId,
      "app.is-team-app": a.isTeamApp,
      "app.is-shared": a.sharedToMe,
      "team.uuid": n?.teamUuid ?? null,
    }),
      await this.applicationActivationService.activateApplication(a, {
        keepReusableTab: !0,
      });
  }
  async activateApplication(e, t = {}) {
    let r = this.appActivationBillingGuard(e);
    r && (await this.applicationActivationService.activateApplication(r, t));
  }
  async activateApplicationsAsTab(e, t = {}) {
    let r = this.appActivationBillingGuard(e);
    r &&
      (await this.applicationActivationService.activateApplicationsAsTab(r, t));
  }
  async activateCurrentApplicationAsTab() {
    let e = await this.browserService.getActiveTab();
    if (!e) return;
    let t = this.applicationRepository.getAppByTab(e);
    t && (await this.activateApplicationsAsTab(t.id));
  }
  async activateCurrentApplicationInSplitView() {
    let e = await this.browserService.getActiveTab();
    if (!e) return !1;
    let t = this.applicationRepository.getAppByTab(e);
    return t
      ? (await this.activateApplication(t.id, { inGlobalSplit: !0 }), !0)
      : !1;
  }
  activateApplicationByRecipeId(e) {
    return this.applicationActivationService.activateApplicationByRecipeId(e);
  }
  async activateApplicationInSplitPanel() {
    return this.billingApi.showLimitPopupIfBlocked(
      () => this.billingRepository.canUseSplitView(),
      "add-app-popup-accounts"
    )
      ? Promise.resolve()
      : this.applicationActivationService.activateInSplitPanel();
  }
  closeApplicationTab(e) {
    return this.applicationActivationService.closeAppTab(e);
  }
  changeIsNotificationEnabled(e, t) {
    return this.applicationService.changeIsNotificationEnabled(e, t);
  }
  changeSyncFocusModeEnabled(e, t) {
    this.applicationService.changeIsSyncFocusModeEnabled(e, t);
  }
  async changeShowAsSidecarPanel(e, t) {
    return this.applicationService.changeShowAsSidecarPanel(e, t);
  }
  changeIsMuted(e, t) {
    return this.applicationService.changeIsMuted(e, t);
  }
  changeAppName(e, t) {
    this.applicationService.changeAppName(e, t);
  }
  changeIcon(e, t) {
    return this.applicationService.changeIcon(e, t);
  }
  async removeApp(e) {
    return (
      await this.applicationService.removeApp(e),
      this.applicationActivationService.closeAppTab(e)
    );
  }
  removeAppsByWorkspaceId(e) {
    this.applicationService.removeWorkspaceApps(e);
  }
  clearPinnedByWorkspace(e) {
    this.applicationService.clearPinnedByWorkspace(e);
  }
  resetIcon(e) {
    return this.applicationService.resetIcon(e);
  }
  changeDoNotSuspend(e, t) {
    this.applicationService.changeDoNotSuspend(e, t);
  }
  changeDisableNotificationMessages(e, t) {
    this.applicationService.changeDisableNotificationMessages(e, t);
  }
  changeIsNotificationBadgeEnabled(e, t) {
    this.applicationService.changeNotificationBadgeEnabled(e, t);
  }
  changeDisableNotificationBadgeNumber(e, t) {
    this.applicationService.changeDisabledNotificationBadgeNumber(e, t);
  }
  createAccount(e, t) {
    this.accountService.createAccount(e, t);
  }
  async deleteAccount(e, t, r) {
    let i = new Set(
        this.accountRepository.getAppIdsWithCurrentAccountId(e, t.id)
      ),
      s = this.accountService.deleteAccount(e, t, r);
    s && (await this.applicationActivationService.updateActiveApp(e, r, s, i)),
      await this.applicationActivationService.updatePartitions(t.partition);
    let a = this.workspaceRepository.getWorkspaceById(e)?.partitionDomain;
    return (
      g(a !== void 0, "Couldnt find workspacePartition"),
      this.accountService.clearUnusedPartition(a, t.partition)
    );
  }
  updateAccount(e, t, r) {
    this.accountService.updateAccount(e, t, r),
      t.shouldReloadOnEdit &&
        this.applicationActivationService.updateActiveApp(e, r, t.id).catch(l);
  }
  activateAccountToAppById(e, t) {
    this.accountService.setCurrentAccountForApp(e, t) &&
      this.applicationActivationService.updateAppAccountPartition(e).catch(l);
  }
  getActivationsByAppId(e) {
    return this.applicationActivationService.getActivationsByAppId(e);
  }
  appActivationBillingGuard(e) {
    let t = this.applicationRepository.getAppById(e);
    return t
      ? (t.recipeId !== Pt.id ||
          this.runningApplicationsObserver.getAppTabId(t.id),
        t)
      : void 0;
  }
  async addNewApp(e, t, r, i, s, a, n) {
    if (
      this.billingApi.showLimitPopupIfBlocked(
        () => this.billingApi.canAddAppToWorkspace(e),
        "add-app-popup-accounts"
      )
    )
      return;
    let d = this.billingApi.showLimitPopupIfBlocked(
        () => this.billingApi.canPinApp(e),
        "add-app-popup-accounts"
      ),
      u = await this.applicationService.addNewApp(e, i && !d, t, n, a, s);
    return (
      await this.activateApplication(u, { showLimitPopup: !1 }),
      this.browserService.scrollSidebarToApp(r, u).catch(l),
      u
    );
  }
  getRecipeIdByAppId(e) {
    let t = this.applicationRepository.getAppById(e);
    return t ? t.recipeId : null;
  }
};
c();
c();
var yE = "/recipes-icons.json",
  vc = class {
    constructor(e) {
      this.browserService = e;
      this.loaded = this.loadFromBundle().catch(l);
    }
    loaded;
    iconsManifest = {};
    async getPath(e) {
      await this.loaded;
      let t = this.iconsManifest[e];
      return {
        svg: t?.svg ? this.browserService.getUrl(t.svg) : void 0,
        png: t?.png ? this.browserService.getUrl(t.png) : void 0,
      };
    }
    async loadFromBundle() {
      let e = new Request(yE),
        t = await fetch(e);
      g(t.ok, "Couldn't load recipes icons manifest"),
        (this.iconsManifest = await je(t, e));
    }
  };
c();
c();
var fc = class {
  constructor(e, t, r, i, s, a, n, p) {
    this.browserService = e;
    this.analyticsTracker = t;
    this.browserEventsService = r;
    this.browserStorage = i;
    this.applicationRepository = s;
    this.runningApplicationsObserver = a;
    this.billingRepository = n;
    this.extraDataService = p;
  }
  logger = x.createInstance("split_view");
  billingApi;
  setupSplitView(e) {
    (this.billingApi = e),
      this.browserEventsService.subscribeToGlobalSplitViewRequested((t) => {
        this.handleGlobalSplitViewRequest(t);
      }),
      this.browserEventsService.subscribeToSplitViewRequested((t, r, i) => {
        this.handleSplitViewRequest(t, r, i);
      });
  }
  async splitAppGlobal(e) {
    if (
      this.billingApi?.showLimitPopupIfBlocked(
        () => this.billingRepository.canUseSplitView(),
        "add-app-popup-accounts"
      )
    )
      return;
    this.analyticsTracker.sendAnalyticsEvent("split-view.global-enabled", {
      source: "tab-alt-click",
    });
    let r = this.runningApplicationsObserver.getAppTabId(e.id);
    if (!r) return;
    let i = (await this.browserStorage.getItem("last-split-panel-app")) ?? {};
    await this.browserStorage.setItem("last-split-panel-app", {
      ...i,
      [e.workspaceId]: e.id,
    }),
      this.logger.info(`Splitting app with id ${e.id}`),
      this.browserService.setGlobalSplitView(r, e.splitViewWidth),
      await this.browserStorage.setItem("last-split-panel-type", "app");
  }
  async resetGlobalSplitView(e) {
    let r = (await this.browserService.getSplitState()).globals.find(
      (i) => i.tabId === e
    );
    return r
      ? (this.logger.info(
          `Closing global split for window with id ${r.windowId}`
        ),
        this.browserService.resetGlobalSplitView(r.windowId),
        !0)
      : !1;
  }
  addLocalSplitView(e, t) {
    this.browserService.addLocalSplitView(e, t);
  }
  resetLocalSplitView(e) {
    this.browserService.resetLocalSplitView(e);
  }
  openSplitViewMenu() {
    this.browserService.showSplitViewMenu().catch(l);
  }
  async getIsInAnySplit(e) {
    let t = await this.browserService.getSplitState();
    return (
      t.globals.some((r) => r.tabId === e) ||
      t.locals.some((r) => r.splitPair.left === e || r.splitPair.right === e)
    );
  }
  async undiscardTab(e) {
    let t = await this.browserService.getSplitState();
    (await this.browserService.getTabById(e))?.discarded &&
      t.locals.some((i) => i.splitPair.left === e || i.splitPair.right === e) &&
      (await this.browserService.reloadTab(e));
  }
  handleGlobalSplitViewRequest(e) {
    this.analyticsTracker.sendAnalyticsEvent("split-view.global-enabled", {
      source: "app-with-sidepanel-enabled-open",
    });
    let t = this.runningApplicationsObserver.getAppIdByTabId(e);
    if (!t) return;
    let r = this.applicationRepository.getAppById(t);
    !r ||
      this.billingApi?.showLimitPopupIfBlocked(
        () => this.billingRepository.canUseSplitView(),
        "add-app-popup-accounts"
      ) ||
      this.browserService.setGlobalSplitView(e, r.splitViewWidth);
  }
  async activateTabId(e, t) {
    let r = this.applicationRepository.getAppById(t);
    r &&
      (await this.browserService.activateTab(e), await this.splitAppGlobal(r));
  }
  async handleSplitViewAltClick(e, t) {
    let r = this.runningApplicationsObserver.getAppIdByTabId(e),
      i = this.runningApplicationsObserver.getAppIdByTabId(t);
    if (r) {
      await this.activateTabId(t, r);
      return;
    }
    i && (await this.activateTabId(e, i));
  }
  handleSplitViewRequest(e, t, r) {
    if (
      (r === pv.ALT_CLICK && this.handleSplitViewAltClick(e, t).catch(l),
      t === e)
    ) {
      this.resetLocalSplitView(e);
      return;
    }
    t !== e &&
      this.analyticsTracker.sendAnalyticsEvent("split-view.local-enabled", {
        source: "split-menu",
      }),
      !this.billingApi?.showLimitPopupIfBlocked(
        () => this.billingRepository.canUseSplitView(),
        "add-app-popup-accounts"
      ) && (this.addToLocalSplitView(e, t), this.saveLastTabs([e, t]).catch(l));
  }
  async saveLastTabs(e) {
    await Promise.all([
      this.browserStorage.setItem("last-split-panel-tab", e),
      this.browserStorage.setItem("last-split-panel-type", "tab"),
    ]).catch(l);
  }
  addToLocalSplitView(e, t) {
    this.undiscardTab(t).catch(l), this.addLocalSplitView(e, t);
  }
  async openLastSplitTab(e, t) {
    let r = e.id;
    if (!r) return;
    let [i, s] = await Promise.all([
      this.browserStorage.getItem("last-split-panel-tab"),
      this.getIsInAnySplit(r),
    ]);
    if (!i?.length) return;
    let a = this.billingApi?.showLimitPopupIfBlocked(
        () => this.billingRepository.canUseSplitView(),
        "add-app-popup-accounts"
      ),
      [n, p] = i,
      d = n === r && p ? p : n;
    if (!d || a) return;
    if (s || d === r) {
      this.resetLocalSplitView(d);
      return;
    }
    this.analyticsTracker.sendAnalyticsEvent("split-view.local-enabled", {
      source: "split-menu",
    });
    let u = await this.browserService.getTabById(d);
    if (!u) return;
    if (this.extraDataService.getTabExtraData(e)?.app) {
      this.splitAppByTabId(r).catch(l);
      return;
    }
    u?.windowId !== t && (await this.browserService.moveTab(d, -1, t)),
      this.addToLocalSplitView(d, r);
  }
  async getLastSplitViewType() {
    return this.browserStorage.getItem("last-split-panel-type");
  }
  async splitAppByTabId(e) {
    let t = this.runningApplicationsObserver.getAppIdByTabId(e);
    if (!t) return;
    let r = this.applicationRepository.getAppById(t);
    if (r)
      try {
        await this.splitAppGlobal(r),
          await this.browserStorage.setItem("last-split-panel-type", "app");
      } catch (i) {
        l(i);
      }
  }
};
c();
c();
var cs = "",
  Ut = class {
    static createAccount({
      accountType: e,
      name: t,
      startUrl: r,
      avatar: i,
      hasSeparatePartition: s,
      isTemporary: a,
    }) {
      let n = s ? le() : cs;
      return {
        id: le(),
        name: t,
        partition: n,
        avatar: i ?? "",
        startUrl: r,
        type: e,
        createdAt: Date.now(),
        isAuthorized: !1,
        isDeleted: !1,
        isTemporary: a,
        isPrivate: s,
      };
    }
    static createBaseAccount({ name: e, startUrl: t }) {
      return { id: le(), name: e, startUrl: t, avatar: "", isPrivate: !1 };
    }
  };
c();
var Et = (o, e) =>
    e.hasCustomUrl || o.sharedToMe ? o.id : e.accountsType ?? e.id,
  Sc = (o, e) => (o.hasCustomUrl ? e ?? o.id : o.accountsType ?? o.id);
var wc = class {
  constructor(e, t) {
    this.browserStorage = e;
    this.recipesRepository = t;
  }
  stateByWorkspaceId = {};
  logger = x.createInstance("accounts");
  getCurrentAppAccountId(e) {
    return this.getCurrentAccountsByAppIdForWorkspace(e.workspaceId)[e.id];
  }
  getAllCurrentAccountIds(e) {
    return this.getCurrentAccountsByAppIdForWorkspace(e);
  }
  getAppIdsWithCurrentAccountId(e, t) {
    let r = this.getCurrentAccountsByAppIdForWorkspace(e);
    return Object.entries(r).reduce(
      (i, [s, a]) => (a === t && i.push(s), i),
      []
    );
  }
  getCurrentAppAccount(e, t) {
    let r = this.getAccountById(
      e,
      t,
      this.getCurrentAccountsByAppIdForWorkspace(e.workspaceId)[e.id]
    );
    if (r) return r;
    let i = Et(e, t);
    return (
      this.logger.info(
        `Temporary ${i} account created for app ${e.id} ${e.name}`
      ),
      Ut.createAccount({
        name: P("background_account_repository__temporary_account"),
        accountType: i,
        hasSeparatePartition: !1,
        startUrl: this.getTempAccountStartUrl(t, e),
        isTemporary: !0,
      })
    );
  }
  getAccountById(e, t, r) {
    let i = Et(e, t),
      s = this.getAccountsByTypeForWorkspace(e.workspaceId)[i],
      a = this.getCurrentAccountsByAppIdForWorkspace(e.workspaceId),
      n = s?.filter((u) => !u.isDeleted),
      d =
        (r ? n?.find((u) => u.id === r) : void 0) ??
        n?.find((u) => u.id === a[e.id]) ??
        n?.[0];
    if (d) return { ...d, startUrl: this.getStartUrl(t, d) };
  }
  getAccountsByType(e, t, r) {
    return (
      this.getAccountsByTypeForWorkspace(e)[t]?.map((s) => ({
        ...s,
        startUrl: this.getStartUrl(r, s),
      })) ?? []
    ).filter((s) => !s.isDeleted);
  }
  getAccountForAppAvatar(e) {
    let t = this.recipesRepository.getRecipeForApp(e);
    return this.getAccountsCountForApp(e, t) > 1
      ? this.getCurrentAppAccount(e, t)
      : void 0;
  }
  getAccountsByTypeSorted(e, t) {
    let r = Et(e, t);
    return this.getSortedAccounts(e.workspaceId, r, t);
  }
  getAccountsByApp(e) {
    let t = this.recipesRepository.getRecipeForApp(e),
      r = Et(e, t);
    return this.getAccountsByType(e.workspaceId, r, t);
  }
  getAccountsByRecipeSorted(e, t) {
    let r = Sc(t);
    return this.getSortedAccounts(e, r, t);
  }
  getAccountsByTypeForWorkspace(e) {
    return this.stateByWorkspaceId[e]?.appAccountsByType ?? {};
  }
  getCurrentAccountsByAppIdForWorkspace(e) {
    return this.stateByWorkspaceId[e]?.currentAccountsByAppId ?? {};
  }
  updateAccounts(e, t, r) {
    let i = this.getStateForWorkspace(e);
    (this.stateByWorkspaceId[e] = {
      ...i,
      appAccountsByType: { ...i.appAccountsByType, [t]: r },
    }),
      this.saveAccounts();
  }
  setCurrentAccountForApp(e, { appId: t, accountId: r, type: i }) {
    let s = this.getStateForWorkspace(e);
    if (r)
      this.stateByWorkspaceId[e] = {
        ...s,
        currentAccountsByAppId: { ...s.currentAccountsByAppId, [t]: r },
      };
    else {
      let a = s.appAccountsByType[i]?.find((n) => n.name && !n.isDeleted)?.id;
      if (!a) return;
      this.stateByWorkspaceId[e] = {
        ...s,
        currentAccountsByAppId: { ...s.currentAccountsByAppId, [t]: a },
      };
    }
    return (
      this.saveAccounts(), this.stateByWorkspaceId[e]?.currentAccountsByAppId[t]
    );
  }
  changeAppIdForCurrentAccount(e, t, r) {
    let i = this.getStateForWorkspace(e),
      s = i.currentAccountsByAppId[t];
    s &&
      ((this.stateByWorkspaceId[e] = {
        ...i,
        currentAccountsByAppId: { ...i.currentAccountsByAppId, [r]: s },
      }),
      delete this.stateByWorkspaceId[e]?.currentAccountsByAppId[t],
      this.saveAccounts());
  }
  changeAccountType(e, t, r) {
    let i = this.getStateForWorkspace(e),
      s = i.appAccountsByType[t];
    s &&
      ((this.stateByWorkspaceId[e] = {
        ...i,
        appAccountsByType: {
          ...i.appAccountsByType,
          [r]: s.map((a) => ({ ...a, type: r })),
        },
      }),
      delete this.stateByWorkspaceId[e]?.appAccountsByType[t],
      this.saveAccounts());
  }
  async loadAccounts(e) {
    let t = await this.loadAccountsFromStorage();
    e.forEach((r) => {
      let i = this.recipesRepository.getRecipeForApp(r),
        s = Et(r, i);
      if (i.accountsType || t[r.workspaceId]?.appAccountsByType[s]) return;
      let n = Ut.createAccount({
        accountType: s,
        name: `${r.name} ${P("background_account_repository__account")}`,
        startUrl: r.migratedUrl || r.recipeMetaData.welcomeURL || i.startURL,
        hasSeparatePartition: r.sharedToMe,
      });
      t[r.workspaceId] = {
        appAccountsByType: { ...t[r.workspaceId]?.appAccountsByType, [s]: [n] },
        currentAccountsByAppId: {
          ...t[r.workspaceId]?.currentAccountsByAppId,
          [r.id]: n.id,
        },
      };
    }),
      this.logger.info("Accounts state after loading", t),
      (this.stateByWorkspaceId = t),
      D.emit("accounts-loaded");
  }
  getStateForWorkspace(e) {
    return (
      this.stateByWorkspaceId[e] ?? {
        currentAccountsByAppId: {},
        appAccountsByType: {},
      }
    );
  }
  async loadAccountsFromStorage() {
    let e = await this.browserStorage.getItem("app-accounts-by-workspace");
    return this.logger.info("Accounts loaded", e), e ?? {};
  }
  getSortedAccounts(e, t, r) {
    return this.getAccountsByType(e, t, r)
      .filter((s) => !s.isTemporary)
      .sort((s, a) => s.createdAt - a.createdAt);
  }
  saveAccounts() {
    this.browserStorage
      .setItem("app-accounts-by-workspace", this.stateByWorkspaceId)
      .catch(l),
      this.logger.info("Accounts saved"),
      D.emit("accounts-changed");
  }
  getStartUrl(e, t) {
    return e.hasCustomUrl || !e.accountsType
      ? t.startUrl
      : !t.isAuthorized && e.loginURL
      ? _u(e.loginURL, t.name)
      : _u(e.startURL, t.name);
  }
  getTempAccountStartUrl(e, t) {
    return e.accountsType
      ? (g(e.welcomeURL, "Recipe does not have welcomeURL"), e.welcomeURL)
      : e.hasCustomUrl
      ? t.customUrl ?? t.recipeMetaData.welcomeURL ?? ""
      : qs(e.startURL);
  }
  getAccountsCountForApp(e, t) {
    let r = Et(e, t);
    return (
      this.getStateForWorkspace(e.workspaceId).appAccountsByType[r]?.filter(
        (a) => !a.isDeleted
      )?.length ?? 0
    );
  }
};
c();
var kc = class {
  constructor(e, t, r, i, s, a, n, p) {
    this.recipesRepository = e;
    this.applicationRepository = t;
    this.accountRepository = r;
    this.browserService = i;
    this.analyticsTracker = s;
    this.accountsMigrationService = a;
    this.workspaceRepository = n;
    this.billingRepository = p;
    D.on("apps-loaded", () => {
      this.loadAccounts().catch(l);
    });
  }
  logger = x.createInstance("accounts");
  authorizeAccount(e, t) {
    let r = Et(e, t),
      i = this.accountRepository.getAccountsByType(e.workspaceId, r, t),
      s = this.accountRepository.getCurrentAppAccountId(e);
    if (!s) return;
    let a = i.map((n) => (n.id === s ? { ...n, isAuthorized: !0 } : n));
    this.logger.info(`Account ${s} was authorized for app ${e.id} ${e.name}`),
      this.accountRepository.updateAccounts(e.workspaceId, r, a);
  }
  addAccountsFromContentScript(e, t) {
    let r = this.applicationRepository.getAppById(e);
    if (!r) return;
    this.logger.info(
      `Received accounts from content script for app ${r.id} ${r.name}`,
      t
    );
    let i = this.recipesRepository.getRecipeForApp(r),
      s = Et(r, i),
      a = this.accountRepository.getAccountsByType(r.workspaceId, s, i),
      n,
      p = a.map((u) => {
        let m = t.find((y) => y.account === u.name);
        return m && !u.isDeleted
          ? (m.isCurrent && (n = u.id), { ...u, avatar: m.avatar })
          : u;
      }),
      d = new Set(p.map((u) => u.name));
    t.forEach((u) => {
      if (!u.account || d.has(u.account)) return;
      let m = Ut.createAccount({
        accountType: s,
        name: u.account,
        startUrl: i.startURL,
        hasSeparatePartition: !i.accountsType,
      });
      u.isCurrent && (n = m.id),
        p.push(m),
        this.logger.info(
          `Added new account from content script ${m.id} ${m.type}`
        ),
        this.analyticsTracker.sendAnalyticsEvent("account.created", {
          "app.is-custom": !1,
          "recipe.has-accounts-type": !0,
          "account.is-injected": !0,
          "app.is-existed": !0,
        });
    }),
      this.accountRepository.updateAccounts(r.workspaceId, s, p),
      n &&
        this.accountRepository.setCurrentAccountForApp(r.workspaceId, {
          appId: r.id,
          accountId: n,
          type: s,
        });
  }
  createAccount(
    e,
    { recipe: t, appId: r, name: i, startUrl: s, isPrivate: a }
  ) {
    let n = Sc(t, r),
      p = this.accountRepository.getAccountsByType(e, n, t);
    if (!this.billingRepository.canAddAccount(p.length)) return null;
    let u = Boolean((!t.accountsType && p.length) || a),
      m = Ut.createAccount({
        accountType: n,
        name: i,
        startUrl: s || t.startURL,
        hasSeparatePartition: u,
      });
    return (
      this.accountRepository.updateAccounts(e, n, [...p, m]),
      r && !p.length && this.setCurrentAccountForApp(r, m.id),
      m.id
    );
  }
  createAccountsForNewApp(e, t, r, i) {
    r.forEach(({ id: s, name: a, startUrl: n, isPrivate: p }) => {
      let d = this.createAccount(e.workspaceId, {
        recipe: t,
        appId: e.id,
        name: a,
        startUrl: n,
        isPrivate: p,
      });
      d && s === i && this.setCurrentAccountForApp(e.id, d);
    });
  }
  createBaseAccountsForOnboardingApp(e, t) {
    let r = Boolean(e.accountsType);
    return t && t.length > 0
      ? t.map((i) => Ut.createBaseAccount({ name: i, startUrl: e.startURL }))
      : r
      ? []
      : [
          Ut.createBaseAccount({
            name: `${e.name} account`,
            startUrl: e.startURL,
          }),
        ];
  }
  setCurrentAccountForApp(e, t) {
    let r = this.applicationRepository.getAppById(e);
    if (!r) return !1;
    let i = this.recipesRepository.getRecipeForApp(r),
      s = Et(r, i),
      a = this.accountRepository.getCurrentAppAccountId(r);
    return t && t === a
      ? !1
      : (this.accountRepository.setCurrentAccountForApp(r.workspaceId, {
          appId: e,
          accountId: t,
          type: s,
        }),
        !0);
  }
  switchCurrentAccountFromStubToRealApp(e, t, r) {
    this.accountRepository.changeAppIdForCurrentAccount(e, t, r);
  }
  switchAccountsFromStubToCustomRealApp(e, t, r) {
    this.accountRepository.changeAccountType(e, t, r);
  }
  deleteAccount(e, t, r) {
    let s = this.accountRepository
      .getAccountsByType(e, t.type, r)
      .map((a) => (a.id === t.id ? { ...a, isDeleted: !0 } : a));
    return (
      this.accountRepository.updateAccounts(e, t.type, s),
      this.resetAccountIfCurrent(e, t)
    );
  }
  updateAccount(e, t, r) {
    let { shouldReloadOnEdit: i, ...s } = t,
      n = this.accountRepository
        .getAccountsByType(e, s.type, r)
        .map((p) => (p.id === s.id ? { ...s } : p));
    this.accountRepository.updateAccounts(e, s.type, n);
  }
  clearUnusedPartition(e, t) {
    return t === cs
      ? Promise.resolve()
      : (this.logger.info(`Unused partition ${t} was removed`),
        D.emit("partition-cleared", e, t),
        this.browserService.clearPartition(e, t));
  }
  resetAccountIfCurrent(e, t) {
    let r = this.accountRepository.getAllCurrentAccountIds(e),
      i = [];
    return (
      Object.entries(r).forEach(([s, a]) => {
        if (t.id !== a) return;
        let n = this.accountRepository.setCurrentAccountForApp(e, {
          appId: s,
          type: t.type,
        });
        n && i.push(n);
      }),
      i[0]
    );
  }
  async loadAccounts() {
    let e = this.applicationRepository.getAllApps(),
      t = this.workspaceRepository.getDefaultWorkspaceId();
    if (!t) {
      re.once("workspaces-loaded", () => {
        this.loadAccounts().catch(l);
      });
      return;
    }
    await this.accountsMigrationService.runMigrations({
      defaultWorkspaceId: t,
      applications: e,
    }),
      await this.accountRepository.loadAccounts(e);
  }
};
c();
var Tc = class {
  constructor(e, t) {
    this.browserStorage = e;
    this.recipesRepository = t;
  }
  async runMigrations(e) {
    let t = await this.migrateOldExtensionAccounts(e.applications);
    await this.migrateAllAccountsToDefaultWorkspace(e.defaultWorkspaceId, t);
  }
  async migrateOldExtensionAccounts(e) {
    let t = await this.browserStorage.getItem("accounts");
    if (!t) return;
    let r =
        t?.reduce((p, d) => {
          let u = this.migrateOldAccount(d),
            m = p[d.type] ?? [];
          return { ...p, [d.type]: [...m, u] };
        }, {}) ?? {},
      { appAccountsByType: i, currentAccountsByAppId: s } =
        await this.loadAccountsFromStorage(),
      a = {},
      n = {};
    return (
      e.forEach((p) => {
        let d = p.id,
          u = this.recipesRepository.getRecipeForApp(p),
          m = Et(p, u);
        if (p.wasPrivateBefore) {
          let S = a[m]?.length ?? 0,
            w = this.migrateOldPrivateAppAccount(p, u, m, S),
            T = a[w.type] ?? [];
          (a[w.type] = [...T, w]), (n[p.id] = w.id);
        }
        let y = r[m] ?? [];
        if (y.length) {
          let S = y.find((w) => w.id === p.currentAccountId) ?? y[0];
          g(S, "Couldnt find default old multiaccount"),
            (a[m] = y),
            (n[d] = S.id);
          return;
        }
        let b = i[m];
        if (b?.length) {
          (a[m] = b),
            g(b[0], "Couldnt find default new multiaccount for type", {
              accountType: m,
            }),
            (n[d] = s[d] ?? b[0].id);
          return;
        }
        if (u.accountsType || a[m]?.length) return;
        let v = Ut.createAccount({
          accountType: m,
          name: `${p.name} account`,
          startUrl: p.migratedUrl || p.recipeMetaData.welcomeURL || u.startURL,
          hasSeparatePartition: p.sharedToMe,
        });
        (a[v.type] = [v]), (n[d] = v.id);
      }),
      this.browserStorage.setItem("app-accounts", a).catch(l),
      this.browserStorage.setItem("app-current-accounts", n).catch(l),
      this.browserStorage.removeItem("accounts").catch(l),
      this.browserStorage.removeItem("accounts-migrated").catch(l),
      { appAccountsByType: a, currentAccountsByAppId: n }
    );
  }
  async migrateAllAccountsToDefaultWorkspace(e, t) {
    let r = await this.browserStorage.getItem("app-accounts-by-workspace"),
      i = r?.[e];
    if (!t && i) return;
    let s = t ?? (await this.loadAccountsFromStorage()),
      a = { ...r, [e]: s };
    await this.browserStorage.setItem("app-accounts-by-workspace", a),
      await this.removeOldKeys();
  }
  async removeOldKeys() {
    await this.browserStorage.removeItem("app-accounts"),
      await this.browserStorage.removeItem("app-current-accounts");
  }
  async loadAccountsFromStorage() {
    let e = (await this.browserStorage.getItem("app-accounts")) ?? {},
      t = (await this.browserStorage.getItem("app-current-accounts")) ?? {};
    return { appAccountsByType: e, currentAccountsByAppId: t };
  }
  migrateOldAccount(e) {
    return {
      id: e.id,
      name: e.value,
      partition: cs,
      avatar: e.avatar ?? "",
      startUrl: "",
      type: e.type,
      createdAt: Date.now(),
      isAuthorized: !0,
      isDeleted: e.isDeleted,
      isPrivate: !1,
    };
  }
  migrateOldPrivateAppAccount(e, t, r, i) {
    let s = i > 0 ? `${e.name} account ${i + 1}` : `${e.name} account`;
    return {
      id: le(),
      name: s,
      partition: e.savedId ?? le(),
      avatar: "",
      startUrl: e.migratedUrl || t.startURL,
      type: r,
      createdAt: Date.now(),
      isAuthorized: !0,
      isDeleted: !1,
      isPrivate: !0,
    };
  }
};
c();
c();
var xr = class {
  constructor(e, t, r, i, s, a) {
    this.browserService = e;
    this.applicationsRepository = r;
    this.encryptionService = i;
    this.teamAppSharingService = s;
    this.browserTabLocker = a;
    (this.keyset = this.encryptionService.getKeyset()),
      this.keyset ||
        this.encryptionService.onKeysetLoaded(() => {
          this.keyset = this.encryptionService.getKeyset();
        }),
      t.subscribeToAutofillPassword(async (n, p, d, u) => {
        await this.browserTabLocker.lock(n),
          p === lv.HTML
            ? await this.tryAutofillPassword(n, u)
            : this.resetForm(n, u);
      });
  }
  keyset = null;
  static isAutofillRequired(e) {
    return e.isTeamApp ? Boolean(e.teamCredentialId) : e.sharedToMe;
  }
  async tryAutofillPassword(e, t) {
    let r = await this.getCredentialsForTab(e);
    r?.username && r.password
      ? this.autofillForm(e, t, r)
      : this.resetForm(e, t);
  }
  async getCredentialsForTab(e) {
    let t = await this.applicationsRepository.getAppByTabId(e);
    return !t || !xr.isAutofillRequired(t)
      ? null
      : t.isTeamApp
      ? this.teamAppSharingService.getCredentialsById(t.teamCredentialId)
      : this.getCredentialsFromSharingData(t.sharing);
  }
  async getCredentialsFromSharingData({ hasCredentials: e, credentials: t }) {
    if (!e) return null;
    let r = t.find((s) => s.publicKeyId === this.keyset?.id);
    return r ? await this.encryptionService.decryptRemote(r.data) : null;
  }
  autofillForm(e, t, r) {
    this.browserTabLocker.unlock(e) &&
      this.browserService.setAutofillPasswordForm(
        e,
        t,
        r.username,
        r.password,
        !0,
        !1
      );
  }
  resetForm(e, t) {
    this.browserTabLocker.unlock(e) &&
      this.browserService.setAutofillPasswordForm(e, t);
  }
};
var Ic = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m) {
    this.applicationRepository = e;
    this.recipesRepository = t;
    this.browserService = r;
    this.extraDataService = i;
    this.splitViewService = s;
    this.accountRepository = a;
    this.activationApplicationStatistic = n;
    this.runningApplicationsObserver = p;
    this.workspaceRepository = d;
    this.browserStorage = u;
    this.billingRepository = m;
    D.once("apps-loaded", this.closeNotFocusedApps.bind(this));
  }
  logger = x.createInstance("applications");
  lastActiveAppTabIdByWorkspaceId = {};
  async activateApplication(e, t = {}) {
    this.logger.info(`Activating application ${e.name}`, t);
    let r = await this.browserService.getNormalLastFocusedWindow(),
      i = r?.partitionDomain,
      s = this.workspaceRepository.getWorkspaceById(
        e.workspaceId
      )?.partitionDomain;
    if (i !== s) {
      D.emit("apps-activate-in-workspace", e);
      return;
    }
    let a = r?.id;
    a &&
      !t.shouldNotScrollSidebar &&
      (await this.browserService.scrollSidebarToApp(a, e.id));
    let n = await this.runningApplicationsObserver.getAppTab(e.id);
    if (n?.id) return this.updateExistingAppTab(t, n, e);
    let { isAutofillRequired: p, injectionPermissions: d } =
        this.getAutofillInfo(e),
      {
        startUrl: u,
        partition: m,
        openInGlobalSplit: y,
        shouldBeActive: b,
        appsTabSettings: v,
      } = this.getAppTabParameters(e, t),
      S = await this.extraDataService.createTabExtraData({ app: e.id }),
      w = await this.browserService.createTab({
        active: b,
        url: u,
        extraData: S,
        hidden: !0,
        hideDevTools: p,
        partitionName: m,
        injectionPermissions: d,
        notificationPermission: e.isNotificationEnabled ? "default" : "block",
      });
    return (
      w?.id
        ? (y && (await this.splitViewService.splitAppGlobal(e)),
          await this.browserService.updateTabById({ tabId: w.id, changes: v }),
          this.logger.info("New app activated, tab id", w.id))
        : this.logger.warn("Tab id is empty for newly activated app"),
      this.afterAppActivation(e, w),
      w
    );
  }
  async activateApplicationsAsTab(e, t) {
    this.logger.info(`Activating tab with application data ${e.name}`, t);
    let { isAutofillRequired: r, injectionPermissions: i } =
        this.getAutofillInfo(e),
      { startUrl: s, partition: a } = this.getAppTabParameters(e, t),
      n = await this.browserService.createTab({
        active: !1,
        url: s,
        hideDevTools: r,
        partitionName: a,
        injectionPermissions: i,
      });
    return (
      this.logger.info("New tab with application data activated"),
      this.afterAppActivation(e, n),
      n
    );
  }
  async updateAppAccountPartition(e) {
    let t = this.applicationRepository.getAppById(e);
    if (!t) return;
    let r = this.recipesRepository.getRecipeForApp(t),
      i = this.accountRepository.getCurrentAppAccount(t, r);
    await this.activateApplication(t, {
      accountId: i.id,
      keepReusableTab: !0,
      url: i.startUrl,
      keepInSplit: !0,
    });
  }
  activateApplicationByRecipeId(e) {
    let t = this.applicationRepository.getAppByRecipeId(e);
    return t ? this.activateApplication(t) : Promise.resolve(void 0);
  }
  async updateActiveApp(e, t, r, i) {
    let s = this.accountRepository
        .getAppIdsWithCurrentAccountId(e, r)
        .filter((n) => !i || i.has(n)),
      a = await this.browserService.getAllTabs();
    await Promise.all(
      a.map(async (n) => {
        let p = this.extraDataService.getTabExtraData(n)?.app;
        if (!n.id || !p || !s.includes(p)) return;
        let d = this.applicationRepository.getAppById(p);
        if (!d) return;
        let u = this.accountRepository.getCurrentAppAccount(d, t);
        await this.browserService.updateTabById({
          tabId: n.id,
          changes: { partitionName: u.partition, url: u.startUrl },
        });
      })
    );
  }
  async updatePartitions(e) {
    let t = await this.browserService.getAllTabs();
    await Promise.all(
      t.map(async (r) => {
        let i = r.partitionName;
        if (!r.id || i === "" || i !== e) return;
        let s = this.extraDataService.getTabExtraData(r),
          a = this.getNewPartition(s?.app);
        await this.browserService.updateTabById({
          tabId: r.id,
          changes: { partitionName: a },
        });
      })
    );
  }
  async closeAppTab(e) {
    let t = this.runningApplicationsObserver.getAppTabId(e);
    if (t)
      return (
        this.logger.info(`Closing app ${e}`),
        this.browserService.closeTab(t).catch(l)
      );
  }
  getActivationsByAppId(e) {
    let t = this.applicationRepository.getAppById(e);
    return t
      ? this.activationApplicationStatistic.getActivationsByAppId(t.id)
      : [];
  }
  async activateInSplitPanel() {
    this.logger.info("Activating split panel");
    let e = await this.browserService.getLastFocusedWindowId();
    if (!e) return;
    let t = this.workspaceRepository.getWorkspaceForWindow(e)?.id;
    if (!t) return;
    let i = ((await this.browserStorage.getItem("last-split-panel-app")) ??
      null)?.[t];
    if (i) {
      let u = this.applicationRepository.getAppById(i);
      if (u) {
        this.logger.info("Last split app opens in panel"),
          await this.activateApplication(u, {
            inGlobalSplit: !0,
            keepReusableTab: !0,
            shouldNotScrollSidebar: !0,
          });
        return;
      }
    }
    let s = this.workspaceRepository.getActiveWindowsForWorkspace(t);
    if (
      !(
        Object.values(
          await this.runningApplicationsObserver.getTabsByAppId()
        ).filter((u) => s.includes(u.windowId)).length !== 0
      )
    ) {
      this.logger.info("No apps to split. Split menu will open."),
        this.splitViewService.openSplitViewMenu();
      return;
    }
    let p = this.lastActiveAppTabIdByWorkspaceId[t];
    if (!p) return;
    let d = await this.applicationRepository.getAppByTabId(p);
    d &&
      (this.logger.info(`Opening last active app with tab id ${p}`),
      await this.activateApplication(d, {
        inGlobalSplit: !0,
        keepReusableTab: !0,
        shouldNotScrollSidebar: !0,
      }));
  }
  async updateExistingAppTab(e, t, r) {
    g(t.id, "Update existing app tab failed: no appTab id");
    let i = await this.browserService.getLastFocusedWindowId();
    if (
      !e.keepInSplit &&
      i === t.windowId &&
      (await this.splitViewService.resetGlobalSplitView(t?.id))
    )
      return t;
    let a = await this.browserService.getActiveTab(),
      n = this.browserService.isReusableTab(a?.url) ? a : null,
      p = !e.keepReusableTab;
    n?.id && p && this.browserService.closeTab(n.id).catch(l),
      i &&
        t.windowId !== i &&
        (await this.browserService.moveTab(t.id, -1, i),
        await this.browserService.focusWindow(i));
    let {
        startUrl: u,
        partition: m,
        shouldBeActive: y,
        appsTabSettings: b,
        openInGlobalSplit: v,
      } = this.getAppTabParameters(r, e),
      S = t.partitionName !== m,
      w = Boolean(e.url),
      T = w || S || y;
    if (T) {
      let k = {
        ...b,
        ...(w && { url: u }),
        ...(S && { partitionName: m }),
        ...(y && { active: !0 }),
      };
      await this.browserService.updateTabById({ tabId: t?.id, changes: k });
    }
    return (
      (!T || v) && (await this.splitViewService.splitAppGlobal(r)),
      this.logger.info("Already activated app updated"),
      this.afterAppActivation(r, t),
      t
    );
  }
  getAppTabParameters(e, t) {
    let r = this.recipesRepository.getRecipeForApp(e),
      i = this.billingRepository.canUseSplitView(),
      s = !1;
    i && (s = t.inGlobalSplit || e.showAsSidecarPanelSetting);
    let a = !s,
      n =
        (t.accountId &&
          this.accountRepository.getAccountById(e, r, t.accountId)) ||
        this.accountRepository.getCurrentAppAccount(e, r),
      p = t.url || (r.canChangeStartUrl === !1 ? r.startURL : n.startUrl),
      d = { muted: e.isMuted };
    return {
      startUrl: p,
      partition: n.partition,
      openInGlobalSplit: s,
      shouldBeActive: a,
      appsTabSettings: d,
    };
  }
  closeNotFocusedApps(e) {
    e.forEach(({ id: t }) => {
      this.runningApplicationsObserver.getIsAppActive(t) ||
        this.closeAppTab(t).catch(l);
    });
  }
  getAutofillInfo(e) {
    let t = xr.isAutofillRequired(e);
    return {
      isAutofillRequired: t,
      injectionPermissions: t ? { restricted: !0 } : void 0,
    };
  }
  getNewPartition(e) {
    if (!e) return "";
    let t = this.applicationRepository.getAppById(e);
    if (!t) return "";
    let r = this.recipesRepository.getRecipeForApp(t);
    return this.accountRepository.getCurrentAppAccount(t, r).partition;
  }
  afterAppActivation(e, t) {
    t?.id && (this.lastActiveAppTabIdByWorkspaceId[e.workspaceId] = t.id),
      this.activationApplicationStatistic.markAppAsActivated(e).catch(l),
      D.emit("apps-activated", e.id);
  }
};
c();
var Ac = class {
  constructor(e) {
    this.applicationLocalStore = e;
    this.init().catch(l);
  }
  recordsById = new Map();
  logger = x.createInstance("application_statistics");
  getActivationsByAppId(e) {
    return this.recordsById.get(e)?.visits ?? [];
  }
  async markAppAsActivated(e) {
    let t = await this.applicationLocalStore.upsert(e.id, {
      id: e.id,
      visits: [Date.now()],
    });
    t &&
      (this.recordsById.set(e.id, t),
      this.logger.info("Activated app marked", e.id, t),
      D.emit("activation-statistic-updated", e.id, e, t));
  }
  async init() {
    (await this.applicationLocalStore.getAll()).forEach((t) => {
      t.id && this.recordsById.set(t.id, t);
    }),
      this.logger.info("Application statistics loaded", this.recordsById),
      D.emit("activation-statistic-loaded");
  }
};
c();
c();
var Pc = class {
  constructor(e, t, r, i, s) {
    this.notificationsService = e;
    this.userNotificationsService = t;
    this.teamNotificationsService = r;
    this.featureFlagsRepository = i;
    this.pusherSourceManager = s;
    this.featureFlagsRepository.onFeatureFlagsLoaded((a) => {
      if (
        ((this.useNotificationsV2 = a.fcmEnabled),
        a.fcmEnabled && !this.isFCMUnavailable)
      ) {
        this.stopPusher();
        return;
      }
      this.startPusher().catch(l);
    }),
      this.notificationsService.subscribeToInitializationError(() => {
        (this.isFCMUnavailable = !0), this.startPusher().catch(l);
      });
  }
  useNotificationsV2 = !1;
  isFCMUnavailable = !1;
  subscriptionsV1 = new Set();
  subscribe(e, t, r, i, s = { needsTeamSubscription: !1 }) {
    let a = [];
    return (
      t.forEach((n) => {
        let p = this.notificationsService.subscribe(n, async (d) => {
          this.useNotificationsV2 &&
            (await r({ version: "firebase", type: n, payload: d }));
        });
        a.push(p);
      }),
      e.forEach((n) => {
        let p = () => {
          let d = this.userNotificationsService.subscribe(n, i, async (u) => {
            this.useNotificationsV2 ||
              (await r({
                version: "pusher",
                type: n,
                payload: { ...u, isTeamSubscription: !1 },
              }));
          });
          if ((a.push(d), s.needsTeamSubscription)) {
            let u = this.teamNotificationsService.subscribe(n, i, async (m) => {
              this.useNotificationsV2 ||
                (await r({
                  version: "pusher",
                  type: n,
                  payload: { ...m, isTeamSubscription: !0 },
                }));
            });
            a.push(u);
          }
        };
        this.pusherSourceManager.isConnected() &&
        this.pusherSourceManager.isFirstRun()
          ? p()
          : this.subscriptionsV1.add(p);
      }),
      F(a)
    );
  }
  stopPusher() {
    this.pusherSourceManager.isConnected() && this.pusherSourceManager.stop();
  }
  async startPusher() {
    this.pusherSourceManager.isConnected() ||
      (await this.pusherSourceManager.start(),
      this.pusherSourceManager.isFirstRun() &&
        this.callAllRememberedV1Subscriptions());
  }
  callAllRememberedV1Subscriptions() {
    Array.from(this.subscriptionsV1.values()).map((e) => e());
  }
};
var Rc = class {
  constructor(e, t) {
    this.applicationRepository = e;
    this.notificationsExperimentalLayer = t;
    re.once("workspaces-loaded", (r) => this.onWorkspaceLoaded(r));
  }
  logger = x.createInstance("applications");
  onWorkspaceLoaded(e) {
    e.forEach(({ id: t }) => {
      if (!t) return;
      let r = { uri: ei.getPath(), parentUri: Fr.getPath({ id: t }) };
      this.notificationsExperimentalLayer.subscribe(
        ["created", "updated", "deleted"],
        [
          "workspace.created",
          "workspace.updated",
          "workspace.deleted",
          "app.created",
          "app.updated",
          "app.deleted",
        ],
        ({ version: i, payload: s, type: a }) => {
          if (
            (this.logger.info("Load apps after notification", a),
            i === "firebase" && s.workspace_id === t)
          ) {
            this.applicationRepository.loadApps([t]).catch(l);
            return;
          }
          this.applicationRepository.loadApps([t]).catch(l);
        },
        r
      );
    });
  }
};
c();
c();
c();
var Wr = class {
  isLoadedFromCache = !1;
  getIsLoadedFromCache() {
    return this.isLoadedFromCache;
  }
};
var ot = class extends Wr {
  isLoadedFromNetwork = !1;
  getIsLoadedFromNetwork() {
    return this.isLoadedFromNetwork;
  }
};
c();
var Ot = class {
  static parseUpdateIconResponse(e) {
    return { iconUrl: e.icon, customIconUrl: e.custom_icon };
  }
  static parseApp(e, t) {
    return {
      id: e.uuid,
      workspaceId: e.workspace_id,
      isTeamApp: e.team_service,
      teamCredentialId: e.credential_id,
      isEditable: e.can_edit,
      isRemovable: e.can_delete,
      name: e.data.name ?? e.data.recipeId,
      iconUrl:
        e.data.customIconUrl || t.icons.svg || t.icons.png || e.icon || null,
      sharedToMe: e.shared_to_me,
      sharedByMe: e.shared_by_me,
      wasPrivateBefore: e.data.sessionSandbox,
      sharing: {
        email: e.sharing?.email,
        expirationDate: e.sharing?.expiration_date,
        hasCredentials: e.sharing?.has_credentials || !1,
        credentials:
          e.sharing?.credentials?.map((r) => ({
            data: r.data,
            publicKeyId: r.public_key_id,
            version: r.version,
          })) || [],
      },
      isNotificationEnabled: e.data.isNotificationEnabled,
      showAsSidecarPanelSetting: e.data.showAsSidecarPanelSetting,
      isMuted: e.data.isMuted,
      team: e.data.team,
      keepRunning: e.data.keepRunning,
      customIconUrl: e.data.customIconUrl,
      recoverClosed: e.data.recoverClosed,
      isNotificationBadgeEnabled: e.data.isNotificationBadgeEnabled,
      disableNotificationBadgeNumber: e.data.disableNotificationBadgeNumber,
      disableNotificationMessages: e.data.disableNotificationMessages,
      recipeId: t.id,
      pinnedByWorkspace: e.data.pinnedByWorkspace ?? {},
      savedId: e.data.savedId,
      customUrl: e.data.customUrl,
      syncFocusMode: e.data.syncFocusMode,
      migratedUrl:
        e.recipe_basic?.welcomeURL ||
        e.recipe_basic?.serviceURL ||
        e.data.customUrl,
      unreadMessageCount: null,
      currentAccountId: e.data.defaultAccountId ?? void 0,
      splitViewWidth: e.data.splitViewWidth,
      recipeMetaData: {
        loginURL: e.data.loginURL,
        welcomeURL: e.data.welcomeURL,
        accountsType: e.data.accountsType,
        hasFocusMode: e.data.hasFocusMode,
        shouldOpenInSplitView: t.shouldOpenInSplitView,
      },
    };
  }
  static parseDto(e) {
    return {
      isDarkModeEnabled: !1,
      sessionSandbox: !1,
      customUrl: e.customUrl,
      disableNotificationBadgeNumber: e.disableNotificationBadgeNumber,
      disableNotificationMessages: e.disableNotificationMessages,
      isMuted: e.isMuted,
      isNotificationBadgeEnabled: e.isNotificationBadgeEnabled,
      isNotificationEnabled: e.isNotificationEnabled,
      name: e.name,
      recipeId: e.recipeId,
      recoverClosed: e.recoverClosed,
      showAsSidecarPanelSetting: e.showAsSidecarPanelSetting,
      team: e.team,
      pinnedByWorkspace: e.pinnedByWorkspace,
      savedId: e.savedId,
      keepRunning: e.keepRunning,
      customIconUrl: e.customIconUrl,
      syncFocusMode: e.syncFocusMode,
      splitViewWidth: e.splitViewWidth,
      loginURL: e.recipeMetaData.loginURL,
      welcomeURL: e.recipeMetaData.welcomeURL,
      accountsType: e.recipeMetaData.accountsType,
      hasFocusMode: e.recipeMetaData.hasFocusMode,
    };
  }
  static createApplicationStub(e, t, r, i) {
    return {
      customIconUrl: r?.icon?.src ?? "",
      customUrl: r?.url ?? "",
      migratedUrl: null,
      disableNotificationBadgeNumber: !1,
      disableNotificationMessages: !1,
      iconUrl: r?.icon?.src || t.icons.svg || t.icons.png || null,
      id: le(),
      isEditable: !1,
      isMuted: !1,
      isNotificationBadgeEnabled: !0,
      isNotificationEnabled: !0,
      wasPrivateBefore: !1,
      isRemovable: t.isRemovable ?? !1,
      isTeamApp: !1,
      teamCredentialId: null,
      keepRunning: !1,
      name: t.name,
      recipeId: t.id,
      recoverClosed: !1,
      savedId: null,
      sharedToMe: !1,
      sharedByMe: !1,
      sharing: { hasCredentials: !1, credentials: [] },
      showAsSidecarPanelSetting: Boolean(i),
      pinnedByWorkspace: {},
      team: "",
      unreadMessageCount: null,
      workspaceId: e,
      syncFocusMode: !0,
      splitViewWidth: void 0,
      recipeMetaData: {
        loginURL: t.loginURL,
        welcomeURL: t.welcomeURL,
        accountsType: t.accountsType,
        hasFocusMode: t.hasFocusMode,
        shouldOpenInSplitView: t.shouldOpenInSplitView,
      },
    };
  }
};
var Ec = class extends ot {
  constructor(t, r, i, s) {
    super();
    this.extraDataService = t;
    this.recipesRepository = r;
    this.browserStorage = i;
    this.backendService = s;
    this.loadFromCache().catch(l);
  }
  applicationsById = {};
  logger = x.createInstance("applications");
  getAppsById() {
    return this.applicationsById;
  }
  getAllApps() {
    return Object.values(this.applicationsById);
  }
  getAllCustomApps() {
    return this.getAllApps().filter(
      (t) => t.recipeId === this.recipesRepository.getCustomRecipe().id
    );
  }
  getAppById(t) {
    return this.getAppsById()[t] ?? null;
  }
  getAppByRecipeId(t) {
    return this.getAllApps().find((i) => i.recipeId === t);
  }
  getAppByRecipeIdAndWorkspace(t, r) {
    return this.getAllApps().find(
      (s) => s.recipeId === t && s.workspaceId === r
    );
  }
  async getAppByTabId(t) {
    let r = (await this.extraDataService.getTabExtraDataByTabId(t))?.app;
    return r ? this.getAppById(r) : null;
  }
  getAppByTab(t) {
    let r = this.extraDataService.getTabExtraData(t)?.app;
    return r ? this.getAppById(r) : null;
  }
  getIsApplicationAlreadyAddedByRecipeIdInWorkspace(t, r) {
    return Boolean(this.getAppByRecipeIdAndWorkspace(t, r));
  }
  getAppsByWorkspaceId(t) {
    return Object.values(this.applicationsById).filter(
      (r) => r.workspaceId === t
    );
  }
  getCustomAppsByWorkspaceId(t) {
    return this.getAppsByWorkspaceId(t).filter(
      (r) => r.recipeId === this.recipesRepository.getCustomRecipe().id
    );
  }
  addAppAfterOnboarding(t, r) {
    (this.applicationsById[t.id] = t),
      this.removeAppSilently(r),
      this.updateCache().catch(l);
  }
  addApp(t, r, i = !1, s) {
    (this.applicationsById[t.id] = t),
      s && this.removeAppSilently(s),
      D.emit("apps-added", t.id, t, r, s, i),
      this.updateCache().catch(l);
  }
  updateApp(t, r) {
    let i = this.applicationsById[t];
    if (i)
      return (
        (this.applicationsById[t] = { ...i, ...r }),
        D.emit("apps-changed", i.id, r),
        this.updateCache().catch(l),
        this.applicationsById[t]
      );
  }
  removeApp(t) {
    (this.applicationsById = Ie(this.applicationsById, t)),
      D.emit("apps-removed", t),
      this.updateCache().catch(l);
  }
  async loadApps(t) {
    let i = (
      await this.backendService.applications.getApplications(t.join(","))
    ).map((s) => {
      let a = this.recipesRepository.getRecipeByIdSafely(s.data.recipeId);
      return Ot.parseApp(s, a);
    });
    return this.setStateFromNetwork(i), i;
  }
  async getMigrationCompleteFlag() {
    return this.browserStorage.getItem("applications-safe-recipes");
  }
  setStateFromNetwork(t) {
    let r = Object.values(this.applicationsById).filter((i) => Vy(i.id));
    (this.applicationsById = Object.fromEntries(
      [...t, ...r].map((i) => [i.id, i])
    )),
      (this.isLoadedFromNetwork = !0),
      D.emit("apps-loaded", t),
      this.updateCache().catch(l),
      this.logger.info("Applications loaded", this.applicationsById);
  }
  setMigrationComplete() {
    return this.browserStorage.setItem("applications-safe-recipes", !0);
  }
  removeAppSilently(t) {
    this.applicationsById = Ie(this.applicationsById, t);
  }
  async loadFromCache() {
    let t = await this.browserStorage.getItem("applications");
    t &&
      ((this.applicationsById = t),
      (this.isLoadedFromCache = !0),
      D.emit("apps-loaded", this.getAllApps()));
  }
  updateCache() {
    return this.browserStorage.setItem("applications", this.applicationsById);
  }
};
c();
var Bc = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m, y) {
    this.applicationRepository = e;
    this.recipesRepository = t;
    this.splitViewService = r;
    this.browserService = i;
    this.browserEventsService = s;
    this.accountRepository = a;
    this.accountService = n;
    this.analyticTracker = p;
    this.backendService = d;
    this.runningApplicationsObserver = u;
    this.extraDataService = m;
    this.featureFlagsRepository = y;
    re.on("workspaces-loaded", (b) => {
      this.initApplications(b).catch(l);
    }),
      (this.sendGotBadgeTrackThrottled = Ys(
        this.sendGotBadgeTrack.bind(this),
        ye(1)
      )),
      this.browserEventsService.subscribeToGlobalSplitResized((b, v, S) => {
        let w = this.extraDataService.getTabExtraData({ extraData: S });
        w?.app && this.changeSplitViewWidth(w.app, v);
      });
  }
  logger = x.createInstance("applications");
  sendGotBadgeTrackThrottled;
  async initApplications(e) {
    let t = await this.applicationRepository.loadApps(e.map(({ id: r }) => r));
    return this.migrateApplicationsWithRecipeMixins(t);
  }
  composeAppForAppPopup(e) {
    let t = this.applicationRepository.getAppById(e);
    if (!t) return null;
    let r = this.recipesRepository.getRecipeForApp(t),
      i = this.accountRepository.getCurrentAppAccount(t, r);
    return {
      accounts: this.accountRepository.getAccountsByTypeSorted(t, r),
      app: t,
      currentAccountId: i.id,
      hostnameForSearch: r.hostnameForSearch || Vt(i.startUrl),
      isPinned: !1,
      isRunning: !1,
      isUploadingIcon: !1,
      partitionId: i.partition,
      recipe: r,
    };
  }
  async addNewApp(e, t, r, i, s, a) {
    let n = this.recipesRepository.getNewAppRecipe(r, i),
      p =
        this.featureFlagsRepository.getFeatureFlag("splitViewAppsEnabled") &&
        n?.shouldOpenInSplitView,
      d = this.createStubApp(n, e, t, i, s, a, p),
      u = n.id === Pt.id,
      m;
    return (
      u
        ? (g(
            i,
            "Custom app config is expected in order to create a custom app"
          ),
          (m = await this.addCustomApp(e, d, i, t)),
          this.accountService.switchAccountsFromStubToCustomRealApp(
            m.workspaceId,
            d.id,
            m.id
          ))
        : (m = await this.addApp(n, e, d, t)),
      this.analyticTracker.sendAnalyticsEvent("app.created", {
        "app.name": m.name,
        "app.recipe-id": r,
        "app.custom-url": i?.url,
        "app.is-custom": u,
      }),
      this.accountService.switchCurrentAccountFromStubToRealApp(
        m.workspaceId,
        d.id,
        m.id
      ),
      m.id
    );
  }
  async removeApp(e) {
    return (
      this.applicationRepository.removeApp(e),
      this.backendService.applications.deleteApplicationById(e)
    );
  }
  removeWorkspaceApps(e) {
    this.applicationRepository.getAllApps().forEach((r) => {
      r.workspaceId === e && this.applicationRepository.removeApp(r.id);
    });
  }
  clearPinnedByWorkspace(e) {
    let t = this.applicationRepository.getAppById(e);
    !t ||
      !Object.keys(t.pinnedByWorkspace).length ||
      this.updateApp(e, { pinnedByWorkspace: {} });
  }
  async changeIsNotificationEnabled(e, t) {
    this.updateApp(e, { isNotificationEnabled: t });
    let r = await this.runningApplicationsObserver.getAppTab(e);
    r?.id &&
      (await this.browserService.updateTabById({
        tabId: r.id,
        changes: { notificationPermission: t ? "default" : "block" },
      }));
  }
  changeIsSyncFocusModeEnabled(e, t) {
    this.updateApp(e, { syncFocusMode: t });
  }
  async changeIsMuted(e, t) {
    this.updateApp(e, { isMuted: t });
    let r = this.runningApplicationsObserver.getAppTabId(e);
    r &&
      (await this.browserService.updateTabById({
        tabId: r,
        changes: { muted: t },
      }));
  }
  async changeShowAsSidecarPanel(e, t) {
    this.updateApp(e, { showAsSidecarPanelSetting: t });
    let r = await this.runningApplicationsObserver.getAppTab(e),
      i = this.applicationRepository.getAppById(e);
    t && r?.active && i && (await this.splitViewService.splitAppGlobal(i));
  }
  changeAppName(e, t) {
    this.updateApp(e, { name: Ei(t) });
  }
  changeIcon(e, t) {
    return this.updateAppIcon(e, t);
  }
  resetIcon(e) {
    return this.updateAppIcon(e, null);
  }
  changeDoNotSuspend(e, t) {
    this.updateApp(e, { recoverClosed: t });
  }
  changeSplitViewWidth(e, t) {
    this.updateApp(e, { splitViewWidth: t });
  }
  changeDisableNotificationMessages(e, t) {
    this.updateApp(e, { disableNotificationMessages: t });
  }
  changeNotificationBadgeEnabled(e, t) {
    this.updateApp(e, { isNotificationBadgeEnabled: t });
  }
  changeDisabledNotificationBadgeNumber(e, t) {
    this.updateApp(e, { disableNotificationBadgeNumber: t });
  }
  changeUnreadMessageCount(e, t) {
    this.applicationRepository.updateApp(e, { unreadMessageCount: t }),
      t && this.sendGotBadgeTrackThrottled(e);
  }
  createStubApp(e, t, r, i, s, a, n) {
    let p = Ot.createApplicationStub(t, e, i, n);
    return (
      this.applicationRepository.addApp(p, t, r),
      s
        ? this.accountService.createAccountsForNewApp(p, e, s, a)
        : a && this.accountService.setCurrentAccountForApp(p.id, a),
      p
    );
  }
  async addApp(e, t, r, i) {
    let s = await this.backendService.applications.createApplication({
      workspaceId: t,
      recipeId: e.id,
      recipeMetaData: r.recipeMetaData,
      shouldOpenInSplitView: r.showAsSidecarPanelSetting,
    });
    return this.switchStubAppToReal(t, s, r, i);
  }
  async addCustomApp(e, t, r, i = !1) {
    let s = await this.backendService.applications.createCustomApplication({
        workspaceId: e,
        applicationStub: t,
        customIcon: r.icon ? { src: r.icon.src, name: r.icon.name } : void 0,
      }),
      { customIconUrl: a } = Ot.parseUpdateIconResponse(s),
      n = { ...s, data: { ...s.data, customIconUrl: a } };
    return this.switchStubAppToReal(e, n, t, i);
  }
  switchStubAppToReal(e, t, r, i = !1) {
    let s = this.recipesRepository.getRecipeByIdSafely(r.recipeId),
      a = Ot.parseApp(t, s);
    return this.applicationRepository.addApp(a, e, i, r.id), a;
  }
  async updateAppIcon(e, t) {
    let { iconUrl: r, customIconUrl: i } = Ot.parseUpdateIconResponse(
      await this.backendService.applications.updateApplicationIconById({
        id: e,
        icon: t,
      })
    );
    this.applicationRepository.updateApp(e, { iconUrl: r, customIconUrl: i });
  }
  updateApp(e, t) {
    let r = this.applicationRepository.updateApp(e, t);
    r &&
      this.backendService.applications
        .updateApplicationById({ id: e, changes: Ot.parseDto(r) })
        .catch(l);
  }
  async migrateApplicationsWithRecipeMixins(e) {
    return (await this.applicationRepository.getMigrationCompleteFlag())
      ? Promise.resolve()
      : (e.forEach(({ id: r, recipeId: i }) => {
          let {
              loginURL: s,
              welcomeURL: a,
              accountsType: n,
              hasFocusMode: p,
            } = this.recipesRepository.getRecipeByIdSafely(i),
            d = {
              loginURL: s,
              welcomeURL: a,
              accountsType: n,
              hasFocusMode: p,
            };
          this.updateApp(r, { recipeMetaData: d });
        }),
        this.logger.info("Applications recipe data migrated"),
        this.applicationRepository.setMigrationComplete());
  }
  sendGotBadgeTrack(e) {
    let t = this.applicationRepository.getAppById(e);
    t &&
      this.analyticTracker.sendAnalyticsEvent("app.got-badge", {
        "app.recipe-id": t.recipeId,
      });
  }
};
c();
c();
c();
var bE = (o) => {
    if (!/^\d+$/.test(o)) return NaN;
    let e = Number(o);
    return e >= 0 && e <= 255 ? e : NaN;
  },
  gE = (o) => {
    let e = o.split(".");
    if (e.length !== 4) return;
    let t = e.map(bE);
    if (t.every((r) => !Number.isNaN(r))) return t;
  };
var Cc = "*",
  vE = (o) => o.slice(o.findIndex(Boolean)),
  ps = class {
    parents;
    subdomains;
    name;
    static fromUrl(e) {
      let t = e.split("/"),
        r = t
          .slice(1)
          .filter((s) => s !== "#" && s.length)
          .reverse(),
        i = t[0] ?? "";
      return this.fromHostname(i, r);
    }
    static fromHostname(e, t) {
      let r = gE(e);
      if (r) return new this([r.join(".")]);
      let i = vE(e.split(".").reverse());
      i[0] === "com" && (i = [Cc, ...i.slice(1)]);
      let s = [...t, ...i];
      return new this(s);
    }
    constructor(e) {
      if (e.length === 0)
        throw new Error("Expected subdomains to have at least 1 item");
      (this.subdomains = e),
        (this.parents = e.slice(0, -1)),
        (this.name = e[e.length - 1]),
        Object.freeze(this);
    }
  };
var _c = Symbol("All subdomains included"),
  Fc = class {
    root = new Map();
    static fromHostnames(e) {
      let t = new this();
      return (
        e.forEach((r) => {
          t.addHostname(r);
        }),
        t
      );
    }
    addHostname(e) {
      return this.add(ps.fromUrl(e));
    }
    hasHostnameOrFullUrl(e, t) {
      return this.hasUrl(e) || this.hasUrl(e + t);
    }
    hasUrl(e) {
      return this.has(ps.fromUrl(e));
    }
    add(e) {
      let t = this.ensureBranch(e.parents);
      return t === void 0 || (e.name && t.get(e.name) === _c)
        ? !1
        : (e.name && t.set(e.name, _c), !0);
    }
    ensureBranch(e) {
      let t = this.root;
      for (let r of e) {
        let i;
        if (t.has(r)) {
          if (((i = t.get(r)), i === _c)) return;
        } else (i = new Map()), t.set(r, i);
        i && (t = i);
      }
      return t;
    }
    has(e) {
      let t = this.root;
      for (let r of e.subdomains) {
        let i;
        if (t.has(r)) i = t.get(r);
        else if (t.has(Cc)) i = t.get(Cc);
        else return !1;
        if (i === _c) return !0;
        i && (t = i);
      }
      return !1;
    }
  };
var Mc = class {
  constructor(e, t, r, i, s, a, n, p, d) {
    this.extraDataService = e;
    this.browserService = t;
    this.accountService = i;
    this.accountRepository = s;
    this.featureFlagsRepository = p;
    this.runningApplicationsObserver = d;
    r.subscribeToTabUpdated(async (u, m, y) => {
      if (!m.url) return;
      let b = e.getTabExtraData(y)?.app;
      if (!b) return;
      let v = n.getAppById(b);
      if (!v) return;
      let S = a.getRecipeForApp(v);
      this.tryAuthorizeAccount(v, S, m.url),
        await this.tryRemoveAppTab(v, S, m.url, y);
    });
  }
  accountTypesToCheck = ["gsuite"];
  logger = x.createInstance("applications");
  tryAuthorizeAccount(e, t, r) {
    this.shouldCheckAccountType(t) &&
      this.tabMatchesStartUrl(t, r) &&
      this.accountService.authorizeAccount(e, t);
  }
  shouldCheckAccountType(e) {
    return Boolean(
      e.accountsType && this.accountTypesToCheck.includes(e.accountsType)
    );
  }
  tabMatchesStartUrl(e, t) {
    return (
      t.startsWith(qs(e.startURL)) ||
      Boolean(e.welcomeURL && t.startsWith(e.welcomeURL))
    );
  }
  async tryRemoveAppTab(e, t, r, i) {
    return this.getShouldKeepTabApp(r, e, t)
      ? Promise.resolve()
      : this.removeAppTab(i);
  }
  getShouldKeepTabApp(e, t, r) {
    let i = Gt(e);
    if (!i) return !1;
    let { hostname: s, pathname: a } = i;
    if (a === "/search" && s.endsWith("google.com")) return !1;
    if (["sidekick-extension:", "chrome-extension:"].includes(i.protocol))
      return !0;
    let p = this.getTrustedHosts(t, r);
    return Fc.fromHostnames(p).hasHostnameOrFullUrl(s, a);
  }
  getTrustedHosts(e, t) {
    let r = t.id === Pt.id,
      i = this.accountRepository.getCurrentAppAccount(e, t).startUrl,
      s = Gt(i)?.hostname ?? i,
      a =
        this.featureFlagsRepository.getFeatureFlags().globalAuthDomains.domains;
    if (r) return [rb(s) || s, ...a];
    let { authDomains: n = [] } = t;
    return [s, ...n, ...a];
  }
  async removeAppTab(e) {
    if (!e.id) return;
    let t = this.extraDataService.getTabExtraData(e);
    await this.browserService.updateTabById({
      tabId: e.id,
      changes: { hidden: !1, extraData: JSON.stringify(Ie(t, ["app"])) },
    }),
      this.runningApplicationsObserver.onTabDetachedFromApp(e.id, e.windowId),
      this.logger.info(
        `Tab ${e.id} was detached from app ${t?.app ?? "no app id present"}`
      );
  }
};
c();
var xc = class {
  constructor(e, t, r, i, s) {
    this.recipesRepository = e;
    this.accountService = t;
    this.applicationService = r;
    this.applicationRepository = i;
    this.backendService = s;
  }
  async addAppsAfterOnboarding(e, t) {
    let r = [];
    if (
      (t.forEach((s) => {
        let a = this.recipesRepository.getRecipeByIdSafely(s.id);
        if (a.id === this.recipesRepository.getCustomRecipe().id) return;
        let n = !0,
          p = this.addStubAppAfterOnboarding(e, a, s, n);
        r.push({ recipe: a, stub: p, isPinned: n });
      }),
      !r.length)
    )
      return;
    let i = (
      await this.backendService.applications.createApplicationBulk({
        workspaceId: e,
        recipes: r.map((s) => ({
          recipeId: s.recipe.id,
          recipeMetaData: s.stub.recipeMetaData,
          shouldOpenInSplitView: s.recipe.shouldOpenInSplitView,
        })),
      })
    ).reduce((s, a, n) => {
      let p = r[n];
      if (!p) return s;
      let d = Ot.parseApp(a, p.recipe);
      return (
        this.applicationRepository.addAppAfterOnboarding(d, p.stub.id),
        this.accountService.switchCurrentAccountFromStubToRealApp(
          d.workspaceId,
          p.stub.id,
          d.id
        ),
        s.push({ app: d, ...p }),
        s
      );
    }, []);
    D.emit("apps-added-after-onboarding", i);
  }
  addStubAppAfterOnboarding(e, t, r, i) {
    let s = this.accountService.createBaseAccountsForOnboardingApp(
      t,
      r.teamIds
    );
    return this.applicationService.createStubApp(t, e, i, void 0, s);
  }
};
c();
var Wc = class {
  constructor(e) {
    this.iconsResolver = e;
    this.recipesById = {};
  }
  customRecipe = { ...Pt, icons: {} };
  logger = x.createInstance("recipes");
  recipesById;
  getCustomRecipe() {
    return this.customRecipe;
  }
  getRecipes() {
    return Object.values(this.recipesById);
  }
  getPopularRecipes() {
    return this.getRecipes().filter(
      (e) => e.onboardingGrade !== void 0 && e.onboardingGrade > 0
    );
  }
  getRecipeByIdSafely(e) {
    return e ? this.recipesById[e] ?? this.customRecipe : this.customRecipe;
  }
  getRecipeForApp({ recipeId: e, recipeMetaData: t }) {
    let r = this.recipesById[e];
    return r || { ...this.customRecipe, ...t, id: e };
  }
  getNewAppRecipe(e, t) {
    let r = this.getRecipeByIdSafely(e);
    return r.id !== this.customRecipe.id
      ? r
      : { ...r, name: t?.name ?? "", startURL: t?.url ?? "" };
  }
  async loadRecipes() {
    await Promise.all(
      Object.values(Pb).map(async (e) => {
        this.recipesById[e.id] = await this.mapSchemaToRecipe(e);
      })
    ),
      this.logger.info("Recipes loaded", this.recipesById);
  }
  async mapSchemaToRecipe(e) {
    return { ...e, icons: await this.iconsResolver.getPath(e.id) };
  }
};
c();
var Dc = class {
  constructor(e, t, r, i) {
    this.extraDataService = e;
    this.browserService = t;
    Object.values(i).forEach((s) => {
      s.tabs?.forEach((a) => {
        let n = e.getTabExtraData(a)?.app;
        a.id &&
          n &&
          ((this.tabsByAppId[n] = a.id),
          a.active && s.id && (this.activeAppByWindowId[s.id] = n));
      });
    }),
      r.subscribeToTabCreated(this.onTabCreated.bind(this)),
      r.subscribeToTabUpdated(this.onTabUpdated.bind(this)),
      r.subscribeToTabRemoved(this.onTabRemoved.bind(this)),
      r.subscribeToTabReplaced(this.onTabReplaced.bind(this)),
      r.subscribeToTabActivated(this.onTabActivated.bind(this)),
      r.subscribeToWindowRemoved(this.onWindowRemoved.bind(this)),
      D.on("apps-added", (s, a, n, p) => {
        p && this.updateStubAppTab(s, p).catch(l);
      });
  }
  tabsByAppId = {};
  activeAppByWindowId = {};
  getAppIdByTabId(e) {
    return this.findAppId(e);
  }
  getAppTabId(e) {
    return this.tabsByAppId[e];
  }
  getIsRunningApp(e) {
    return Boolean(this.getAppTabId(e));
  }
  getAppTab(e) {
    let t = this.tabsByAppId[e];
    return t ? this.browserService.getTabById(t) : Promise.resolve(void 0);
  }
  async getTabsByAppId() {
    let e = await this.browserService.getAllTabs(),
      t = {};
    return (
      e.forEach((r) => {
        let i = this.extraDataService.getTabExtraData(r)?.app;
        i && (t[i] = r);
      }),
      t
    );
  }
  getActiveAppId(e) {
    return this.activeAppByWindowId[e];
  }
  getIsAppActive(e) {
    let t = Object.values(this.activeAppByWindowId);
    return Boolean(t.find((r) => r === e));
  }
  onTabDetachedFromApp(e, t) {
    this.removeAppInfo(e, t);
  }
  onTabCreated(e) {
    let t = this.extraDataService.getTabExtraData(e)?.app;
    if (t && this.tabsByAppId[t]) {
      this.browserService
        .createTab({
          url: e.url || e.pendingUrl || "",
          active: e.active,
          index: e.index,
        })
        .catch(l),
        e.id && this.browserService.closeTab(e.id).catch(l);
      return;
    }
    this.addAppInfo(e);
  }
  onTabUpdated(e, t, r) {
    if (t.hidden === !1) {
      this.removeAppInfo(e, r.windowId);
      return;
    }
    !oe(t, "status") || t.status !== "loading" || this.updateAppInfo(r);
  }
  onTabRemoved(e) {
    this.removeAppInfo(e);
  }
  onTabReplaced(e, t) {
    let r = this.findAppId(t);
    r && (this.tabsByAppId[r] = e);
  }
  addAppInfo(e) {
    let t = this.extraDataService.getTabExtraData(e)?.app;
    !t || !e.id || (this.tabsByAppId[t] = e.id);
  }
  updateAppInfo(e) {
    if (!e.id) return;
    let t = this.extraDataService.getTabExtraData(e)?.app;
    if (!t) {
      this.removeAppInfo(e.id, e.windowId);
      return;
    }
    this.tabsByAppId[t] = e.id;
  }
  removeAppInfo(e, t) {
    let r = this.findAppId(e);
    r &&
      (delete this.tabsByAppId[r],
      t && delete this.activeAppByWindowId[t],
      D.emit("apps-closed", r));
  }
  onTabActivated(e) {
    let t = this.findAppId(e.tabId);
    t
      ? (this.activeAppByWindowId[e.windowId] = t)
      : delete this.activeAppByWindowId[e.windowId];
  }
  onWindowRemoved(e) {
    delete this.activeAppByWindowId[e];
  }
  findAppId(e) {
    return Object.keys(this.tabsByAppId).find((t) => this.tabsByAppId[t] === e);
  }
  async updateStubAppTab(e, t) {
    let r = await this.getAppTab(t);
    if (!r?.id) return;
    let i = this.extraDataService.getTabExtraData(r),
      s = await this.extraDataService.createTabExtraData({ ...i, app: e });
    this.activeAppByWindowId[r.windowId] === t &&
      (this.activeAppByWindowId[r.windowId] = e),
      (this.tabsByAppId[e] = r.id),
      delete this.tabsByAppId[t],
      await this.browserService.updateTabById({
        tabId: r.id,
        changes: { extraData: s },
      });
  }
};
var TS = async (o, e, t, r, i, s, a, n, p, d, u, m) => {
  let y = new vc(o),
    b = new Wc(y);
  await b.loadRecipes();
  let v = new Dc(e, o, i, m),
    S = new Ec(e, b, r, p),
    w = new fc(o, a, i, r, S, v, u, e),
    T = new Tc(r, b),
    I = new wc(r, b),
    k = new kc(b, S, I, o, a, T, d, u),
    _ = new Bc(S, b, w, o, i, I, k, a, p, v, e, s),
    O = new xc(b, k, _, S, p),
    E = new Ac(n),
    f = new Ic(S, b, o, e, w, I, E, v, d, r, u);
  return (
    new Rc(S, t),
    new Mc(e, o, i, k, I, b, S, s, v),
    {
      applicationRepository: S,
      applicationService: _,
      applicationsActivationService: f,
      recipesRepository: b,
      accountRepository: I,
      accountService: k,
      onboardingAppsService: O,
      splitViewService: w,
      runningApplicationsObserver: v,
    }
  );
};
c();
c();
var Uc = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m) {
    this.billingRepository = e;
    this.billingService = t;
    this.applicationRepository = r;
    this.workspaceRepository = i;
    this.accountRepository = s;
    this.recipesRepository = a;
    this.billingPriceService = n;
    this.invitationsService = p;
    this.sessionRepository = d;
    this.userApi = u;
    this.featureFlagsRepository = m;
    this.startTrial().catch(l);
  }
  getMonthlyPrice() {
    return this.billingPriceService.getPlansForUpgrade().monthlyPlan
      .monthlyPrice;
  }
  getYearlyPlan() {
    return this.billingPriceService.getPlansForUpgrade().yearlyPlan;
  }
  getPlansForUpgrade() {
    return this.billingPriceService.getPlansForUpgrade();
  }
  startPlanUpgrade(e) {
    return this.billingPriceService.startPlanUpgrade(e);
  }
  startPersonalPlanUpgrade(e) {
    return this.billingPriceService.startPersonalPlanUpgrade(e);
  }
  startTeamPlanUpgrade(e) {
    return this.billingPriceService.startTeamPlanUpgrade(e);
  }
  openPaidTrialPortal() {
    return this.billingService.openPaidTrialPortal();
  }
  showInvitationsPopup() {
    return this.invitationsService.showInvitationsPopup();
  }
  startInvitesBonusTime() {
    return this.invitationsService.startInvitesBonusTime();
  }
  canAddAppToWorkspaceByWindow(e) {
    let t = this.workspaceRepository.getWorkspaceIdForWindow(e);
    return t ? this.canAddAppToWorkspace(t) : !1;
  }
  canAddAppToWorkspace(e) {
    let t = this.applicationRepository.getAppsByWorkspaceId(e).length;
    return this.billingRepository.canAddApp(t);
  }
  canAddAccount(e) {
    let t = this.recipesRepository.getRecipeForApp(e),
      r = this.accountRepository.getAccountsByTypeSorted(e, t);
    return this.billingRepository.canAddAccount(r.length);
  }
  canAddWorkspace() {
    let e = this.workspaceRepository.getWorkspacesArray().length;
    return this.billingRepository.canAddWorkspace(e);
  }
  canOpenWorkspace(e) {
    return this.billingRepository.canOpenWorkspace(e);
  }
  canPinApp(e) {
    let t = this.workspaceRepository.getPinnedCountById(e);
    return this.billingRepository.canPinApp(t);
  }
  canOpenLaunchpadApp(e) {
    return this.billingRepository.canOpenLaunchpadApp(e);
  }
  canOpenSidebarApp(e) {
    return this.billingRepository.canOpenSidebarApp(e);
  }
  openUpgradePlanTab(e) {
    return this.billingService.openUpgradePlanTab(e);
  }
  openCustomerPortal() {
    return this.billingService.openCustomerPortal();
  }
  startTrial() {
    return this.billingService.startTrial();
  }
  loadInvitationsStats() {
    return this.invitationsService.loadInvitationsStats();
  }
  openTeamUpgradePlanTab(e) {
    return this.billingService.openTeamUpgradePlanTab(e);
  }
  deleteTeamPlanSubscription(e) {
    return this.billingService.deleteTeamPlanSubscription(e);
  }
  showLimitPopupIfBlocked(e, t) {
    return e() ? !1 : (this.showLimitPopup(t).catch(l), !0);
  }
  showLimitPopup(e) {
    return this.billingService.showLimitPopup(e);
  }
  canAddSession(e) {
    if (
      this.userApi.getSettings().wasSessionsEnabled &&
      this.featureFlagsRepository.getFeatureFlag("sessionsForOldUsersEnabled")
    )
      return !0;
    let r = this.workspaceRepository.getWorkspaceForWindow(e);
    return (
      g(r, "Workspace id is required for session window"),
      this.billingRepository.canAddSessions(
        this.sessionRepository.getSessionsByWorkspaceId(r.id)?.length ?? 1
      )
    );
  }
  canEditSession(e) {
    if (
      this.userApi.getSettings().wasSessionsEnabled &&
      this.featureFlagsRepository.getFeatureFlag("sessionsForOldUsersEnabled")
    )
      return !0;
    let r = this.sessionRepository.getSessionLastUsedIndexById(
      e.id,
      e.workspaceId
    );
    return this.billingRepository.canEditSessions(r);
  }
  canUseSessions() {
    let e = this.billingRepository.getIsPro(),
      t = this.featureFlagsRepository.getFeatureFlag(
        "sessionsForOldUsersEnabled"
      ),
      { wasSessionsEnabled: r } = this.userApi.getSettings();
    return e || ((r ?? !1) && t);
  }
  getMaxSessionsAvailable() {
    let e =
        this.billingRepository.getBillingPlan()?.planOptions
          .sessionsPerWorkspaceLimit,
      t = this.userApi.getSettings().wasSessionsEnabled,
      r = this.featureFlagsRepository.getFeatureFlag(
        "sessionsForOldUsersEnabled"
      );
    return t && r ? null : e;
  }
  canOpenSession(e) {
    return (this.getMaxSessionsAvailable() ?? 1 / 0) > e;
  }
  showBillingPlanHasExpiredModal(e) {
    return this.billingService.showBillingPlanHasExpiredModal(e);
  }
  showBillingPlanExpireSoonModal(e) {
    return this.billingService.showBillingPlanExpireSoonModal(e);
  }
  disableShowingPaidTrialModal() {
    this.billingService.updateCounterForPaidTrialModal(0);
  }
  updatePaidTrialModalShowedDay() {
    this.billingService.paidTrialModalShowedDay();
  }
  dismissCancelDiscountOffer() {
    this.billingService.dismissCancelDiscountOffer();
  }
  claimCancelDiscountOffer() {
    return this.billingService.claimCancelDiscountOffer();
  }
};
c();
var Oc = class {
  constructor(e, t, r) {
    this.backendService = e;
    this.billingPlansRepository = t;
    this.notificationsExperimentalLayer = r;
  }
  init() {
    return (
      this.notificationsExperimentalLayer.subscribe(
        ["updated"],
        ["billing_plans.updated"],
        async () => {
          await this.reloadBillingPlans();
        },
        { uri: Qo.getPath() }
      ),
      this.reloadBillingPlans()
    );
  }
  async reloadBillingPlans() {
    let e = await this.backendService.extension.getBillingPlans(),
      t = {
        freePlan: this.mapDtoToPlan(e.free_plan),
        proMonthlyPlan: this.mapDtoToPlan(e.pro_monthly_plan),
        proYearlyPlan: this.mapDtoToPlan(e.pro_yearly_plan),
        proMonthlyDiscountPlan: this.mapNullableDtoToPlan(
          e.pro_monthly_discount_offer
        ),
        proYearlyDiscountPlan: this.mapNullableDtoToPlan(
          e.pro_yearly_discount_offer
        ),
        progressiveDiscountOffer: this.mapNullableDtoToPlan(
          e.progressive_discount_offer
        ),
        afterTrialDiscountOffer: this.mapNullableDtoToPlan(
          e.after_trial_discount_offer
        ),
        cancelDiscountOffer: this.mapNullableDtoToPlan(e.cancel_discount_offer),
        teamFreePlan: this.mapDtoToPlan(e.team_free_plan),
        teamProMonthlyPlan: {
          ...this.mapDtoToPlan(e.team_pro_monthly_plan),
          usersBreakpoint:
            e.team_pro_monthly_plan.price_schema?.[0]?.limit ?? 0,
          priceLessThanBreakpoint:
            e.team_pro_monthly_plan.price_schema?.[0]?.amount ?? 0,
          priceMoreThanBreakpoint:
            e.team_pro_monthly_plan.price_schema?.[1]?.amount ?? 0,
        },
        enterprisePlan: e.enterprise_request
          ? { url: e.enterprise_request.url }
          : void 0,
      };
    this.billingPlansRepository.setStateFromNetwork(t);
  }
  mapNullableDtoToPlan(e) {
    if (e) return this.mapDtoToPlan(e);
  }
  mapDtoToPlan(e) {
    return {
      planId: e.plan_id,
      currency: e.currency ?? null,
      price: e.price ?? null,
      monthlyPrice: e.price_per_month ?? null,
    };
  }
};
c();
var gh = "after-trial-discount-alarm",
  jc = class {
    constructor(e, t, r, i, s, a, n, p, d) {
      this.featureFlagsRepository = e;
      this.billingRepository = t;
      this.userApi = r;
      this.userSettingsRepository = i;
      this.modalService = s;
      this.browserStorage = a;
      this.browserService = n;
      this.browserEventsService = p;
      this.billingPlansRepository = d;
      let u = () => {
        this.tryStartDiscountBeforeTrialEnds(),
          this.tryStartDiscountAfterTrialEnds().catch(l),
          this.tryOpenCancelDiscountOfferModal().catch(l);
      };
      se.onSeveral(["billing-plan-loaded", "billing-plans-loaded"], u),
        e.onFeatureFlagsLoaded(u),
        p.subscribeToAlarm((m) => {
          m.name === gh && this.tryStartDiscountAfterTrialEnds(!0).catch(l);
        }),
        u();
    }
    currentDiscountMode = null;
    timeoutForStartingDiscount = void 0;
    intervalForShowingDiscountModal = void 0;
    timeoutForShowingDiscountModal = void 0;
    getPlansForUpgrade() {
      return (
        this.getSpecialDiscountPlans() ??
        this.getExperimentalPlans() ??
        this.getDefaultPlans()
      );
    }
    startPlanUpgrade(e) {
      return this.billingRepository.getIsTeam()
        ? this.startTeamPlanUpgrade(e)
        : this.startPersonalPlanUpgrade(e);
    }
    startPersonalPlanUpgrade(e) {
      return this.getIsDiscountActive()
        ? this.openSpecialUpgradeModal()
        : this.modalService.showUpgradePlanModal(e);
    }
    startTeamPlanUpgrade(e) {
      return this.openTeamUpgradeModal(e);
    }
    setAlarmForDiscount(e, t) {
      let { daysAfterTrialEndToShow: r } =
          this.featureFlagsRepository.getFeatureFlag("afterTrialDiscountOffer"),
        i = e + ce(t),
        s = pt(r),
        a = i + s;
      return this.browserService.createAlarm(gh, { when: a });
    }
    openSpecialUpgradeModal() {
      return this.currentDiscountMode
        ? this.currentDiscountMode === "afterTrialDiscountOffer"
          ? this.openDiscountModal()
          : this.billingRepository.getIsTrial()
          ? this.openDiscountModal()
          : this.openLastChanceOfferModal()
        : Promise.resolve();
    }
    openTeamUpgradeModal({ source: e }) {
      let t = this.billingRepository.getIsPro(),
        r = this.billingRepository.getIsTrial()
          ? this.billingRepository.getSubscriptionTimeLeftDays()
          : null,
        i = this.billingPlansRepository.getTeamProPlan(),
        s = this.billingPlansRepository.getTeamEnterprisePlan();
      if (!i || !s)
        return l(new L("No team plans for open modal")), Promise.resolve();
      let a = {
          usersBreakpoint: i.usersBreakpoint,
          lessThanBreakpointPrice: i.priceLessThanBreakpoint,
          moreThanBreakpointPrice: i.priceMoreThanBreakpoint,
        },
        n = this.billingRepository.getBillingPlan(),
        p = t
          ? {
              ["shared-apps"]: ns["shared-apps"],
              ["pre-installed-apps"]: ns["pre-installed-apps"],
            }
          : {
              ["shared-apps"]: n?.planOptions.appSharingLimit ?? null,
              ["pre-installed-apps"]:
                n?.planOptions.preInstalledAppsLimit ?? null,
            };
      return this.modalService.showTeamUpgradePlanModal({
        source: e,
        currentPlan: t ? "pro" : "free",
        trialTimeLeftDays: r,
        enterpriseContactUrl: s.url,
        price: a,
        freeLimits: p,
      });
    }
    openDiscountModal() {
      return this.modalService.showBillingDiscountModal(
        this.getDiscountModalPayload()
      );
    }
    openLastChanceOfferModal() {
      return this.modalService.showBillingLastChanceModal(
        this.getLastChanceOfferModalPayload()
      );
    }
    openCancelDiscountOfferModal() {
      let e = this.getCancelDiscountOfferModalPayload();
      return this.modalService.showCancelDiscountOfferModal(e);
    }
    getIsDiscountActive() {
      if (!this.currentDiscountMode || !this.isDiscountTimerAlreadySet())
        return !1;
      let { showingPeriodHours: t } = this.getDiscountConfig(
        this.currentDiscountMode
      );
      return this.getDiscountRemainingMS(t) > 0;
    }
    tryStartDiscountBeforeTrialEnds() {
      if (this.currentDiscountMode === "afterTrialDiscountOffer") return;
      let e = this.featureFlagsRepository.getFeatureFlag(
          "isProgressiveDiscountOfferEnabled"
        ),
        {
          showForNotTrial: t,
          showingPeriodHours: r,
          daysBeforeTrialEndToShow: i,
        } = this.featureFlagsRepository.getFeatureFlag(
          "progressiveDiscountOffer"
        ),
        a =
          this.isDiscountTimerAlreadySet() &&
          this.getDiscountRemainingMS(r) <= 0,
        n = this.billingRepository.getIsTrial(),
        p = this.billingPlansRepository.getProgressiveDiscountOfferPlan();
      if (this.billingRepository.getIsTeam() || !e || a || !p) {
        this.disableDiscount();
        return;
      }
      if (n) {
        let u = this.billingRepository.getSubscriptionTimeLeftDays();
        if (u === null) {
          this.disableDiscount();
          return;
        }
        let m = u - i;
        if (m > 0) {
          if (this.timeoutForStartingDiscount) return;
          this.timeoutForStartingDiscount = setTimeout(() => {
            this.tryStartDiscountAfterTrialEnds().catch(l);
          }, pt(m));
          return;
        }
      } else {
        let u = this.billingRepository.getIsPaid();
        if (!t || !u) {
          this.disableDiscount();
          return;
        }
      }
      (this.currentDiscountMode = "progressiveDiscountOffer"),
        this.startDiscountTimerIfNotExists(),
        this.startDiscountModalShowingInterval().catch(l);
    }
    async tryStartDiscountAfterTrialEnds(e = !1) {
      if (
        (this.currentDiscountMode === "progressiveDiscountOffer" && !e) ||
        (!e && (await this.browserService.getAlarmByName(gh)))
      )
        return;
      let t = this.featureFlagsRepository.getFeatureFlag(
          "afterTrialDiscountOfferEnabled"
        ),
        { showingPeriodHours: r } = this.getDiscountConfig(
          "afterTrialDiscountOffer"
        ),
        i = this.isDiscountTimerAlreadySet(),
        s = e ? !1 : i && this.getDiscountRemainingMS(r) <= 0,
        a = this.billingRepository.getBillingPlan(),
        n =
          Boolean(a) &&
          !this.billingRepository.getIsPro() &&
          a?.options.isTrialExpired,
        p = this.billingPlansRepository.getAfterTrialDiscountOffer();
      if (this.billingRepository.getIsTeam() || !t || s || !n || !p) {
        (this.currentDiscountMode = null), this.disableDiscount();
        return;
      }
      e
        ? (this.disableDiscount(), this.startDiscountTimer())
        : this.startDiscountTimerIfNotExists(),
        (this.currentDiscountMode = "afterTrialDiscountOffer"),
        this.startDiscountModalShowingInterval().catch(l);
    }
    async startDiscountModalShowingInterval() {
      if (!this.currentDiscountMode) return;
      let e =
          (await this.browserStorage.getItem(
            "billing-discount-modal-showed-at"
          )) ?? 0,
        { showingIntervalHours: t } = this.getDiscountConfig(
          this.currentDiscountMode
        ),
        r = xe(t),
        i = Date.now() - e,
        s = i >= r,
        a = s ? r : r - i;
      if (s) {
        if (
          (this.tryShowDiscountModalWithSaving().catch(l),
          this.intervalForShowingDiscountModal)
        )
          return;
        this.intervalForShowingDiscountModal = setInterval(() => {
          this.tryShowDiscountModalWithSaving().catch(l);
        }, r);
        return;
      }
      this.timeoutForShowingDiscountModal ||
        (this.timeoutForShowingDiscountModal = setTimeout(() => {
          this.tryShowDiscountModalWithSaving().catch(l),
            this.startDiscountModalShowingInterval().catch(l);
        }, a));
    }
    tryShowDiscountModalWithSaving() {
      if (!this.getIsDiscountActive())
        return this.disableDiscount(), Promise.resolve();
      let e = Date.now();
      return Promise.all([
        this.openSpecialUpgradeModal(),
        this.browserStorage.setItem("billing-discount-modal-showed-at", e),
      ]);
    }
    tryOpenCancelDiscountOfferModal() {
      return !this.featureFlagsRepository.getFeatureFlags()
        .cancelDiscountOfferEnabled ||
        !this.billingPlansRepository.getIsLoadedFromNetwork() ||
        !this.billingPlansRepository.getCancelDiscountOffer() ||
        !this.billingRepository.getCancelAt()
        ? Promise.resolve()
        : this.openCancelDiscountOfferModal();
    }
    disableDiscount() {
      (this.currentDiscountMode = null),
        this.timeoutForStartingDiscount &&
          clearTimeout(this.timeoutForStartingDiscount),
        this.timeoutForShowingDiscountModal &&
          clearTimeout(this.timeoutForShowingDiscountModal),
        this.intervalForShowingDiscountModal &&
          clearInterval(this.intervalForShowingDiscountModal);
    }
    startDiscountTimerIfNotExists() {
      this.isDiscountTimerAlreadySet() || this.startDiscountTimer();
    }
    startDiscountTimer(e = Date.now()) {
      this.userApi.setDiscountStartTimestamp(e);
    }
    isDiscountTimerAlreadySet() {
      let { discountStartTimestamp: e } =
        this.userSettingsRepository.getGlobalUserSettings();
      return e > 0;
    }
    getDiscountRemainingMS(e) {
      let t = xe(e),
        r = this.getTimeAfterDiscountStartMs();
      return t - r;
    }
    getTimeAfterDiscountStartMs() {
      let { discountStartTimestamp: e } =
        this.userSettingsRepository.getGlobalUserSettings();
      return Date.now() - e;
    }
    getDiscountConfig(e) {
      return this.featureFlagsRepository.getFeatureFlag(e);
    }
    getPlanForDiscount(e) {
      return e === "afterTrialDiscountOffer"
        ? this.billingPlansRepository.getAfterTrialDiscountOffer()
        : this.billingPlansRepository.getProgressiveDiscountOfferPlan();
    }
    getSpecialDiscountPlans() {
      if (!this.getIsDiscountActive() || !this.currentDiscountMode) return;
      let { monthlyPlan: e } = this.getDefaultPlans(),
        t = this.getPlanForDiscount(this.currentDiscountMode);
      if (!t) return;
      let r = Number(t.monthlyPrice),
        i = this.getDiscountPercentage(r, Number(e.monthlyPrice));
      return {
        monthlyPlan: e,
        yearlyPlan: {
          planId: t.planId,
          monthlyPrice: r,
          yearlyPrice: r * 12,
          yearlySavings: `${i}%`,
        },
      };
    }
    getExperimentalPlans() {
      if (
        !this.featureFlagsRepository.getFeatureFlag(
          "subscriptionPriceExperimentEnabled"
        )
      )
        return;
      let { proMonthlyDiscountPlan: t, proYearlyDiscountPlan: r } =
        this.billingPlansRepository.getPlans();
      if (!(!t || !r))
        return { monthlyPlan: t, yearlyPlan: this.getYearlyPlanForUI(t, r) };
    }
    getYearlyPlanForUI(e, t) {
      let r = Number(t.monthlyPrice),
        i = r * 12,
        s = this.getDiscountPercentage(r, Number(e.monthlyPrice));
      return {
        planId: t.planId,
        monthlyPrice: r,
        yearlyPrice: i,
        yearlySavings: `${s}%`,
      };
    }
    getDiscountPercentage(e, t) {
      let r = ((1 - e / t) * 100).toFixed(0);
      return Number(r);
    }
    getDefaultPlans() {
      let { proMonthlyPlan: e, proYearlyPlan: t } =
        this.billingPlansRepository.getPlans();
      return { monthlyPlan: e, yearlyPlan: this.getYearlyPlanForUI(e, t) };
    }
    getDiscountModalPayload() {
      let { monthlyPlan: e } = this.getDefaultPlans();
      g(
        this.currentDiscountMode,
        "Failed to get discount config: no currentDiscountMode"
      );
      let { showingPeriodHours: t } = this.getDiscountConfig(
          this.currentDiscountMode
        ),
        r = this.getDiscountRemainingMS(t),
        i = this.getPlanForDiscount(this.currentDiscountMode);
      g(i, "No discount plan for discount modal");
      let s = Number(i.monthlyPrice),
        a = this.getDiscountPercentage(s, Number(e.monthlyPrice));
      return {
        monthlyPrice: { price: Number(e.monthlyPrice), planId: e.planId },
        yearlyPrice: {
          planId: i.planId,
          timer: this.getHMS(r),
          discountPercentage: a,
          price: s,
        },
      };
    }
    getLastChanceOfferModalPayload() {
      let { monthlyPrice: e } = this.getDefaultPlans().monthlyPlan,
        { showingIntervalHours: t } = this.getDiscountConfig(
          "progressiveDiscountOffer"
        ),
        r = this.getDiscountRemainingMS(t),
        i = new Date();
      i.setTime(i.getTime() + r);
      let s = this.getPlanForDiscount("progressiveDiscountOffer");
      g(s, "No discount plan for last change offer modal");
      let a = Number(s.monthlyPrice);
      return {
        newPrice: {
          monthlyPrice: Number(e),
          effective: { date: i.getDate(), month: i.getMonth() + 1 },
        },
        currentPrice: {
          monthlyPrice: a,
          timer: this.getHMS(r),
          planId: s.planId,
        },
      };
    }
    getCancelDiscountOfferModalPayload() {
      let { yearlyPlan: e } = this.getDefaultPlans(),
        t = this.billingPlansRepository.getCancelDiscountOffer();
      g(t, "No discount plan for cancel discount modal");
      let r = this.billingRepository.getCancelAt();
      return (
        g(r, "Property `cancel_at` is not defined"),
        {
          source: "condition-trigger",
          yearlyPrice: Number(t.price),
          monthlyPrice: Number(t.monthlyPrice),
          oldYearlyPrice: e.yearlyPrice,
          oldMonthlyPrice: e.monthlyPrice,
          cancelAt: r,
        }
      );
    }
    getHMS(e) {
      let t = Math.floor(Pi(e)),
        r = Math.floor(ur(e - xe(t))),
        i = Math.floor(Ue(e - xe(t) - ye(r)));
      return { hours: t, minutes: r, seconds: i };
    }
  };
c();
c();
c();
var ci = class {
  static parseInvitationsPlans(e) {
    return e.collection.map((t) => ({
      requiredActivations: t.count,
      wasActivated: t.is_used,
      durationInMonths: t.duration ? Math.floor(Yy(ce(t.duration))) : null,
      basePlanId: t.base_plan_id,
    }));
  }
  static parseInvitationsStats(e) {
    return {
      inviteLink: e.invite_link ?? null,
      requiredActivations: e.required_activations,
      statistics: {
        activations: e.statistics.activations,
        downloads: e.statistics.downloads,
      },
    };
  }
  static parseBillingPlan(e) {
    return {
      id: e.id,
      name: e.name,
      originalName: e.original_name ?? null,
      billingLink: e.billingLink,
      canManage: e.can_manage,
      cancelAt: e.cancel_at ? ce(e.cancel_at) : null,
      options: {
        interval: e.options.interval ?? null,
        isGift: e.options.isGift,
        isTeam: e.options.isTeam,
        isPaid: e.options.isPaid,
        isPro: e.options.isPro,
        isTrial: e.options.isTrial,
        isTrialExpired: e.options.isTrialExpired,
        planName: e.name,
        subscriptionTimeLeft: e.options.subscriptionTimeLeft ?? null,
      },
      planOptions: {
        accountsLimitPerApp: e.planOptions.accountsLimitPerApp.value ?? null,
        appSharingLimit: e.planOptions.appSharingLimit.value ?? null,
        canBeUpgradedByInvites:
          e.planOptions.canBeUpgradedByInvites?.value ?? !1,
        canUseAdblock: e.planOptions.canUseAdblock?.value ?? !1,
        cancelLink: e.planOptions.cancelLink?.value,
        canUseIntercom: e.planOptions.canUseIntercom?.value ?? !1,
        pinnedAppsLimit: e.planOptions.pinnedAppsLimit.value ?? null,
        splitViewLimitPerWindow:
          e.planOptions.splitViewLimitPerWindow.value ?? null,
        totalAppsLimit: e.planOptions.totalAppsLimit.value ?? null,
        sessionsPerWorkspaceLimit:
          e.planOptions.sessionsPerWorkspaceLimit.value ?? null,
        workspacesLimit: e.planOptions.workspacesLimit.value ?? null,
        preInstalledAppsLimit:
          e.planOptions.preInstalledAppsLimit.value ?? null,
      },
    };
  }
};
var Nc = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m, y, b, v, S) {
    this.backendService = e;
    this.billingRepository = t;
    this.browserService = r;
    this.modalService = i;
    this.notificationManager = s;
    this.analytics = a;
    this.popupService = n;
    this.featureFlagsRepository = p;
    this.userRepository = d;
    this.signUpService = u;
    this.browserStorage = m;
    this.userSettingsRepository = y;
    this.billingPriceService = b;
    this.billingPlansRepository = v;
    this.actualUsageDaysRepository = S;
    this.subscribeToUserActivatedAndShowStartTrialPopup(),
      this.featureFlagsRepository.onFeatureFlagsLoaded((w) => {
        w.showPaidTrialModalIsEnabled && this.tryShowPaidTrialModal().catch(l);
      });
  }
  logger = x.createInstance("billing");
  async startTrial() {
    let e = this.billingRepository.getBillingPlan();
    if (!e) {
      se.once("billing-plan-loaded", () => {
        this.startTrial().catch(l);
      });
      return;
    }
    let { isPro: t, isTrial: r, isTrialExpired: i } = e.options;
    if (!(t || r || i)) {
      try {
        await this.backendService.extension.postStartTrial(),
          await this.loadBillingPlan();
      } catch {
        this.logger.info("Trial already started");
        return;
      }
      this.analytics.sendAnalyticsEvent("monetization.trial-started", void 0);
    }
  }
  async loadBillingPlan(e = !1) {
    let t = this.billingRepository.getBillingPlan(),
      r = this.billingRepository.getLastBillingPlanReloadTimestamp(),
      i = await this.backendService.extension.getBillingPlan(),
      s = ci.parseBillingPlan(i);
    this.billingRepository.setBillingPlan(s),
      this.analytics.setExtra({
        "monetization.plan": this.billingRepository.getPlanName(),
        "monetization.plan-id": s.id,
        "monetization.is-trial": s.options.isTrial,
        "monetization.is-pro": s.options.isPro,
      }),
      this.logger.info("Billing plan loaded from backend", s),
      s.options.subscriptionTimeLeft &&
        this.tryShowBillingTrialExpireSoonNotification(
          s.options.subscriptionTimeLeft
        ).catch(l),
      t && this.processOldPlanAfterReloading(t, s, r),
      se.emit("billing-plan-loaded", s, e);
  }
  async showLimitPopup(e) {
    return this.modalService.showBillingLimitsReachedModal({ source: e });
  }
  async openUpgradePlanTab(e) {
    if (this.userRepository.getIsTemporaryUser())
      return this.signUpService.showModal({
        source: "limit-plan-modal.upgrade-button-clicked",
      });
    let { url: t } =
        await this.backendService.extension.getBillingUpgradePlanUrl({
          plan_id: e,
        }),
      r = (await this.browserService.getAllTabs({ url: t }))[0];
    return (
      this.analytics.sendAnalyticsEvent(
        "monetization.upgrade-plan-tab-opened",
        void 0
      ),
      r?.id
        ? this.browserService.activateTab(r.id)
        : this.browserService.createTab({ url: t })
    );
  }
  async openTeamUpgradePlanTab(e) {
    let t = this.billingPlansRepository.getTeamProPlan()?.planId;
    if (!t) return Promise.resolve();
    let { url: r } = await this.backendService.extension.getTeamUpgradePlanUrl({
        teamUUID: e,
        planId: t,
      }),
      i = (await this.browserService.getAllTabs({ url: r }))[0];
    return (
      this.analytics.sendAnalyticsEvent(
        "monetization.upgrade-team-plan-tab-opened",
        void 0
      ),
      i?.id
        ? this.browserService.activateTab(i.id)
        : this.browserService.createTab({ url: r })
    );
  }
  deleteTeamPlanSubscription(e) {
    return this.backendService.extension.deleteTeamPlanSubscription({
      teamUUID: e,
    });
  }
  async openCustomerPortal() {
    let e = await this.backendService.extension.getStripeCustomerPortalUrl();
    if (!e.session_url) return Promise.resolve(void 0);
    let t = e.session_url;
    return (
      this.analytics.sendAnalyticsEvent(
        "monetization.customer-portal-opened",
        void 0
      ),
      this.browserService.createTab({ url: t })
    );
  }
  setupNotificationsListener(e) {
    e.subscribe(
      ["updated"],
      ["billing_plan.updated"],
      this.handleUpdateViaNotificationService.bind(this),
      { uri: zo.getPath() }
    );
  }
  showBillingPlanHasExpiredModal(e) {
    let t = this.billingRepository.getIsTeam();
    if (t && !this.billingRepository.getCanManagePlan())
      return Promise.resolve();
    let r = this.billingRepository.getPlanName() ?? "";
    return this.modalService.showBillingPlanHasExpiredModal({
      source: e,
      isTeamVersion: t,
      planName: r,
    });
  }
  showBillingPlanExpireSoonModal(e) {
    let t = this.billingRepository.getIsTeam();
    if (t && !this.billingRepository.getCanManagePlan())
      return Promise.resolve();
    let r = this.billingRepository.getPlanName() ?? "";
    return this.modalService.showBillingPlanExpireSoonModal({
      source: e,
      isTeamVersion: t,
      planName: r,
    });
  }
  dismissCancelDiscountOffer() {
    this.backendService.extension.dismissCancelDiscountOffer().catch(l);
  }
  async claimCancelDiscountOffer() {
    let e = this.billingPlansRepository.getCancelDiscountOffer();
    g(e, "No discount plan for cancel discount modal");
    try {
      await this.backendService.extension.claimDiscountOffer({
        plan_id: e.planId,
      });
      let t = this.getSuccessDiscountOfferPayloadForNotifications();
      this.notificationManager.showBillingDiscountOfferNotification(t);
    } catch (t) {
      l(t);
      let r = this.getFailureDiscountOfferPayloadForNotifications();
      this.notificationManager.showBillingDiscountOfferNotification(r);
    }
  }
  subscribeToUserActivatedAndShowStartTrialPopup() {
    W.once("user-activated", () => {
      this.billingRepository.getBillingPlan()?.options.isTrial &&
        this.notificationManager.showBillingStartTrialNotification(
          this.getPayloadForNotifications()
        );
    });
  }
  handleUpdateViaNotificationService() {
    let e = this.billingRepository.getBillingPlan();
    if (!e) return;
    let { isTrial: t } = e.options;
    this.loadBillingPlan(!0)
      .then(() => {
        let r = this.billingRepository.getBillingPlan();
        if (!r) return;
        let { isTrial: i } = r.options;
        if (!(!t && i)) return;
        let { wasActivated: a } = this.userSettingsRepository.getSettings();
        a &&
          this.notificationManager.showBillingStartTrialNotification(
            this.getPayloadForNotifications()
          );
      })
      .catch(l);
  }
  processOldPlanAfterReloading(e, t, r) {
    this.getWasTrialEnded(e, t) &&
      (this.showBillingPlanHasExpiredModal("plan-change-route").catch(l),
      !(!r || !e.options.subscriptionTimeLeft) &&
        this.billingPriceService.setAlarmForDiscount(
          r,
          e.options.subscriptionTimeLeft
        ));
  }
  getWasTrialEnded(e, t) {
    let { isTrial: r, isTrialExpired: i, isPro: s } = t.options;
    if (s) return !1;
    let { isTrial: a, isTrialExpired: n } = e.options;
    return !(!(a && !n) || !(!r && i));
  }
  async tryShowBillingTrialExpireSoonNotification(e) {
    if (
      this.billingRepository.getIsTeam() &&
      !this.billingRepository.getCanManagePlan()
    )
      return;
    let r = pt(23),
      i = Math.ceil(Rr(ce(e))),
      { daysBeforeShowingExpireSoon: s, expireSoonShowingInterval: a } =
        this.featureFlagsRepository.getFeatureFlag("newBilling"),
      n = await this.browserStorage.getItem(
        "billing-trial-expire-soon-last-showed-at"
      ),
      p = this.calculateDelayBeforeShowingExpireSoonNotification(
        n ?? 0,
        xe(a),
        pt(i),
        pt(s)
      );
    if (p === 0) await this.showBillingTrialExpireSoonNotification();
    else {
      if (p >= r) {
        let d = e - Ue(r);
        globalThis.setTimeout(() => {
          this.tryShowBillingTrialExpireSoonNotification(d).catch(l);
        }, r);
        return;
      }
      globalThis.setTimeout(() => {
        this.showBillingTrialExpireSoonNotification().catch(l);
      }, p);
    }
  }
  calculateDelayBeforeShowingExpireSoonNotification(e, t, r, i) {
    let s = Math.max(r - i, 0),
      a = Math.max(t - (Date.now() - e), 0);
    return Math.max(s, a);
  }
  async showBillingTrialExpireSoonNotification() {
    return (this.billingRepository.getIsTeam() &&
      !this.billingRepository.getCanManagePlan()) ||
      !this.billingRepository.getIsTrial()
      ? Promise.resolve()
      : (this.notificationManager.showBillingEndTrialNotification(
          this.getPayloadForNotifications()
        ),
        this.browserStorage.setItem(
          "billing-trial-expire-soon-last-showed-at",
          Date.now()
        ));
  }
  getPayloadForNotifications() {
    return {
      isTeam: this.billingRepository.getIsTeam(),
      planName: this.billingRepository.getBillingPlanName(),
    };
  }
  getSuccessDiscountOfferPayloadForNotifications() {
    return { isSuccess: !0 };
  }
  getFailureDiscountOfferPayloadForNotifications() {
    return { isSuccess: !1 };
  }
  updateCounterForPaidTrialModal(e) {
    this.browserStorage
      .setItem("paid-trial-modal-reminder-counter", e)
      .catch(l);
  }
  paidTrialModalShowedDay() {
    let e = this.actualUsageDaysRepository.getCount() ?? 0;
    this.browserStorage.setItem("paid-trial-modal-showed-day", e).catch(l);
  }
  async getPaidTrialModalRemindersCount() {
    let e = await this.browserStorage
      .getItem("paid-trial-modal-reminder-counter")
      .catch(l);
    if (e === void 0) {
      let { reminderCounter: t } =
        this.featureFlagsRepository.getFeatureFlag("showPaidTrialModal");
      return t;
    }
    return e;
  }
  async openPaidTrialPortal() {
    let { url: e } =
      await this.backendService.extension.getStripePaidTrialUrl();
    return e
      ? this.browserService.createTab({ url: e })
      : Promise.resolve(void 0);
  }
  async tryShowPaidTrialModal() {
    if (!this.billingRepository.getIsTrial()) return;
    let { wasActivated: t } = this.userSettingsRepository.getSettings();
    if (!t) return;
    let { daysBeforeShowing: r } =
        this.featureFlagsRepository.getFeatureFlag("showPaidTrialModal"),
      i = this.actualUsageDaysRepository.getCount() ?? 0;
    if (
      r > i ||
      (await this.browserStorage.getItem("paid-trial-modal-showed-day")) === i
    )
      return;
    let a = await this.getPaidTrialModalRemindersCount();
    if (!a) return;
    let n = a > 0;
    this.modalService.showPaidTrialModal({ shouldShowReminder: n }).catch(l),
      this.updateCounterForPaidTrialModal(a - 1);
  }
};
c();
var Lc = class {
  constructor(e, t, r, i, s, a, n) {
    this.backendService = e;
    this.invitationsRepository = t;
    this.analyticsTracker = r;
    this.browserService = i;
    this.modalService = s;
    this.popupService = a;
    this.uiNotificationsManager = n;
  }
  async showInvitationsPopup() {
    let e = await this.browserService.getLastFocusedWindowId();
    e && this.modalService.closeModal(e),
      await this.popupService.showLaunchpadPopup("billing-invitations");
  }
  async startInvitesBonusTime() {
    return (
      await this.backendService.extension.postStartInvitationsBonusTime(),
      this.loadInvitationPlansAndStats()
    );
  }
  async initialLoadInvitations() {
    await this.loadInvitationPlansAndStats(),
      this.tryShowInvitationsReachedFreePlanNotifications();
  }
  async loadInvitationsStats() {
    let e = await this.backendService.extension.getInvitationsStats(),
      t = ci.parseInvitationsStats(e);
    this.invitationsRepository.setInvitationsStats(t);
  }
  async loadInvitationPlansAndStats() {
    await Promise.all([
      this.loadInvitationsPlans(),
      this.loadInvitationsStats(),
    ]),
      await this.tryActivateForeverFree();
  }
  async tryActivateForeverFree() {
    let e = this.invitationsRepository.getBestAvailablePlanForUpgrade();
    !e ||
      e.durationInMonths !== null ||
      (await this.startInvitesBonusTime(),
      this.uiNotificationsManager.showInvitationsReachedForeverFreePlan(
        e.requiredActivations
      ));
  }
  tryShowInvitationsReachedFreePlanNotifications() {
    let e = this.invitationsRepository.getBestAvailablePlanForUpgrade();
    !e ||
      e.durationInMonths === null ||
      this.uiNotificationsManager.showInvitationsReachedFreePlan(
        e.requiredActivations,
        e.durationInMonths
      );
  }
  async loadInvitationsPlans() {
    let e = await this.backendService.extension.getInvitationsPlans(),
      r = [...ci.parseInvitationsPlans(e)].sort((s, a) =>
        s.durationInMonths === null
          ? 1
          : a.durationInMonths === null
          ? -1
          : s.durationInMonths - a.durationInMonths
      );
    this.invitationsRepository.setInvitationsPlans(r);
    let i = this.invitationsRepository.getBestActivatedPlan();
    i &&
      this.analyticsTracker.setExtra({
        "monetization.invitations-plan-id": i.basePlanId,
        "monetization.invitations-plan-months": i.durationInMonths,
      });
  }
};
var AS = ({
  accountRepository: o,
  analytics: e,
  applicationRepository: t,
  backendService: r,
  billingPlansRepository: i,
  billingRepository: s,
  browserEventsService: a,
  browserService: n,
  browserStorage: p,
  featureFlagsRepository: d,
  invitationsRepository: u,
  modalService: m,
  notificationManager: y,
  notificationsExperimentalLayer: b,
  popupService: v,
  recipesRepository: S,
  signUpService: w,
  userApi: T,
  userRepository: I,
  userSettingsRepository: k,
  workspaceRepository: _,
  sessionRepository: O,
  actualUsageDaysRepository: E,
}) => {
  let f = new jc(d, s, T, k, m, p, n, a, i);
  new Oc(r, i, b).init().catch(l);
  let ue = new Nc(r, s, n, m, y, e, v, d, I, w, p, k, f, i, E);
  ue.setupNotificationsListener(b), ue.loadBillingPlan(!1).catch(l);
  let Q = new Lc(r, u, e, n, m, v, y);
  return (
    Q.initialLoadInvitations().catch(l),
    new Uc(s, ue, t, _, o, S, f, Q, O, T, d)
  );
};
c();
var Gc = class {
  constructor(e) {
    this.collectionsService = e;
  }
  async createTab(e) {
    return this.collectionsService.createTab(e);
  }
  async createCollection(e) {
    await this.collectionsService.createCollection(e);
  }
  deleteCollection(e) {
    return this.collectionsService.deleteCollection(e);
  }
  renameCollection(e, t) {
    return this.collectionsService.renameCollection(e, t);
  }
  shareCollection(e, t, r) {
    return this.collectionsService.shareCollection(e, t, r);
  }
  unshareCollection(e, t, r) {
    return this.collectionsService.unshareCollection(e, t, r);
  }
  updateCollection(e, t, r) {
    return this.collectionsService.updateCollection(e, t, r);
  }
  createLink(e, t, r) {
    return this.collectionsService.createLink(e, t, r);
  }
  async addCurrentTabToCollection(e, t) {
    await this.collectionsService.addCurrentTabToCollection(e, t);
  }
  deleteLink(e) {
    return this.collectionsService.deleteLink(e);
  }
  updateLink(e, t) {
    return this.collectionsService.updateLink(e, t);
  }
  getSharedRecipients(e) {
    return this.collectionsService.getSharedRecipientsForCollection(e);
  }
};
c();
c();
var Hc = class {
  constructor(e, t) {
    this.browserService = e;
    this.browserEventsService = t;
    this.bookmarks = this.createBaseBookmarkFolder({
      id: Hu,
      title: "Bookmarks",
      emoji: "\u{1F31F}",
    });
  }
  bookmarks;
  foldersById = {};
  linksById = {};
  emitter = new A();
  subscriptions = null;
  onBookmarksLoaded(e) {
    return this.emitter.on("bookmarks-loaded", e);
  }
  getAllBookmarks() {
    return this.bookmarks;
  }
  async importBookmarks() {
    if (this.bookmarks.children.length) return;
    let e = (await this.browserService.getBookmarksTree())[0]?.children;
    if (
      (g(e, "Bookmarks cannot be empty"),
      (this.bookmarks.children = this.convertBookmarksToCollections(e)),
      this.subscriptions?.length)
    ) {
      this.emitter.emit("bookmarks-loaded");
      return;
    }
    this.subscriptions = this.initSubscriptions();
  }
  moveBookmark(e, t) {
    let r = this.foldersById[e]?.folderUuid ?? this.linksById[e]?.folderUuid;
    g(r, "parentId cannot be undefined");
    let i = this.foldersById[r];
    g(i, "parent cannot be undefined");
    let s = i.children.findIndex((p) => p.uuid === e);
    g(s !== -1, "Failed to move bookmark: couldnt find a bookmark to move");
    let a = t.parentId ?? r,
      n = t.index ?? this.foldersById[a]?.children.length ?? 0;
    return (
      (!t.parentId || r === t.parentId) && s < n && (n += 1),
      this.browserService.moveBookmark(e, { ...t, index: n })
    );
  }
  initSubscriptions() {
    return [
      this.browserEventsService.subscribeToBookmarkCreated((e, t) => {
        if (t.url) {
          let i = this.convertBookmarkToLink(t);
          (this.linksById[i.uuid] = i), this.addNodeToFolder(i, t.index);
          return;
        }
        let r = this.createBaseBookmarkFolder(t);
        (this.foldersById[r.uuid] = r), this.addNodeToFolder(r, t.index);
      }),
      this.browserEventsService.subscribeToBookmarkRemoved((e, t) => {
        if (t.node.url) {
          this.removeLink(e), this.emitter.emit("bookmarks-loaded");
          return;
        }
        this.removeFolderDeep(e), this.emitter.emit("bookmarks-loaded");
      }),
      this.browserEventsService.subscribeToBookmarkChanged(
        this.changeNode.bind(this)
      ),
      this.browserEventsService.subscribeToBookmarkMoved(
        this.handleBookmarkMoved.bind(this)
      ),
    ];
  }
  addNodeToFolder(e, t) {
    let r = this.foldersById[e.folderUuid ?? Lo];
    g(r, "Link cannot be without parent folder");
    let i = t ?? r.children.length;
    r.children.splice(i, 0, e), this.emitter.emit("bookmarks-loaded");
  }
  removeLink(e) {
    let t = this.linksById[e];
    g(t, "Cannot delete non existed link");
    let r = this.foldersById[t.folderUuid];
    g(r, "Cannot delete link without parent folder"),
      (r.children = r.children.filter(
        (i) => i.type !== "link" || i.uuid !== e
      )),
      delete this.linksById[e];
  }
  removeFolderDeep(e) {
    let t = this.foldersById[e];
    g(t, "Cannot delete non existed folder"),
      t.children.forEach((i) => {
        i.type === "link"
          ? this.removeLink(i.uuid)
          : this.removeFolderDeep(i.uuid);
      });
    let r = this.foldersById[t.folderUuid ?? Lo];
    g(r, "Cannot delete folder without its parent"),
      (r.children = r.children.filter((i) => i.uuid !== e)),
      delete this.foldersById[e];
  }
  changeNode(e, t) {
    let r = this.foldersById[e],
      i = this.linksById[e];
    r && (r.name = t.title ?? r.name),
      i && ((i.name = t.title ?? i.name), (i.url = t.url ?? i.url)),
      this.emitter.emit("bookmarks-loaded");
  }
  handleBookmarkMoved(e, t) {
    let r = this.foldersById[t.oldParentId];
    g(r, "Old parent cannot be undefined");
    let i = this.foldersById[e] ?? this.linksById[e],
      s = this.foldersById[t.parentId];
    g(i, "Cannot move non existed node"),
      g(s, "Parent doesnt exists"),
      (r.children = r.children.filter((a) => a.uuid !== e)),
      s.children.splice(t.index, 0, i),
      (i.folderUuid = s.uuid),
      this.emitter.emit("bookmarks-loaded");
  }
  convertBookmarksToCollections(e) {
    return e.map((t) =>
      t.children
        ? ((this.foldersById[t.id] = this.createBaseBookmarkFolder(t)),
          this.foldersById[t.id])
        : ((this.linksById[t.id] = this.convertBookmarkToLink(t)),
          this.linksById[t.id])
    );
  }
  convertBookmarkToLink(e) {
    return (
      g(e.url, "Link doesn't have url"),
      {
        uuid: e.id,
        url: e.url,
        type: "link",
        name: e.title,
        folderUuid: (e.parentId ?? Lo).toString(),
      }
    );
  }
  createBaseBookmarkFolder(e) {
    return {
      uuid: e.id,
      name: e.title,
      children: e.children
        ? this.convertBookmarksToCollections(e.children)
        : [],
      type: "folder",
      emoji: e.emoji ?? null,
      publicUrl: null,
      folderUuid: e.parentId ?? Lo,
      userUuid: null,
      teamUuid: null,
      permissions: {
        edit: !this.isRootFolder(e),
        copy: !1,
        transferOwner: !1,
        share: !1,
        shareWithTeam: !1,
        shareByPublicUrl: !1,
        shareByEmail: !1,
        destroy: !this.isRootFolder(e),
        drop: this.isDropAllowed(e),
        drag: !this.isRootFolder(e),
      },
    };
  }
  isRootFolder(e) {
    return Db.indexOf(e.id) !== -1;
  }
  isDropAllowed(e) {
    return e.id !== Hu;
  }
};
c();
var Vc = class {
  constructor(e, t, r, i) {
    this.collectionsBookmarksRepository = e;
    this.browserService = t;
    this.searchService = r;
    this.browserStorage = i;
    this.init().catch(l);
  }
  areBookmarksImported = !1;
  isImportSuccessPopupShown = !1;
  emitter = new A();
  async init() {
    (this.areBookmarksImported = (await this.getBookmarksImported()) ?? !1),
      (this.isImportSuccessPopupShown =
        (await this.loadIsImportSuccessPopupShown()) ?? !1),
      this.areBookmarksImported && this.importBookmarks().catch(l);
  }
  subscribeImportFinished(e) {
    return this.emitter.on("bookmarks-import-finished", e);
  }
  getAreBookmarksImported() {
    return this.areBookmarksImported;
  }
  getIsImportSuccessPopupShown() {
    return this.isImportSuccessPopupShown;
  }
  closeSuccessPopup() {
    return this.setIsImportSuccessPopupShown(!0);
  }
  async importBookmarks() {
    await this.collectionsBookmarksRepository.importBookmarks(),
      await this.setBookmarksImported(!0),
      this.emitter.emit("bookmarks-import-finished");
  }
  async addCurrentTabToBookmarksCollection(e) {
    let t = await this.browserService.getActiveTab(),
      r = t?.url;
    if (!t || !r) return;
    let i = t.title ?? (await this.getTitleForUrl(r));
    await this.browserService.createBookmark({ title: i, url: r, parentId: e });
  }
  async addLinkToBookmarksCollection(e, t, r) {
    let i = Ht(t),
      s = await this.getTitleForUrl(i);
    await this.browserService.createBookmark({
      title: s,
      url: i,
      parentId: e,
      index: r,
    });
  }
  createBookmarkFolder(e) {
    return this.browserService.createBookmark(e);
  }
  removeBookmark(e) {
    return this.browserService.removeBookmark(e);
  }
  removeBookmarkFolder(e) {
    return this.browserService.removeBookmarkTree(e);
  }
  moveBookmark(e, t) {
    return this.collectionsBookmarksRepository.moveBookmark(e, t);
  }
  updateBookmark(e, t) {
    return this.browserService.updateBookmark(e, t);
  }
  async getTitleForUrl(e) {
    return (await this.searchService.getTitleFromUrl(e)) ?? xo(e);
  }
  setBookmarksImported(e) {
    return (
      (this.areBookmarksImported = e),
      this.browserStorage.setItem("are-bookmarks-imported", e)
    );
  }
  getBookmarksImported() {
    return this.browserStorage.getItem("are-bookmarks-imported");
  }
  setIsImportSuccessPopupShown(e) {
    return (
      (this.isImportSuccessPopupShown = e),
      this.browserStorage.setItem("is-bookmarks-import-success-popup-shown", e)
    );
  }
  loadIsImportSuccessPopupShown() {
    return this.browserStorage.getItem(
      "is-bookmarks-import-success-popup-shown"
    );
  }
};
c();
c();
var st = (o) => (
    g(de(o), "Collection mapper: required value is null", { value: o }), o
  ),
  De = class {
    static parseCollections(e) {
      return {
        team: e.team.map((t) => De.parseCollectionFolder(t)),
        shared: e.shared.map((t) => De.parseCollectionFolder(t)),
        private: e.private.map((t) => De.parseCollectionFolder(t)),
      };
    }
    static parseCollectionNode(e) {
      switch (e.type) {
        case "folder":
          return De.parseCollectionFolder(e);
        case "link":
          return De.parseCollectionLink(e);
        default:
          throw TypeError(`Unknown type: ${String(e.type)}`);
      }
    }
    static parseCollectionFolder(e) {
      return {
        type: "folder",
        uuid: st(e.uuid),
        name: st(e.name),
        publicUrl: e.public_url,
        emoji: e.emoji ?? null,
        userUuid: e.user_uuid ?? null,
        folderUuid: e.folder_uuid ?? null,
        teamUuid: e.team_uuid ?? null,
        permissions: {
          edit: st(e.permissions.edit),
          copy: st(e.permissions.copy),
          transferOwner: st(e.permissions.transfer_owner),
          share: st(e.permissions.share),
          shareWithTeam: st(e.permissions.share_with_team),
          shareByPublicUrl: st(e.permissions.share_by_public_url),
          shareByEmail: st(e.permissions.share_by_email),
          destroy: st(e.permissions.destroy),
        },
        children: (e.children ?? []).map((t) => De.parseCollectionNode(t)),
      };
    }
    static parseCollectionLink(e) {
      return {
        type: "link",
        uuid: st(e.uuid),
        name: st(e.name),
        url: st(e.url),
        folderUuid: e.folder_uuid ?? null,
      };
    }
    static parseRecipient(e) {
      return {
        uuid: st(e.uuid),
        collectionUuid: st(e.collection_uuid),
        avatar: e.avatar,
        email: e.email,
        status: st(e.status),
      };
    }
    static createStubCollection(e, t, r, i) {
      return {
        name: e,
        emoji: t ?? null,
        teamUuid: i ?? null,
        uuid: le(),
        type: "folder",
        children: [],
        folderUuid: r ?? null,
        userUuid: null,
        publicUrl: null,
        permissions: {
          edit: !1,
          copy: !1,
          transferOwner: !1,
          share: !1,
          shareWithTeam: !1,
          shareByPublicUrl: !1,
          shareByEmail: !1,
          destroy: !1,
        },
      };
    }
    static createStubLink(e, t, r) {
      return { uuid: le(), name: e, url: t, type: "link", folderUuid: r };
    }
  };
c();
var vh = 127,
  fh = 127,
  wE = ce(5),
  $c = class {
    constructor(e, t, r, i, s, a, n, p, d, u, m, y) {
      this.backendService = e;
      this.collectionsRepository = t;
      this.notificationsExperimentalLayer = r;
      this.browserService = i;
      this.browserEventsService = s;
      this.workspaceRepository = a;
      this.searchService = n;
      this.featureFlagsRepository = p;
      this.modalService = d;
      this.browserStorage = u;
      this.actualUsageDaysRepository = m;
      this.sessionRepository = y;
      this.subscribeAllNotifications(),
        this.browserEventsService.subscribeToMessageExternal((b, v) =>
          this.handleExternalMessage(b, v)
        ),
        _e.on("team-created", (b) => {
          this.createCollectionsInNewTeam(b).catch(l);
        }),
        this.featureFlagsRepository.onFeatureFlagsLoaded((b) => {
          b.isCollectionModalEnabled &&
            this.tryShowCollectionIntroModal().catch(l);
        });
    }
    logger = x.createInstance("collections");
    createTab(e) {
      return this.browserService.createTab({ url: e });
    }
    async deleteCollection(e) {
      this.collectionsRepository.deleteNode(e),
        await this.handleCollectionsError(async () => {
          await this.backendService.collection.deleteCollection(e);
        }),
        this.logger.info("Deleting collection with id: ", e);
    }
    async renameCollection(e, t) {
      let r = t.slice(0, fh);
      this.collectionsRepository.updateCollectionFolder(e, { name: r }),
        await this.handleCollectionsError(async () => {
          await this.backendService.collection.updateCollection(e, { name: r });
        }),
        this.logger.info("Renaming collection with id: ", e);
    }
    async createCollection({
      name: e,
      index: t,
      dontExpandCollectionInUI: r,
      parentId: i,
      teamId: s,
      emoji: a,
      ...n
    }) {
      let p =
        n.workspaceId ??
        this.workspaceRepository.getWorkspaceForWindow(n.windowId)?.id;
      g(p, "Failed to create collection: no workspace id to use");
      let d = e.slice(0, fh),
        u;
      if (i) {
        let m = De.createStubCollection(d, a, i, s);
        this.collectionsRepository.createStubFolderNested(m),
          await this.handleCollectionsError(async () => {
            let y = De.parseCollectionFolder(
              await this.backendService.collection.createNestedCollection(
                d,
                i,
                p,
                a,
                t
              )
            );
            this.collectionsRepository.switchStubCollectionNestedToReal(
              m.uuid,
              y
            ),
              (u = y.uuid),
              we.emit("collection-created", r ? void 0 : y);
          }),
          this.logger.info(
            `Creating collection with name: ${e}. Parent UUID ${i ?? ""}`
          );
      } else {
        let m = De.createStubCollection(d, a, null, s);
        this.collectionsRepository.createStubFolder(m, p, t),
          await this.handleCollectionsError(async () => {
            let y = De.parseCollectionFolder(
              await this.backendService.collection.createRootCollection(
                d,
                p,
                a,
                s,
                t
              )
            );
            this.collectionsRepository.switchStubCollectionToReal(
              m.uuid,
              y,
              p,
              t
            ),
              (u = y.uuid),
              we.emit("collection-created", r ? void 0 : y);
          }),
          this.logger.info(`Creating collection with name: ${e}`);
      }
      return u;
    }
    async createLink(e, { link: t, name: r }, i) {
      let s = Ht(t),
        a = (r || (await this.getTitleForUrl(s))).slice(0, vh),
        n = De.createStubLink(a, s, e);
      await this.handleCollectionsError(async () => {
        this.collectionsRepository.createStubLink(n, i);
        let p = De.parseCollectionLink(
          await this.backendService.collection.createLink(e, a, s, i)
        );
        this.collectionsRepository.switchStubLinkToReal(n.uuid, p);
      }),
        this.logger.info(
          `Creating link inside ${e}. Url: ${t}. Name: ${xo(t)}`
        );
    }
    async shareCollection(e, t, r) {
      await this.handleCollectionsError(async () => {
        let i = De.parseRecipient(
            await this.backendService.collection.shareCollection(t, r)
          ),
          s = await this.getSharedRecipientsForCollection(t);
        this.collectionsRepository.updateRecipientsForCollection(t, [i, ...s]),
          this.collectionsRepository.updateCollectionsSection(e, t);
      }),
        this.logger.info(`Sharing collection with uuid: ${t} to ${r}`);
    }
    async unshareCollection(e, t, r) {
      await this.handleCollectionsError(async () => {
        await this.backendService.collection.unshareCollection(r);
        let i = await this.getSharedRecipientsForCollection(t);
        (i = i.filter((s) => s.uuid !== r)),
          this.collectionsRepository.updateRecipientsForCollection(t, i),
          this.collectionsRepository.updateCollectionsSection(e, t);
      }),
        this.logger.info(`Revoke sharing collection with uuid: ${t}`);
    }
    async updateCollection(e, t, r) {
      let i = r.name?.slice(0, fh),
        s = i ? { ...r, name: i } : r;
      this.collectionsRepository.updateCollectionFolder(
        t,
        s,
        e,
        s.teamUuid ? "team" : "private"
      ),
        r.teamUuid !== void 0 &&
          r.folderUuid === void 0 &&
          this.collectionsRepository.updateCollectionsSection(e, t),
        await this.handleCollectionsError(async () => {
          let a = De.parseCollectionFolder(
            await this.backendService.collection.updateCollection(t, s)
          );
          r.isPublic !== void 0 &&
            (this.collectionsRepository.updateCollectionFolder(t, {
              publicUrl: a.publicUrl,
            }),
            this.collectionsRepository.updateCollectionsSection(e, t),
            we.emit("collection-public-changed"));
        }),
        this.logger.info(`Collection with id ${t} updated.`);
    }
    getSharedRecipientsForCollection(e) {
      return this.collectionsRepository.getRecipientsForCollection(e);
    }
    async addCurrentTabToCollection(e, t) {
      let r = await this.browserService.getActiveTab(),
        i = r?.url;
      if (!r || !i) return;
      let s = (r.title ?? (await this.getTitleForUrl(i))).slice(0, vh),
        a = De.createStubLink(s, i, t);
      this.collectionsRepository.createStubLink(a),
        await this.handleCollectionsError(async () => {
          let n = De.parseCollectionLink(
            await this.backendService.collection.createLink(t, s, i)
          );
          this.collectionsRepository.switchStubLinkToReal(a.uuid, n);
        }),
        this.logger.info(`Creating link inside ${t}. Url: ${i}. Name: ${s}`);
    }
    async deleteLink(e) {
      this.collectionsRepository.deleteNode(e),
        await this.handleCollectionsError(async () => {
          await this.backendService.collection.deleteLink(e);
        }),
        this.logger.info(`Link with id ${e} removed.`);
    }
    async updateLink(e, t) {
      let r = t.name?.slice(0, vh),
        i = r ? { ...t, name: r } : t;
      this.collectionsRepository.updateCollectionLink(e, i),
        await this.handleCollectionsError(async () => {
          await this.backendService.collection.updateLink(e, i);
        }),
        this.logger.info(
          `Link with id ${e} updated. Name: ${t.name || ""}. Url: ${
            t.url || ""
          }`
        );
    }
    async createCollectionsInNewTeam({ workspaceId: e, team: t }) {
      return e
        ? Promise.all(
            this.getDefaultTeamFolders().map(async (i, s) => {
              let a = await this.createCollection({
                name: i.title,
                teamId: t.uuid,
                workspaceId: e,
                index: s,
                dontExpandCollectionInUI: !0,
              });
              i.links?.length &&
                a &&
                i.links.forEach((n) => {
                  this.createLink(a, n).catch(l);
                });
            })
          )
        : Promise.resolve([]);
    }
    async handleExternalMessage(e, t) {
      if (!this.getIsCollectionsAddMessage(e)) return;
      let r = this.workspaceRepository.getWorkspaceForWindow(
        t.tab?.windowId
      )?.id;
      r &&
        (await this.backendService.collection.subscribeCollection(
          e.payload.collectionId,
          r,
          e.payload.inviteCode
        ));
    }
    async handleCollectionsError(e, t = "Unknown error") {
      try {
        await e();
      } catch (r) {
        let i = r instanceof lt ? (await je(r.res, r.req))?.message : t;
        we.emit("request-error", i),
          await this.collectionsRepository.reloadCollections();
      }
    }
    async getTitleForUrl(e) {
      return (await this.searchService.getTitleFromUrl(e)) ?? xo(e);
    }
    subscribeAllNotifications() {
      let e = yt(async () => {
        await this.collectionsRepository.reloadCollections();
      }, wE);
      this.notificationsExperimentalLayer.subscribe(
        ["created", "updated", "deleted"],
        [
          "collection_folder.created",
          "collection_folder.updated",
          "collection_folder.deleted",
        ],
        e,
        { uri: Ko.getPath() }
      ),
        this.notificationsExperimentalLayer.subscribe(
          ["created", "updated", "deleted"],
          [
            "collection_link.created",
            "collection_link.updated",
            "collection_link.deleted",
          ],
          e,
          { uri: qo.getPath() }
        );
    }
    getIsCollectionsAddMessage(e) {
      return Ge(e) && oe(e, "type") && e.type === "ADD_SHARED_COLLECTION";
    }
    getDefaultTeamFolders() {
      return [
        { title: P("sidecar_collections__default_team_folder_product") },
        { title: P("sidecar_collections__default_team_folder_marketing") },
        { title: P("sidecar_collections__default_team_folder_dashboards") },
        { title: P("sidecar_collections__default_team_folder_onboarding") },
        {
          title: P("sidecar_collections__default_team_folder_learn_sidekick"),
          links: [
            { name: "Sidekick", link: "https://www.meetsidekick.com/" },
            {
              name: P("sidecar_collections__default_team_link_sidekick_help"),
              link: this.featureFlagsRepository.getFeatureFlag("helpLinks")
                .learningCenter,
            },
          ],
        },
      ];
    }
    async tryShowCollectionIntroModal() {
      if (await this.browserStorage.getItem("session-intro-modal")) return;
      let { daysLimitBeforeToShow: t } =
        this.featureFlagsRepository.getFeatureFlag("showCollectionModal");
      (this.actualUsageDaysRepository.getCount() ?? 0) <= t ||
        (await Promise.all([
          this.modalService.showCollectionIntroModal({}).catch(l),
          this.browserStorage.setItem("session-intro-modal", !0).catch(l),
        ]));
    }
  };
c();
var Kc = ["index", "folderUuid"],
  qc = class {
    constructor(e, t, r) {
      this.backendService = e;
      this.featureFlagsRepository = t;
      this.workspaceRepository = r;
      this.init().catch(l);
    }
    collectionsByWorkspaceId = {};
    logger = x.createInstance("collections");
    featureFlagsUnsubscribe = null;
    foldersById = {};
    linksById = {};
    recipientsById = {};
    async init() {
      let e = this.featureFlagsRepository.getFeatureFlag("collectionsEnabled"),
        t = this.featureFlagsRepository.getFeatureFlag(
          "forceCollectionsEnableForTeams"
        );
      if (!e && !t) {
        this.featureFlagsUnsubscribe ??=
          this.featureFlagsRepository.onFeatureFlagsLoaded(() => {
            this.init().catch(l);
          });
        return;
      }
      this.featureFlagsUnsubscribe?.();
      let r = [...this.workspaceRepository.getWorkspacesById().keys()];
      await Promise.all(
        r.map(async (i) => {
          this.isCollectionsEnabledForWorkspace(i) &&
            (await this.loadCollectionsByWorkspaceId(i).catch(l));
        })
      ),
        re.on("workspaces-loaded", (i) => {
          i.forEach((s) => {
            this.collectionsByWorkspaceId[s.id] ||
              !this.isCollectionsEnabledForWorkspace(s.id) ||
              this.loadCollectionsByWorkspaceId(s.id).catch(l);
          });
        }),
        re.on("workspaces-changed", (i, s) => {
          this.collectionsByWorkspaceId[s] ||
            !this.isCollectionsEnabledForWorkspace(s) ||
            this.loadCollectionsByWorkspaceId(s).catch(l);
        });
    }
    isCollectionsEnabledForWorkspace(e) {
      let t = this.featureFlagsRepository.getFeatureFlag("collectionsEnabled");
      if (t) return t;
      let r = this.featureFlagsRepository.getFeatureFlag(
          "forceCollectionsEnableForTeams"
        ),
        s = this.workspaceRepository.getWorkspaceById(e)?.isTeamWorkspace;
      return (r && s) ?? !1;
    }
    isCollectionsEnabledForWorkspaceByWindowId(e) {
      let t = this.workspaceRepository.getWorkspaceForWindow(e)?.id;
      return t
        ? this.isCollectionsEnabledForWorkspace(t)
        : this.featureFlagsRepository.getFeatureFlag("collectionsEnabled");
    }
    reloadCollections() {
      return Promise.all(
        Object.keys(this.collectionsByWorkspaceId).map(async (e) => {
          await this.loadCollectionsByWorkspaceId(e);
        })
      );
    }
    updateCollectionFolder(e, t, r, i) {
      Object.keys(t).forEach((s) => {
        Kc.includes(s) ||
          (this.foldersById[e] && (this.foldersById[e][s] = t[s]));
      }),
        Kc.some((s) => oe(t, s)) &&
          this.handleNodeMoved(
            e,
            { index: t.index, parentId: t.folderUuid, toSection: i },
            r
          ),
        we.emit("collections-updated");
    }
    updateCollectionLink(e, t) {
      Object.keys(t).forEach((r) => {
        Kc.includes(r) || (this.linksById[e] && (this.linksById[e][r] = t[r]));
      }),
        Kc.some((r) => oe(t, r)) &&
          this.handleNodeMoved(e, { index: t.index, parentId: t.folderUuid }),
        we.emit("collections-updated");
    }
    updateRecipientsForCollection(e, t) {
      (this.recipientsById[e] = t), we.emit("recipients-updated", t);
    }
    async getRecipientsForCollection(e) {
      let t = this.recipientsById[e];
      return (
        t ||
          ((t = (
            await this.backendService.collection.getRecipientsByCollectionId(e)
          ).map((i) => De.parseRecipient(i))),
          (this.recipientsById[e] = t)),
        t || []
      );
    }
    getCollectionById(e) {
      return this.foldersById[e];
    }
    createStubFolder(e, t, r) {
      if (e.teamUuid) {
        (this.foldersById[e.uuid] = { ...e, section: "team" }),
          this.addFolder(e, t, "team", void 0, r);
        return;
      }
      (this.foldersById[e.uuid] = { ...e, section: "private" }),
        this.addFolder(e, t, "private");
    }
    createStubFolderNested(e) {
      g(
        e.folderUuid,
        "Collection folder does not have a folderUuid to create nested stub folder"
      );
      let t = this.foldersById[e.folderUuid];
      g(t, "No parent folder to create nested stub folder"),
        (t.children = [e, ...t.children]),
        we.emit("collections-updated");
    }
    switchStubCollectionToReal(e, t, r, i) {
      if ((delete this.foldersById[e], t.teamUuid)) {
        (this.foldersById[t.uuid] = { ...t, section: "team" }),
          this.addFolder(t, r, "team", e, i);
        return;
      }
      (this.foldersById[t.uuid] = { ...t, section: "private" }),
        this.addFolder(t, r, "private", e, i);
    }
    switchStubCollectionNestedToReal(e, t) {
      g(
        t.folderUuid,
        "Collection folder does not have a folderUuid to switch stub folder to real"
      );
      let r = this.foldersById[t.folderUuid];
      g(r, "No parent folder to switch stub folder to real"),
        (r.children = r.children.map((i) => (e === i.uuid ? t : i))),
        we.emit("collections-updated");
    }
    createStubLink(e, t) {
      this.linksById[e.uuid] = e;
      let r = this.foldersById[e.folderUuid];
      g(r, "No parent folder to create stub link");
      let i = t ?? r.children.length;
      r.children.splice(i, 0, e), we.emit("collections-updated");
    }
    switchStubLinkToReal(e, t) {
      delete this.linksById[e], (this.linksById[t.uuid] = t);
      let r = this.foldersById[t.folderUuid];
      g(r, "No parent folder to switch stub link to real"),
        (r.children = r.children.map((i) => (e === i.uuid ? t : i))),
        we.emit("collections-updated");
    }
    getCollectionsForWorkspaceByWindowId(e) {
      let t = this.workspaceRepository.getWorkspaceForWindow(e)?.id;
      return (
        g(t, "Cant get workspace by windowId for collections", {
          workspacesCount: this.workspaceRepository.getWorkspacesById().size,
          windowId: e,
        }),
        this.collectionsByWorkspaceId[t] ?? {
          team: [],
          shared: [],
          private: [],
        }
      );
    }
    deleteNode(e) {
      let t = this.foldersById[e],
        r = this.getParentById(e);
      if ((delete this.foldersById[e], !r && t)) {
        g(
          t.workspaceId,
          "Couldnt delete node: no workspaceId in fallbackFolder"
        );
        let i = this.collectionsByWorkspaceId[t.workspaceId];
        g(i, "Couldnt delete node: no collection for workspaceId", {
          workspaceId: t.workspaceId,
        }),
          Object.entries(i).forEach(([s, a]) => {
            i[s] = a.filter(({ uuid: n }) => n !== e);
          }),
          we.emit("collections-updated");
        return;
      }
      r &&
        ((r.children = r.children.filter((i) => i.uuid !== e)),
        we.emit("collections-updated"));
    }
    updateCollectionsSection(e, t) {
      let r = this.foldersById[t];
      if ((g(r, "Cannot find collection"), this.isCollectionTeam(r.uuid))) {
        this.moveFromSectionToSection(e, t, r?.section || "private", "team");
        return;
      }
      this.isCollectionPublic(t)
        ? this.moveFromSectionToSection(e, t, r?.section || "private", "shared")
        : this.moveFromSectionToSection(
            e,
            t,
            r?.section || "shared",
            "private"
          );
    }
    getTeamIdByFolderId(e) {
      return this.foldersById[e]?.teamUuid ?? null;
    }
    isCollectionPublic(e) {
      let t = this.foldersById[e];
      if (
        (g(t, "Can not say if collection is public: collection not found"),
        t.publicUrl)
      )
        return !0;
      let r = this.recipientsById[e];
      return r ? r.length > 1 || r[0]?.status !== "owner" : !1;
    }
    isCollectionTeam(e) {
      return Boolean(this.foldersById[e]?.teamUuid);
    }
    moveFromSectionToSection(e, t, r, i) {
      if (r === i) return;
      let s = this.workspaceRepository.getWorkspaceForWindow(e)?.id;
      if (!s) return;
      let a = this.collectionsByWorkspaceId[s];
      g(
        a,
        "Couldnt move collection from section to section: no collections for current workspace"
      );
      let n = this.foldersById[t];
      g(
        n,
        "Couldnt move collection from section to section: no collection to move"
      ),
        (this.collectionsByWorkspaceId[s][r] = a[r].filter(
          (p) => p.uuid !== n.uuid
        )),
        (this.collectionsByWorkspaceId[s][i] = [...a[i], n]),
        (n.section = i),
        we.emit("collections-updated");
    }
    addFolder(e, t, r, i, s) {
      i && this.deleteRootCollection(t, r, i);
      let a = s ?? 0;
      this.collectionsByWorkspaceId[t]?.[r]?.splice(a, 0, e),
        we.emit("collections-updated");
    }
    handleNodeMoved(e, t, r) {
      let i = this.foldersById[e] ?? this.linksById[e];
      g(i, "Cannot move non existed node");
      let s = this.removeCollectionFromOldPlace(i, r),
        a = t.parentId === void 0 ? s : t.parentId;
      this.pasteCollectionToNewPlace(i, a, t, r),
        typeof t.parentId < "u" &&
          i.type === "folder" &&
          (i.section = a
            ? this.foldersById[a]?.section
            : t.toSection ?? i.section);
    }
    removeCollectionFromOldPlace(e, t) {
      if (e.folderUuid) {
        let s = this.foldersById[e.folderUuid];
        return (
          g(s, "Old parent cannot be undefined"),
          (s.children = s.children.filter((a) => a.uuid !== e.uuid)),
          s.uuid
        );
      }
      let r =
        e.type === "folder"
          ? e.section
          : this.foldersById[e.folderUuid]?.section;
      g(r, "Folder section cannot be undefined");
      let i = this.workspaceRepository.getWorkspaceIdForWindow(t);
      return (
        g(
          i,
          "Couldnt remove collection from old place: no workspace id for window",
          { windowId: t }
        ),
        this.deleteRootCollection(i, r, e.uuid),
        null
      );
    }
    pasteCollectionToNewPlace(e, t, r, i) {
      if (t) {
        let s = this.foldersById[t];
        g(s, "Parent doesnt exists");
        let a = r.index ?? s.children.length;
        s.children.splice(a, 0, e), (e.folderUuid = s.uuid);
      } else {
        if (e.type !== "folder") return;
        this.insertCollectionToRoot(e, r?.toSection ?? e.section, i, r.index);
      }
    }
    insertCollectionToRoot(e, t, r, i) {
      let s = this.workspaceRepository.getWorkspaceIdForWindow(r);
      g(s, "Failed to insert collection to root: no workspaceId for window", {
        windowId: r,
      });
      let a = this.collectionsByWorkspaceId[s];
      g(
        a,
        "Failed to insert collection to root: no collections for workspace id",
        { workspaceId: s }
      );
      let n = this.collectionsByWorkspaceId[s]?.[t];
      g(
        n,
        "Failed to insert collection to root: no destination section for workspace id",
        { workspaceId: s, toSection: t }
      ),
        n.splice(i ?? n.length, 0, e);
    }
    deleteRootCollection(e, t, r) {
      let i = this.collectionsByWorkspaceId[e];
      g(
        i,
        "Failed to delete root collection: no collection to delete for workspace id",
        { workspaceId: e }
      ),
        (this.collectionsByWorkspaceId[e][t] = i[t].filter(
          (s) => s.uuid !== r
        ));
    }
    getParentById(e) {
      let t = this.foldersById[e],
        r = this.linksById[e],
        i = t ?? r;
      return (
        g(i, "Couldnt find parent node by id: no node"),
        i.folderUuid ? this.foldersById[i.folderUuid] ?? null : null
      );
    }
    async loadCollectionsByWorkspaceId(e) {
      let t = await this.backendService.collection.getCollectionsByWorkspaceId(
          e
        ),
        r = De.parseCollections(t);
      (this.collectionsByWorkspaceId[e] = r),
        this.refillFoldersById(r, e),
        this.logger.info(`Collections for workspace ${e} loaded`, r),
        we.emit("collections-loaded", r);
    }
    refillFoldersById(e, t) {
      let r = (i, s) => {
        if (!oe(i, "children")) {
          this.linksById[i.uuid] = i;
          return;
        }
        i.children.forEach((a) => r(a, s)),
          (i.workspaceId = t),
          (this.foldersById[i.uuid] = i),
          (this.foldersById[i.uuid].section = s);
      };
      e.team.forEach((i) => r(i, "team")),
        e.shared.forEach((i) => r(i, "shared")),
        e.private.forEach((i) => r(i, "private"));
    }
  };
var PS = (o, e, t, r, i, s, a, n, p, d, u, m) => {
  let y = new qc(o, t, i),
    b = new Hc(r, a),
    v = new $c(o, y, e, r, a, i, s, t, d, p, u, m),
    S = new Vc(b, r, s, p);
  return [y, v, b, S];
};
c();
c();
var zc = class {
  constructor(e, t, r, i) {
    this.sessionRepository = e;
    this.sessionService = t;
    this.sessionTabsService = r;
    this.sessionTabGroupsService = i;
  }
  createSession(e) {
    this.sessionService.createSession(e);
  }
  saveSession(e) {
    this.sessionRepository.updateSession(e, { isTemporary: !1 });
  }
  renameSession(e, t) {
    this.sessionRepository.updateSession(e, { name: t });
  }
  deactivateSession(e) {
    return this.sessionService.deactivateSession(e);
  }
  deleteSession(e) {
    this.sessionService.deleteSession(e);
  }
  deleteSessionsByWorkspace(e) {
    this.sessionRepository.getSessionsByWorkspaceId(e).forEach(({ id: r }) => {
      this.deleteSession(r);
    });
  }
  focusSessionWindow(e) {
    return this.sessionService.focusSessionWindow(e);
  }
  createWindowForSession(e) {
    return this.sessionService.createWindowForSession(e);
  }
  prepareDataForNewWorkspaceWindow(e, t) {
    if (t) return;
    let [r] = this.sessionRepository.getSessionsByLastUsedByWorkspaceId(e);
    return r
      ? { sessionTabs: this.sessionRepository.getOrderedTabs(r.id), session: r }
      : void 0;
  }
  switchWindowSession(e, t) {
    return this.sessionService.switchWindowSession(e, t);
  }
  changeSessionTabPinning(e, t, r) {
    return this.sessionTabsService.changeSessionTabPinning(e, t, r);
  }
  changeSessionTabMuting(e, t, r) {
    return this.sessionTabsService.changeSessionTabMuting(e, t, r);
  }
  reorderSessionTab(e, t, r, i) {
    return this.sessionTabsService.reorderSessionTab(e, t, r, i);
  }
  moveSessionTabToAnotherSession(e, t, r, i) {
    return this.sessionTabsService.moveSessionTabToAnotherSession(e, t, r, i);
  }
  openSessionTab(e, t) {
    return this.sessionTabsService.openSessionTab(e, t);
  }
  openLastActiveSessionTabInWindow(e) {
    let t = this.sessionRepository.getSessionByWindowId(e);
    return t?.lastActiveSessionTabId
      ? this.sessionTabsService.openSessionTab(e, t.lastActiveSessionTabId)
      : Promise.resolve();
  }
  reloadSessionTab(e, t) {
    return this.sessionTabsService.reloadSessionTab(e, t);
  }
  deleteSessionTab(e, t) {
    return this.sessionTabsService.deleteSessionTab(e, t);
  }
  deleteOtherSessionTabs(e, t) {
    return this.sessionTabsService.deleteOtherSessionTabs(e, t);
  }
  duplicateSessionTab(e, t) {
    return this.sessionTabsService.duplicateSessionTab(e, t);
  }
  ungroupTabsFromTabGroup(e, t) {
    return this.sessionTabGroupsService.ungroupTabsFromTabGroup(e, t);
  }
  createTabGroup(e, t, r) {
    return this.sessionTabGroupsService.createTabGroup(e, t, r);
  }
  updateTabGroup(e, t, r) {
    return this.sessionTabGroupsService.updateTabGroup(e, t, r);
  }
  removeTabFromTabGroup(e, t) {
    return this.sessionTabGroupsService.removeTabFromTabGroup(e, t);
  }
  closeTabGroup(e, t) {
    let i = this.sessionRepository.getSessionById(e)?.tabsByGroupId[t];
    i && i.map((s) => this.sessionTabsService.deleteSessionTab(e, s));
  }
  openNewTabInTabGroup(e, t) {
    return this.sessionTabGroupsService.openNewTabInTabGroup(e, t);
  }
  addTabToTabGroup(e, t, r) {
    return this.sessionTabGroupsService.addTabToTabGroup(e, t, r);
  }
  mapSessionsToUI(e) {
    return e.map((r) => {
      let { pinnedTabs: i, regularTabs: s } =
        this.getPinnedAndRegularSessionTabs(r);
      return {
        ...r,
        tabsList: this.sessionRepository.getOrderedTabs(r.id),
        windowId: this.sessionRepository.getWindowIdBySessionId(r.id),
        tabGroups: this.getUITabGroupsForSession(r),
        regularTabs: s,
        pinnedTabs: i,
      };
    });
  }
  getUITabGroupsForSession(e) {
    let t = [];
    return (
      Object.entries(e.tabsByGroupId).forEach(([r, i]) => {
        let s = this.sessionRepository.getTabGroup(e.id, r);
        if (!s) return;
        let n = [
          ...i.reduce((p, d) => {
            let u = this.sessionRepository.getTab(e.id, d);
            return u ? [...p, u] : p;
          }, []),
        ].sort(
          (p, d) =>
            this.sessionRepository.getIndexOfTab(e.id, p.id) -
            this.sessionRepository.getIndexOfTab(e.id, d.id)
        );
        t.push({ ...s, tabs: n });
      }),
      t
    );
  }
  saveSessionBeforeSignOut(e) {
    let t = this.sessionRepository.getSessionByWindowId(e);
    t &&
      this.sessionRepository.updateSession(t.id, { lastTimeUsed: Date.now() });
  }
  getPinnedAndRegularSessionTabs(e) {
    let t = this.sessionRepository.getOrderedTabs(e.id),
      r = [],
      i = [];
    return (
      t.forEach((s) => {
        if (s.pinned) {
          r.push(s);
          return;
        }
        this.sessionRepository.getIsTabInTabGroup(s.id, e) || i.push(s);
      }),
      { pinnedTabs: r, regularTabs: i }
    );
  }
};
c();
c();
var ls = "Untitled",
  RS = new RegExp(`^${ls} ([\\d]+)$`),
  ES = "session.restore_on_startup";
c();
var at = class {
  static createTemporarySession(e, t = 0) {
    return {
      id: le(),
      workspaceId: e,
      updatedAt: Date.now(),
      lastTimeUsed: t,
      isTemporary: !0,
      tabsById: {},
      tabsOrder: [],
      tabGroupsById: {},
      tabsByGroupId: {},
    };
  }
  static createSession({
    id: e = le(),
    workspaceId: t,
    name: r,
    lastTimeUsed: i = 0,
    isTemporary: s = !1,
  }) {
    return {
      id: e,
      workspaceId: t,
      updatedAt: Date.now(),
      name: r,
      isTemporary: s,
      tabsById: {},
      tabsOrder: [],
      tabGroupsById: {},
      tabsByGroupId: {},
      lastTimeUsed: i,
    };
  }
  static createTabGroup({ color: e, collapsed: t, title: r, id: i }, s) {
    return { id: s ?? le(), color: e, collapsed: t, title: r, browserId: i };
  }
  static copyTab(e) {
    return { ...Ie(e, ["browserId", "partitionId"]), id: le() };
  }
  static convertBrowserTabToTab(e, t) {
    let r = e.url || e.pendingUrl;
    return {
      id: t ?? le(),
      browserId: e.id,
      url: r ?? "",
      favIconUrl: e.favIconUrl,
      partitionId: e.partitionName,
      title: e.title,
      pinned: e.pinned,
      muted: e.mutedInfo?.muted,
      audible: e.audible,
    };
  }
};
var Qc = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m) {
    this.sessionRepository = e;
    this.workspaceRepository = t;
    this.extraDataService = r;
    this.browserEventsService = i;
    this.browserService = s;
    this.sessionTabGroupsService = a;
    this.windowHeadlessService = n;
    this.onboardingDataService = p;
    this.userApi = d;
    this.featureFlagsRepository = u;
    this.billingRepository = m;
  }
  initSessions(e, t) {
    this.onboardingDataService.getIsAfterOnboarding() &&
      this.createDefaultSession(e[0]),
      e.forEach((r) => {
        if (!r.id || this.sessionRepository.getSessionByWindowId(r.id)) return;
        let s = this.extraDataService.getWindowExtraData(r);
        if (s?.sessionId && t)
          try {
            this.mapBrowserTabsToSessionTabs(r, s.sessionId);
            return;
          } catch {}
        let a = this.workspaceRepository.getWorkspaceIdForWindow(r.id);
        g(a, "No workspace for window on initial");
        let n = at.createTemporarySession(a);
        this.sessionRepository.addSession(n),
          r.tabs
            ? this.mapBrowserTabsToSessionTabs(r, n.id)
            : this.activateSession(r.id, n),
          this.extraDataService
            .ensureWindowExtraData([{ session: n, windowId: r.id }])
            .catch(l);
      }),
      this.extraDataService
        .ensureTabExtraData(this.sessionRepository.getAllTabs())
        .catch(l);
  }
  initListeners() {
    re.on("workspaces-loaded", (e, t) => {
      t && this.createDefaultWorkspacesSession(t);
    }),
      this.browserEventsService.subscribeToNormalWindowCreated(
        this.onWindowCreated.bind(this)
      ),
      this.browserEventsService.subscribeToWindowRemoved(
        this.onWindowRemoved.bind(this)
      );
  }
  async processMissedWindows([e], t) {
    if (
      !e ||
      e.partitionDomain === void 0 ||
      e.type !== "normal" ||
      !e.id ||
      !t ||
      this.extraDataService.getWindowExtraData(e)?.sessionId
    )
      return;
    let s = this.workspaceRepository.getWorkspaceIdByPartition(
      e.partitionDomain
    );
    if (!s) return;
    let [a, n] = this.sessionRepository.getSessionsByLastUsedByWorkspaceId(s),
      d = a?.isTemporary ? n : a;
    d
      ? await this.switchWindowSession(d.id, e.id)
      : this.createTemporarySessionForWindow(s, e.id);
  }
  createSession(e) {
    let t = e.isTemporary ? void 0 : e.name || this.getDefaultSessionName(),
      r = at.createSession({ ...e, name: t });
    return this.sessionRepository.addSession(r);
  }
  activateSession(e, t) {
    this.sessionRepository.setActiveSessionByWindowId(e, t.id);
  }
  async deactivateSession(e) {
    try {
      await this.browserService.closeWindow(e);
    } catch {
      this.sessionRepository.deactivateSessionByWindowId(e);
    }
  }
  deleteSession(e) {
    this.sessionRepository.deleteSession(e);
  }
  focusSessionWindow(e) {
    return this.browserService.focusWindow(e);
  }
  async createWindowForSession(e) {
    let t = this.sessionRepository.getSessionById(e);
    if (!t) return;
    let r = this.sessionRepository.getOrderedTabs(e),
      i = this.extraDataService.createWindowData(t.id, !0, r.length),
      s = t.lastActiveSessionTabId,
      a = await this.browserService.createWindowWithTabs(i, r, s);
    !r.length ||
      !a?.id ||
      (await this.sessionTabGroupsService.openTabGroups(a.id, e));
  }
  async switchWindowSession(e, t, r = !1) {
    let i = this.sessionRepository.getSessionByWindowId(t),
      s = this.sessionRepository.getOrderedTabs(e);
    if (e === i?.id && !r) return;
    i && this.sessionRepository.deactivateSessionByWindowId(t);
    let a = this.sessionRepository.setActiveSessionByWindowId(t, e);
    this.removeRecentlyClosed(a.id).catch(l),
      this.extraDataService
        .ensureWindowExtraData([{ session: a, windowId: t }])
        .catch(l);
    let n = a.lastActiveSessionTabId;
    try {
      this.windowHeadlessService.lockWindow(t),
        await this.browserService.switchWindowTabs(s, t, n);
    } finally {
      this.windowHeadlessService.unlockWindow(t);
    }
    await this.sessionTabGroupsService.openTabGroups(t, e);
  }
  async getShouldRestoreOnStartup() {
    return (await this.browserService.getPref(ES)).value === 1;
  }
  createTemporarySessionForWindow(e, t) {
    let r = at.createTemporarySession(e);
    this.sessionRepository.addSession(r),
      this.sessionRepository.setActiveSessionByWindowId(t, r.id, !0),
      pe.emit("session-created-from-window", { session: r, windowId: t }),
      this.extraDataService
        .ensureWindowExtraData([{ session: r, windowId: t }])
        .catch(fe);
  }
  onWindowRemoved(e) {
    this.sessionRepository.deactivateSessionByWindowId(e);
  }
  onWindowCreated(e) {
    if (!e.id || e.partitionDomain === void 0) return;
    let t = this.workspaceRepository.getWorkspaceIdByPartition(
      e.partitionDomain
    );
    if (!t) return;
    let r = this.extraDataService.getWindowExtraData(e),
      i = r?.sessionId
        ? this.sessionRepository.getSessionById(r?.sessionId)
        : this.sessionRepository.getSessionByWindowId(e.id);
    if (!i) {
      this.createTemporarySessionForWindow(t, e.id);
      return;
    }
    this.sessionRepository.setActiveSessionByWindowId(e.id, i.id),
      this.removeRecentlyClosed(i.id).catch(l);
  }
  mapBrowserTabsToSessionTabs(e, t) {
    if (!e.id) return;
    let r = this.sessionRepository.setActiveSessionByWindowId(e.id, t);
    e.tabs?.forEach((i) => {
      let s = this.extraDataService.getTabExtraData(i),
        a = s?.sessionTabId;
      if (Boolean(s?.app) || !i.id) {
        a && delete r.tabsById[a];
        return;
      }
      let p = a ? r.tabsById[a] : void 0,
        d = p ?? at.convertBrowserTabToTab(i, a);
      (r.tabsById[d.id] = { ...d, browserId: i.id }),
        !p && r.tabsOrder.push(d.id);
    }),
      Object.values(r.tabsById).forEach((i) => {
        i.browserId || delete r.tabsById[i.id];
      }),
      r.tabsOrder.forEach((i, s) => {
        r.tabsById[i] || r.tabsOrder.splice(s, 1);
      }),
      this.sessionRepository.updateSession(r.id, r);
  }
  createDefaultWorkspacesSession(e) {
    let t = new Set();
    this.sessionRepository.getSessionsArray().forEach((i) => {
      t.add(i.workspaceId);
    }),
      e.forEach((i) => {
        if (t.has(i.id)) return;
        let s = at.createSession({ workspaceId: i.id, name: i.name });
        this.sessionRepository.addSession(s);
      });
  }
  async removeRecentlyClosed(e) {
    let t = (await this.browserService.getRecentlyClosed())
      .filter((r) =>
        r.window
          ? this.extraDataService.getWindowExtraData(r.window)?.sessionId === e
          : !1
      )
      .map((r) => r.window?.sessionId);
    await Promise.all(
      t.map((r) => this.browserService.removeRecentlyClosedItem(r))
    );
  }
  createDefaultSession(e) {
    let t = this.workspaceRepository.getDefaultWorkspaceId();
    g(t, "Not default workspace ID while creating first session");
    let r = at.createSession({ workspaceId: t, name: "Getting Started" }),
      i = this.sessionRepository.addSession(r);
    e?.id &&
      (this.activateSession(e.id, i),
      e.tabs?.forEach((s) => {
        let a = at.convertBrowserTabToTab(s);
        (i.tabsById[a.id] = a),
          i.tabsOrder.push(a.id),
          s.active && (i = { ...i, lastActiveSessionTabId: a.id });
      }),
      this.sessionRepository.updateSession(i.id, i),
      this.extraDataService
        .ensureWindowExtraData([{ session: i, windowId: e.id }])
        .catch(l),
      this.extraDataService
        .ensureTabExtraData(Object.values(i.tabsById))
        .catch(l));
  }
  getDefaultSessionName() {
    let e = this.sessionRepository
      .getSessionsArray()
      .reduce((t, { name: r }) => {
        if (!r) return t;
        if (t === 0 && r === ls) return 1;
        let i = RS.exec(r);
        if (!i?.[1]) return t;
        let s = parseInt(i[1], 10);
        return t > s ? t : s;
      }, 0);
    return e > 0 ? `${ls} ${e + 1}` : ls;
  }
};
c();
c();
var BS = "sidekick.sync.sessions_visible",
  Sh = "sidekick.sync.sessions",
  Yc = class {
    constructor(e, t, r, i, s, a, n, p, d, u, m, y, b) {
      this.browserStorage = e;
      this.backendService = t;
      this.sessionRepository = r;
      this.featureFlagsRepository = i;
      this.encryptionService = s;
      this.browserEventsService = a;
      this.browserService = n;
      this.workspaceRepository = p;
      this.sessionService = d;
      this.sessionTabsEventsListener = u;
      this.analyticsTracker = m;
      this.userRepository = y;
      this.sessionTabGroupsService = b;
    }
    interval = null;
    intervalTimeoutSeconds = 0;
    syncOnStart = !1;
    lastSyncTime = 0;
    isQueueBlocked = !1;
    sessionsQueueToUpdate = new Set();
    sessionsQueueToDelete = new Set();
    sessionsQueueToDecrypt = new Set();
    async init() {
      await this.loadLastSyncDate(),
        await this.tryStartSyncing(),
        this.startListeners();
    }
    startListeners() {
      this.featureFlagsRepository.onFeatureFlagsLoaded(() => {
        this.tryStartSyncing().catch(l);
      }),
        W.on("user-loaded", () => {
          this.tryStartSyncing().catch(l);
        }),
        this.browserEventsService.subscribeToPrefsChanged((e) => {
          let t = e.find((i) => i.key === Sh);
          if (!t) return;
          let r = Boolean(t.value);
          this.tryStartSyncing(r).catch(l),
            this.analyticsTracker.sendAnalyticsEvent(
              r
                ? "system.browser-settings-syncsessions-on"
                : "system.browser-settings-syncsessions-off",
              void 0
            );
        }),
        this.browserEventsService.subscribeOnBeforeShutdown(() => {
          if (!this.interval) {
            this.browserService.ackShutdown();
            return;
          }
          this.updateRemoteSessions()
            .then(() => {
              this.browserService.ackShutdown();
            })
            .catch(l);
        }),
        pe.on("session-changed", (e, t, r, i) => {
          if (i) {
            this.addToDeleteQueue(t?.externalUUID);
            return;
          }
          this.addToUpdateQueue(e);
        }),
        pe.on("session-tab-group-changed", (e) => {
          this.addToUpdateQueue(e);
        }),
        pe.on("session-tab-changed", (e) => {
          this.addToUpdateQueue(e);
        }),
        this.encryptionService.onKeysetLoaded(() => {
          let e = [...this.sessionsQueueToDecrypt];
          this.sessionsQueueToDecrypt.clear(),
            this.processSessionsDecrypt(e)
              .then(() => {
                this.sessionsQueueToDecrypt.size !== 0 &&
                  l(new L("Sessions not decrypt after keyset reloading"));
              })
              .catch(l);
        });
    }
    async tryStartSyncing(e) {
      let t = this.userRepository.getIsTemporaryUser();
      if (!this.isSyncFeatureEnabled() || t) {
        await this.disable();
        return;
      }
      if ((this.setPref(BS, !0).catch(l), !(e ?? (await this.getPref(Sh))))) {
        this.clearInterval();
        return;
      }
      this.tryStartNewInterval(),
        !this.syncOnStart &&
          ((this.syncOnStart = !0), await this.syncSessions());
    }
    tryStartNewInterval() {
      let e = this.getInterval();
      (this.interval && this.intervalTimeoutSeconds === e) ||
        (this.clearInterval(),
        (this.intervalTimeoutSeconds = e),
        (this.interval = setInterval(() => {
          this.syncSessions().catch(l);
        }, ce(this.intervalTimeoutSeconds))));
    }
    async syncSessions() {
      (this.isQueueBlocked = !0),
        this.addLocalSessionsToPublishing(),
        await this.loadRemoteSessions(),
        (this.isQueueBlocked = !1),
        await this.updateRemoteSessions();
    }
    async loadRemoteSessions() {
      let e = Math.trunc(Ue(this.lastSyncTime)) + 1,
        t = await this.backendService.sessions.getSessions({ timestamp: e });
      return this.processSessionsDecrypt(t.collection);
    }
    processSessionsDecrypt(e) {
      let t = e.map(async (r) => {
        if (r.deleted_at || !r.data) {
          await this.handleSessionDelete(r.uuid);
          return;
        }
        try {
          let a = {
              ...(await this.encryptionService.decryptLocal(r.data)),
              externalUUID: r.uuid,
              updatedAt: r.updated_at,
            },
            n = this.sessionRepository.getSessionById(a.id);
          n
            ? this.handleSessionUpdate(n, a)
            : this.sessionRepository.addSession(a);
        } catch {
          this.sessionsQueueToDecrypt.add(r);
        }
      });
      return Promise.all(t);
    }
    async handleSessionDelete(e) {
      let t = this.sessionRepository.getSessionByExternalUUID(e);
      if (!t) return;
      let r = this.sessionRepository.getWindowIdBySessionId(t.id);
      r && (await this.updateWindowForDeletedSession(t, r)),
        this.sessionRepository.deleteSession(t.id);
    }
    updateWindowForDeletedSession(e, t) {
      if (this.sessionRepository.getActiveSessionsLength() > 1)
        return this.sessionService.deactivateSession(t);
      let s = this.sessionRepository
        .getSessionsByLastUsedByWorkspaceId(e.workspaceId)
        .find((n) => n.id !== e.id);
      if (s) return this.sessionService.switchWindowSession(s.id, t);
      let a = this.sessionService.createSession({
        isTemporary: !0,
        workspaceId: e.workspaceId,
      });
      return this.sessionService.switchWindowSession(a.id, t);
    }
    handleSessionUpdate(e, t) {
      if ((e.updatedAt ?? 0) >= (t.updatedAt ?? 0)) return;
      this.sessionRepository.updateSession(t.id, t);
      let r = this.sessionRepository.getWindowIdBySessionId(t.id);
      !r ||
        !this.shouldUpdateSessionWindow(e, t) ||
        (Object.entries(t.tabsByGroupId).forEach(([s, a]) => {
          this.sessionTabGroupsService.preventFromTabGroupRemoving(s),
            a.forEach((n) => {
              this.sessionTabsEventsListener.preventFromTabGroupRemoving(n);
            });
        }),
        this.sessionService
          .switchWindowSession(t.id, r, !0)
          .then(() => {
            this.sessionTabGroupsService.clearProtectingQueue(),
              this.sessionTabsEventsListener.clearProtectingQueue();
          })
          .catch(l));
    }
    shouldUpdateSessionWindow(e, t) {
      return e.tabsOrder.length !== t.tabsOrder.length ||
        e.tabsOrder.some((n, p) => t.tabsOrder[p] !== n) ||
        Object.entries(e.tabsByGroupId).length !==
          Object.entries(t.tabsByGroupId).length
        ? !0
        : Object.values(e.tabGroupsById).some((n) => !t.tabGroupsById[n.id]);
    }
    addLocalSessionsToPublishing() {
      let e = this.lastSyncTime === 0;
      this.sessionRepository.getSessionsArray().forEach((t) => {
        t.isTemporary || (t.externalUUID && !e) || this.addToUpdateQueue(t.id);
      });
    }
    async updateRemoteSessions() {
      let e = [];
      this.sessionsQueueToUpdate.forEach((t) => {
        let r = this.sessionRepository.getSessionById(t);
        r &&
          (r.externalUUID
            ? e.push(this.patchRemoteSession(r))
            : e.push(this.createRemoteSession(r)));
      }),
        this.sessionsQueueToDelete.forEach((t) => {
          t && e.push(this.deleteRemoteSession(t));
        }),
        await Promise.all(e),
        this.sessionsQueueToDelete.clear(),
        this.sessionsQueueToUpdate.clear(),
        await this.updateLastSyncDate();
    }
    async createRemoteSession(e) {
      if (e.isTemporary) return;
      let t = await this.encryptSession(e);
      if (!t) return;
      let r = await this.backendService.sessions.postSession({
        data: t,
        workspace_uuid: e.workspaceId,
      });
      this.sessionRepository.updateSession(e.id, { externalUUID: r.uuid });
    }
    async patchRemoteSession(e) {
      if (!e.externalUUID || e.isTemporary) return;
      let t = await this.encryptSession(e);
      if (t)
        try {
          await this.backendService.sessions.patchSession(e.externalUUID, {
            data: t,
          });
        } catch (r) {
          r instanceof lt &&
            r.status === 404 &&
            (await this.createRemoteSession(e));
        }
    }
    async deleteRemoteSession(e) {
      try {
        await this.backendService.sessions.deleteSession(e);
      } catch (t) {
        if (t instanceof lt && t.status === 404) return;
        l(t);
      }
    }
    encryptSession(e) {
      return this.encryptionService.encryptLocal(e);
    }
    disable() {
      return (
        this.clearInterval(),
        Promise.all([this.setPref(BS, !1), this.setPref(Sh, !1)])
      );
    }
    clearInterval() {
      this.interval && clearInterval(this.interval);
    }
    addToUpdateQueue(e) {
      this.isQueueBlocked || this.sessionsQueueToUpdate.add(e);
    }
    addToDeleteQueue(e) {
      this.isQueueBlocked || !e || this.sessionsQueueToDelete.add(e);
    }
    async getPref(e) {
      let { value: t } = await this.browserService.getPref(e);
      return t;
    }
    setPref(e, t) {
      return this.browserService.setPref(e, t);
    }
    isSyncFeatureEnabled() {
      return this.featureFlagsRepository.getFeatureFlag("syncSessionsEnabled");
    }
    getInterval() {
      return this.featureFlagsRepository.getFeatureFlag("syncSessions")
        .syncIntervalSeconds;
    }
    async loadLastSyncDate() {
      let e = await this.browserStorage.getItem("sessions-sync-last-update");
      this.lastSyncTime = e ?? 0;
    }
    updateLastSyncDate() {
      let e = Date.now();
      return (
        (this.lastSyncTime = e),
        this.browserStorage.setItem("sessions-sync-last-update", e)
      );
    }
  };
c();
var Xc = class {
  constructor(e, t, r, i, s) {
    this.sessionRepository = e;
    this.browserEventsService = t;
    this.extraDataService = r;
    this.browserService = i;
    this.sessionTabsEventsListener = s;
  }
  queueForTabGroupProtecting = new Set();
  initListeners() {
    this.browserEventsService.subscribeToTabGroupCreated(
      this.onTabGroupCreated.bind(this)
    ),
      this.browserEventsService.subscribeToTabGroupUpdated(
        this.onTabGroupUpdated.bind(this)
      ),
      this.browserEventsService.subscribeToTabGroupRemoved(
        this.onTabGroupRemoved.bind(this)
      );
  }
  async initTabGroups() {
    (await this.browserService.getAllTabGroups()).forEach((t) => {
      this.onTabGroupCreated(t);
    });
  }
  async openTabGroups(e, t) {
    let r = [],
      i = this.sessionRepository.getSessionById(t);
    g(i, "No session while opening tab groups"),
      Object.values(i.tabGroupsById).forEach((s) => {
        let a = i.tabsByGroupId[s.id],
          n = [];
        a?.forEach((p) => {
          let d = i.tabsById[p]?.browserId;
          d && n.push(d);
        }),
          r.push({
            id: s.id,
            collapsed: s.collapsed,
            title: s.title,
            color: s.color,
            tabIds: n,
          });
      }),
      await Promise.all(
        r.map(async (s) => {
          let { extraData: a } = this.extraDataService.createTabGroupExtraData(
            s.id
          );
          await this.createTabGroup(e, t, s, a);
        })
      );
  }
  preventFromTabGroupRemoving(e) {
    this.queueForTabGroupProtecting.add(e);
  }
  clearProtectingQueue() {
    this.queueForTabGroupProtecting.clear();
  }
  async createTabGroup(e, t, r, i) {
    try {
      let s = await this.browserService.createTabGroup(e, [...r.tabIds], i);
      await this.browserService.updateTabGroup(s, {
        title: r.title,
        collapsed: r.collapsed,
        color: r.color,
      });
    } catch (s) {
      this.sessionRepository.deleteTabGroup(t, r.id), fe(s);
    }
  }
  async updateTabGroup(e, t, r) {
    let i = this.sessionRepository.getTabGroup(e, t);
    g(i?.browserId, "No tab group browserId when updating"),
      await this.browserService.updateTabGroup(i.browserId, r);
  }
  async addTabToTabGroup(e, t, r) {
    let i = this.sessionRepository.getTabGroup(e, r);
    if (!i?.browserId) return;
    let s = this.sessionRepository.getTab(e, t);
    s?.browserId &&
      (await this.browserService.addTabsToExistingTabGroup(
        [s.browserId],
        i.browserId
      ));
  }
  async removeTabFromTabGroup(e, t) {
    let r = this.sessionRepository.getTab(e, t);
    r?.browserId && (await this.browserService.ungroupTabs([r.browserId]));
  }
  async openNewTabInTabGroup(e, t) {
    let r = this.sessionRepository.getTabGroup(e, t);
    if (!r?.browserId) return;
    let i = await this.browserService.createNTP();
    i?.id &&
      (await this.browserService.addTabsToExistingTabGroup(
        [i.id],
        r.browserId
      ));
  }
  async ungroupTabsFromTabGroup(e, t) {
    let i = this.sessionRepository.getSessionById(e)?.tabsByGroupId[t];
    if (!i) return;
    let s = i.reduce((a, n) => {
      let p = this.sessionRepository.getTab(e, n)?.browserId;
      return p && a.push(p), a;
    }, []);
    await this.browserService.ungroupTabs(s);
  }
  onTabGroupCreated(e) {
    let t = this.sessionRepository.getSessionByWindowId(e.windowId)?.id;
    if (
      (g(t, "No session id for tab group on created"),
      this.extraDataService.getTabGroupExtraData(e)?.sessionTabGroupId)
    ) {
      this.onTabGroupUpdated(e);
      return;
    }
    let s = at.createTabGroup(e);
    this.sessionRepository.addTabGroup(t, s),
      this.extraDataService.ensureTabGroupExtraData([s]).catch(fe),
      this.sessionTabsEventsListener.flushFromQueue(s.browserId, s.id);
  }
  onTabGroupUpdated(e) {
    let t = this.sessionRepository.getSessionByWindowId(e.windowId)?.id;
    g(t, "No session id for tab group on updated");
    let i = this.extraDataService.getTabGroupExtraData(e)?.sessionTabGroupId;
    i &&
      this.sessionRepository.updateTabGroup(t, i, {
        title: e.title,
        collapsed: e.collapsed,
        color: e.color,
        browserId: e.id,
      });
  }
  onTabGroupRemoved(e, t) {
    let r = this.sessionRepository.getSessionByWindowId(e.windowId);
    g(r, "No session id for tab group on removed");
    let s = this.extraDataService.getTabGroupExtraData(e)?.sessionTabGroupId;
    if (
      (g(s, "No tab group id on removed"), t.isWindowClosing && !r.isTemporary)
    ) {
      this.sessionRepository.updateTabGroup(r.id, s, { browserId: void 0 });
      return;
    }
    if (this.queueForTabGroupProtecting.has(s)) {
      this.queueForTabGroupProtecting.delete(s);
      return;
    }
    this.sessionRepository.deleteTabGroup(r.id, s);
  }
};
c();
var kE = -1,
  Jc = class {
    constructor(e, t, r, i, s, a, n, p) {
      this.sessionRepository = e;
      this.browserService = t;
      this.extraDataService = r;
      this.tabStripObserver = i;
      this.browserEventsService = s;
      this.featureFlagsRepository = a;
      this.sidecarAppearanceService = n;
      this.sessionTabsService = p;
    }
    queueForTabGroup = new Map();
    queueForTabGroupProtecting = new Set();
    initListeners() {
      this.browserEventsService.subscribeToTabActivated(
        this.onTabActivated.bind(this)
      ),
        this.browserEventsService.subscribeToTabAttached(
          this.onTabAttached.bind(this)
        ),
        this.browserEventsService.subscribeToTabCreated(
          this.onTabCreated.bind(this)
        ),
        this.browserEventsService.subscribeToTabDetached(
          this.onTabDetached.bind(this)
        ),
        this.browserEventsService.subscribeToTabMoved(
          this.onTabMoved.bind(this)
        ),
        this.browserEventsService.subscribeToTabRemoved(
          this.onTabRemoved.bind(this)
        ),
        this.browserEventsService.subscribeToTabReplaced(
          this.onTabReplaced.bind(this)
        ),
        this.browserEventsService.subscribeToTabUpdated(
          this.onTabUpdated.bind(this)
        );
    }
    preventFromTabGroupRemoving(e) {
      this.queueForTabGroupProtecting.add(e);
    }
    clearProtectingQueue() {
      this.queueForTabGroupProtecting.clear();
    }
    flushFromQueue(e, t) {
      let r = this.queueForTabGroup.get(e);
      r &&
        (this.sessionRepository.updateGroupForTab(r.sessionId, r.tabId, t),
        this.queueForTabGroup.delete(e));
    }
    async onTabCreated(e) {
      if (!this.tabStripObserver.isTabOfNormalWindow(e)) return;
      let r = this.extraDataService.getTabExtraData(e),
        i = Boolean(r?.app),
        s = r?.sessionTabId,
        a = s && this.sessionRepository.getTabByWindowIdAndTabId(e.windowId, s);
      if (i && a) {
        this.sessionRepository.deleteTabByWindowId(e.windowId, a.id);
        return;
      }
      let n = this.sessionRepository.getSessionByWindowId(e.windowId);
      if (!i && !a) {
        let p = this.createNewSessionTab(e),
          { shouldOpenNewTabsOnTop: d } =
            this.featureFlagsRepository.getFeatureFlag("verticalTabs");
        if (
          this.sidecarAppearanceService.getIsVerticalTabsModeEnabled() &&
          d &&
          p.url.startsWith("chrome://newtab") &&
          p.browserId &&
          n?.id
        ) {
          let m = this.sessionRepository.getIndexOfTab(n.id, p.id);
          await this.sessionTabsService.reorderSessionTab(
            e.windowId,
            n.id,
            m,
            0
          );
        }
        return;
      }
      a &&
        n &&
        this.sessionRepository.updateTab(n.id, a.id, { browserId: e.id });
    }
    createNewSessionTab(e) {
      let {
        tab: t,
        tabId: r,
        sessionTabId: i,
        sessionIdOfWindow: s,
      } = this.ensureIdForNewSessionTab(e);
      i && this.removeRecentlyClosed(i).catch(l);
      let a = this.sessionRepository.getAllHiddenPinnedSessionTabs(s, i),
        n =
          this.tabStripObserver.getInternalIndexForIndex(e.windowId, r) +
          a.length,
        p = this.sessionRepository.getTabGroupByBrowserId(s, t.groupId)?.id;
      i &&
        this.sessionRepository.getTab(s, i) &&
        this.sessionRepository.deleteTab(s, i);
      let d = at.convertBrowserTabToTab(e),
        u = this.sessionRepository.addTab(s, d, n, p);
      return (
        e.active && this.updateLastActiveSessionTabId(s, d.id),
        this.extraDataService.ensureTabExtraData([d]).catch(l),
        u
      );
    }
    async onTabUpdated(e, t, r) {
      if (t.hidden === !1) {
        await this.onTabCreated(r);
        return;
      }
      let s = this.extraDataService.getTabExtraData(r)?.sessionTabId,
        a = this.sessionRepository.getSessionByWindowId(r.windowId)?.id;
      g(a, "No session for tab while updating");
      let n = this.sessionRepository.getTabByWindowId(r.windowId, e),
        p = s
          ? this.sessionRepository.getTabByWindowIdAndTabId(r.windowId, s)
          : n;
      if (((p ??= n), !p)) return;
      let d = Wo(t, "groupId") && !t.isWindowClosing;
      if (
        !(
          ["url", "title", "favIconUrl", "pinned", "mutedInfo", "audible"].some(
            (b) => Wo(t, b)
          ) || d
        )
      )
        return;
      let y = r.url || r.pendingUrl || p.url;
      if (!y) {
        let b = t.title?.trim();
        !b?.endsWith("...") &&
          !b?.endsWith("\u2026") &&
          !d &&
          l(
            new L("Session tab is saved with empty url", { extra: { info: t } })
          );
      }
      if (t.groupId) {
        let b = this.sessionRepository.getTabGroupByBrowserId(a, t.groupId)?.id;
        if (kE === t.groupId) {
          if (this.queueForTabGroupProtecting.has(p.id)) {
            this.queueForTabGroupProtecting.delete(p.id);
            return;
          }
          this.sessionRepository.deleteTabFromGroup(a, p.id);
        } else
          b
            ? this.sessionRepository.updateGroupForTab(a, p.id, b)
            : this.queueForTabGroup.set(t.groupId, {
                sessionId: a,
                tabId: p.id,
              });
      }
      this.sessionRepository.updateTab(a, p.id, {
        url: y,
        title: r.title || y || p.title || "",
        pinned: r.pinned,
        favIconUrl: r.favIconUrl || p.favIconUrl,
        muted: r.mutedInfo?.muted,
        audible: r.audible,
      });
    }
    onTabRemoved(e, t) {
      let r = this.sessionRepository.getTabByWindowId(t.windowId, e);
      if (!r) return;
      let i = this.sessionRepository.getSessionByWindowId(t.windowId);
      if (i) {
        if (t.isWindowClosing || r.pinned) {
          this.sessionRepository.updateTab(i.id, r.id, { browserId: void 0 });
          return;
        }
        this.sessionRepository.deleteTab(i.id, r.id);
      }
    }
    async onTabReplaced(e, t) {
      let r = this.sessionRepository.getTabAndSessionByBrowserId(t);
      if (!r) return;
      let i = this.sessionRepository.updateTab(r.session.id, r.tab.id, {
        browserId: e,
      });
      i && (await this.extraDataService.ensureTabExtraData([i]));
    }
    onTabActivated(e) {
      let t = this.sessionRepository.getSessionByWindowId(e.windowId);
      if (!t) return;
      let r = this.sessionRepository.getTabByWindowId(e.windowId, e.tabId);
      r && this.updateLastActiveSessionTabId(t.id, r.id);
    }
    async onTabDetached(e) {
      let t = await this.browserService.getTabById(e);
      if (!t) return;
      if (
        (await this.browserService.getWindowById(t.windowId))?.type !== "normal"
      ) {
        let s = this.extraDataService.getTabExtraData(t)?.sessionTabId;
        if (!s) return;
        let a = this.sessionRepository.getSessionByWindowId(t.windowId);
        if (!a) return;
        this.sessionRepository.deleteTab(a.id, s);
      }
    }
    onTabMoved(e, t) {
      let r = this.sessionRepository.getTabByWindowId(t.windowId, e);
      if (!r || this.sessionTabsService.removeMovedProgrammatically(r.id))
        return;
      let i = this.sessionRepository.getSessionByWindowId(t.windowId)?.id;
      if (!i) return;
      let s = this.sessionRepository.getIndexOfTab(i, r.id),
        a = this.getIndexForTabStripPosition(e, t.windowId, i, r.pinned),
        n = a < 0 ? s : a;
      this.sessionRepository.moveTabToSession(i, i, r, n);
    }
    onTabAttached(e, { newWindowId: t }) {
      let r = this.sessionRepository.getTabAndSessionByBrowserId(e);
      if (!r || this.sessionTabsService.removeMovedProgrammatically(r.tab.id))
        return;
      let i = this.sessionRepository.getSessionByWindowId(t);
      if (!i) return;
      let s = this.getIndexForTabStripPosition(e, t, i.id, r.tab.pinned);
      this.sessionRepository.moveTabToSession(r.session.id, i.id, r.tab, s);
    }
    async removeRecentlyClosed(e) {
      let t = (await this.browserService.getRecentlyClosed())
        .filter((r) =>
          r.tab
            ? this.extraDataService.getTabExtraData(r.tab)?.sessionTabId === e
            : !1
        )
        .map((r) => r.tab?.sessionId);
      await Promise.all(
        t.map((r) => this.browserService.removeRecentlyClosedItem(r))
      );
    }
    updateLastActiveSessionTabId(e, t) {
      this.sessionRepository.updateSession(e, { lastActiveSessionTabId: t });
    }
    getIndexForTabStripPosition(e, t, r, i) {
      let s = this.tabStripObserver.getInternalIndexForIndex(t, e),
        a = i
          ? this.sessionRepository.getHiddenPinnedTabsBeforeIndex(r, s)
          : this.sessionRepository.getAllHiddenPinnedSessionTabs(r);
      return s + a.length;
    }
    ensureIdForNewSessionTab(e) {
      let t = e.id;
      g(t, "Tab has not ID");
      let r = this.sessionRepository.getSessionByWindowId(e.windowId);
      g(r, "Session for tab is undefined");
      let s = this.extraDataService.getTabExtraData(e)?.sessionTabId;
      return {
        tab: e,
        tabId: t,
        sessionTabId: s ?? void 0,
        sessionIdOfWindow: r.id,
      };
    }
  };
c();
var Zc = class {
  constructor(e, t, r, i) {
    this.sessionRepository = e;
    this.browserService = t;
    this.tabStripObserver = r;
    this.billingApi = i;
  }
  movedProgrammatically = new Set();
  removeMovedProgrammatically(e) {
    return this.movedProgrammatically.has(e)
      ? (this.movedProgrammatically.delete(e), !0)
      : !1;
  }
  async changeSessionTabPinning(e, t, r) {
    let i = this.sessionRepository.updateTab(e, t, { pinned: r });
    i.browserId &&
      (await this.browserService.updateTabById({
        tabId: i.browserId,
        changes: { pinned: r },
      }));
  }
  async changeSessionTabMuting(e, t, r) {
    let i = this.sessionRepository.updateTab(e, t, { muted: r });
    i.browserId &&
      (await this.browserService.updateTabById({
        tabId: i.browserId,
        changes: { muted: r },
      }));
  }
  async openSessionTab(e, t) {
    let r = this.sessionRepository.getSessionByWindowId(e);
    if (!r) return;
    let i = Boolean(r.tabsById[t]),
      s = this.sessionRepository.getTab(r.id, t);
    if (s) {
      if (i) {
        await this.openTabInActiveSession(e, r.id, s);
        return;
      }
      await this.moveTabToSessionAndOpen(e, s, r.id);
    }
  }
  async openTabInActiveSession(e, t, r) {
    r.browserId
      ? await this.browserService.activateTab(r.browserId)
      : r.pinned && (await this.openPinnedSessionTab(e, t, r, !0));
  }
  async moveTabToSessionAndOpen(e, t, r) {
    let i = { ...t, id: le(), browserId: void 0, pinned: !1 };
    this.sessionRepository.addTab(r, i),
      await this.browserService.createTabFromSessionTab({
        sessionTab: i,
        windowId: e,
        isActive: !0,
      });
  }
  async reloadSessionTab(e, t) {
    let r = this.sessionRepository.getTab(e, t);
    r?.browserId && (await this.browserService.reloadTab(r.browserId));
  }
  async deleteSessionTab(e, t) {
    let r = this.sessionRepository.getTab(e, t);
    if (r?.browserId)
      try {
        await this.browserService.closeTab(r.browserId);
      } catch (i) {
        fe(i);
      }
    return this.sessionRepository.deleteTab(e, t);
  }
  deleteOtherSessionTabs(e, t) {
    let r = this.sessionRepository.getSessionById(e);
    r &&
      r.tabsOrder.map((i) => {
        if (i !== t) return this.deleteSessionTab(e, i).catch(fe);
      });
  }
  async duplicateSessionTab(e, t) {
    let r = this.sessionRepository.getTab(e, t);
    if (!r) return;
    if (r.browserId) {
      await this.browserService.duplicateTab(r.browserId);
      return;
    }
    let i = at.copyTab({ ...r, pinned: !1 });
    this.sessionRepository.addTab(e, i);
  }
  async reorderSessionTab(e, t, r, i) {
    let s = this.sessionRepository.reorderTabInSession(t, r, i);
    if (!s) return;
    let a = this.sessionRepository.getTab(t, s);
    if (!a?.browserId) return;
    let n = this.getTabStripPositionForIndex(t, e, i);
    this.setTabAsMovedProgrammatically(s),
      await this.browserService.moveTab(a.browserId, n);
  }
  async moveSessionTabToAnotherSession(e, t, r, i) {
    let s = this.sessionRepository.getTab(r, e);
    if (!s) return;
    let a = this.sessionRepository.getSessionById(t);
    if (!a || !this.billingApi.canEditSession(a)) return;
    this.sessionRepository.moveTabToSession(r, t, s, i),
      await this.tryShowNtp(r);
    let n = this.sessionRepository.getWindowIdBySessionId(a.id),
      { browserId: p } = s;
    if (!n) {
      if (!p) return;
      this.sessionRepository.updateTab(t, e, { browserId: void 0 }),
        await this.browserService.closeTab(p);
      return;
    }
    let d = this.sessionRepository.getIndexOfTab(t, s.id),
      u = this.getTabStripPositionForIndex(t, n, d),
      y =
        this.sessionRepository.getSessionById(r)?.workspaceId === a.workspaceId;
    if (!p || !y) {
      p && (await this.browserService.closeTab(p)),
        await this.browserService.createTabFromSessionTab({
          sessionTab: s,
          windowId: n,
          position: u,
        });
      return;
    }
    this.setTabAsMovedProgrammatically(s.id),
      await this.browserService.updateTabById({
        tabId: p,
        changes: { pinned: s.pinned },
      }),
      await this.browserService.moveTab(p, u, n);
  }
  setTabAsMovedProgrammatically(e) {
    this.movedProgrammatically.add(e);
  }
  async openPinnedSessionTab(e, t, r, i) {
    let s = this.sessionRepository.getIndexOfTab(t, r.id),
      a = i
        ? s - this.sessionRepository.getHiddenPinnedTabsBeforeIndex(t, s).length
        : s;
    await this.browserService.createTabFromSessionTab({
      sessionTab: r,
      windowId: e,
      position: a,
      isActive: !0,
    });
  }
  getTabStripPositionForIndex(e, t, r) {
    let i = this.sessionRepository.getHiddenPinnedTabsBeforeIndex(e, r),
      s = r - i.length;
    return this.tabStripObserver.getIndexForInternalIndex(t, s);
  }
  tryShowNtp(e) {
    return this.sessionRepository.getSessionTabsLength(e) !== 0
      ? Promise.resolve()
      : this.sessionRepository.getActiveSessionsLength() === 1
      ? this.browserService.createNTP()
      : Promise.resolve();
  }
};
var CS = async ({
  analyticsTracker: o,
  backendService: e,
  browserEventsService: t,
  browserService: r,
  browserStorage: i,
  encryptionService: s,
  extraDataService: a,
  featureFlagsRepository: n,
  openWindows: p,
  sessionRepository: d,
  tabStripObserver: u,
  userRepository: m,
  windowHeadlessService: y,
  workspaceRepository: b,
  userApi: v,
  onboardingDataService: S,
  billingRepository: w,
  billingApi: T,
  sidecarAppearanceService: I,
}) => {
  let { missedWindowsFromOnCreated: k } = t,
    _ = new Zc(d, r, u, T),
    O = new Jc(d, r, a, u, t, n, I, _),
    E = new Xc(d, t, a, r, O),
    f = new Qc(d, b, a, t, r, E, y, S, v, n, w),
    j = await f.getShouldRestoreOnStartup();
  return (
    f.initSessions(p, j),
    f.processMissedWindows(k, j).catch(l),
    f.initListeners(),
    E.initListeners(),
    E.initTabGroups().catch(l),
    O.initListeners(),
    new Yc(i, e, d, n, s, t, r, b, f, O, o, m, E).init().catch(l),
    new zc(d, f, _, E)
  );
};
c();
c();
var ep = class {
  constructor(e, t, r, i, s, a, n) {
    this.modalService = e;
    this.teamService = t;
    this.teamRepository = r;
    this.workspaceRepository = i;
    this.analytics = s;
    this.browserStorage = a;
    this.sidekickAppPath = n;
  }
  async inviteToTeam(
    { teamId: e, emails: t, allowApprovedDomains: r = !1 },
    i
  ) {
    let s = this.getTeamForWorkspaceByWindowId(i);
    if (!s || !e) return;
    let a = [this.teamService.inviteToTeam(e, t)];
    s.allowApprovedDomains !== r &&
      a.push(this.teamService.updateTeam(e, { allow_approved_domains: r })),
      await Promise.all(a);
  }
  async createTeamWorkspace(e, t) {
    let r = this.workspaceRepository.getWorkspaceForWindow(t);
    if (r) {
      if (r.isTeamWorkspace) {
        l(new L("Workspace is already team"));
        return;
      }
      await this.teamService.createTeam({ ...e, workspaceId: r.id }),
        this.analytics.sendAnalyticsEvent(
          "b2b.intro-popup.team-created",
          void 0
        );
    }
  }
  setLastViewedIntroStep(e) {
    return this.browserStorage.setItem("intro-modal-step", e);
  }
  async getLastViewedIntroStep() {
    return (await this.browserStorage.getItem("intro-modal-step")) || 0;
  }
  setIsIntroFinished(e) {
    return this.browserStorage.setItem("intro-modal-finished", e);
  }
  async getIsIntroFinished() {
    return (await this.browserStorage.getItem("intro-modal-finished")) || !1;
  }
  getUserInvitePermissionForTeamInWindow(e) {
    if (!e) return !1;
    let t = this.getTeamForWorkspaceByWindowId(e);
    return t ? t.canInvite ?? !1 : !1;
  }
  getMembersCountForTeamInWindow(e) {
    if (!e) return 0;
    let t = this.getTeamForWorkspaceByWindowId(e);
    return t ? t.membersCount : 0;
  }
  getTeamForWorkspaceByWindowId(e) {
    let t = this.workspaceRepository.getWorkspaceForWindow(e);
    return !t?.isTeamWorkspace || !t.teamUuid
      ? null
      : this.teamRepository.getTeam(t.teamUuid);
  }
  getTeamAdminLinks() {
    return {
      applications: `${this.sidekickAppPath}/applications`,
      invites: `${this.sidekickAppPath}/team/invite-people`,
    };
  }
  getManageLinkForWindow(e) {
    let t = this.getTeamForWorkspaceByWindowId(e)?.uuid;
    return this.getManageLinkForTeam(t);
  }
  getManageLinkForTeam(e) {
    return e
      ? `${this.sidekickAppPath}/?team_id=${e}`
      : `${this.sidekickAppPath}/team/members`;
  }
};
c();
var tp = class {
  constructor(e, t, r, i, s) {
    this.browserService = e;
    this.backendService = t;
    this.teamRepository = r;
    this.teamBrowserPolicyRepository = i;
    this.notificationsService = s;
  }
  unsubscribeNotifications;
  init() {
    return (
      _e.on(
        "team-browser-policies-loaded",
        this.handlePoliciesUpdate.bind(this)
      ),
      _e.on("teams-loaded", () => ee(this.reloadTeamBrowserPolicies())),
      this.reloadTeamBrowserPolicies()
    );
  }
  async reloadTeamBrowserPolicies() {
    this.unsubscribeNotifications?.();
    let e = Object.keys(this.teamRepository.getTeams()).filter(
        (i) => i !== Ui.uuid
      ),
      t = e.map((i) =>
        this.notificationsService.subscribe(
          ["updated"],
          ["team_browser_policy.updated"],
          ({ version: s, payload: a }) => {
            (s === "firebase" && a.team_id !== i) ||
              this.reloadTeamBrowserPolicies().catch(l);
          },
          { uri: Yo.getPath({ id: i }) }
        )
      );
    this.unsubscribeNotifications = F(t);
    let r = Object.fromEntries(
      await Promise.all(
        e.map(async (i) => [
          i,
          await this.backendService.extension.getTeamPolicy(i),
        ])
      )
    );
    this.teamBrowserPolicyRepository.setStateFromNetwork(r);
  }
  apply(e) {
    return this.browserService.applyPolicy(JSON.stringify(e));
  }
  handlePoliciesUpdate(e) {
    let t = this.mergePolicies(e) ?? {};
    this.apply(t).catch(l);
  }
  mergePolicies(e) {
    let t = Object.values(e).filter((i) => Object.keys(i).length > 0),
      r = t[0];
    if (t.length > 1) {
      let i = new L(
        "DANGER: We've detected multiple active team policies at same time!",
        { level: "warning", extra: { policies: t } }
      );
      l(i);
    }
    return r;
  }
};
c();
c();
var Dr = class {
  static parseTeam(e) {
    return {
      uuid: e.uuid,
      isJustMe: e.is_just_me ?? !0,
      name: e.name,
      logoUrl: e.logo_url ?? null,
      role: e.role ?? null,
      allowApprovedDomains: e.allow_approved_domains ?? !1,
      domains: e.domains ?? [],
      canInvite: e.can_invite ?? !1,
      membersCount: e.members_count || 1,
    };
  }
  static toCreateTeamDto(e) {
    return {
      name: e.name,
      allow_approved_domains: e.allowApprovedDomains,
      workspace_id: e.workspaceId,
      invites: e.invites,
    };
  }
};
var rp = class {
  constructor(e, t) {
    this.backendService = e;
    this.teamRepository = t;
  }
  async createTeam(e) {
    let t = await this.backendService.extension.createTeam(
        Dr.toCreateTeamDto(e)
      ),
      r = Dr.parseTeam(t.team);
    this.teamRepository.createTeam(r, e.workspaceId);
  }
  async updateTeam(e, t) {
    await this.backendService.extension.updateTeam(e, t),
      this.teamRepository.updateTeamById(e, t);
  }
  async inviteToTeam(e, t) {
    await this.backendService.extension.inviteToTeam(e, t),
      await this.syncTeamWithBackend(e);
  }
  async loadTeams() {
    let t = (await this.backendService.extension.getTeams()).reduce(
      (i, s) => ((i[s.uuid] = Dr.parseTeam(s)), i),
      {}
    );
    if (Boolean(Object.keys(t).length)) {
      this.teamRepository.setStateFromNetwork(t);
      return;
    }
    l(new L("User has no teams")),
      this.teamRepository.addTeam(Dr.parseTeam(Ui));
  }
  async syncTeamWithBackend(e) {
    let t = await this.getTeamFromBackend(e);
    this.teamRepository.updateTeamById(e, t);
  }
  async getTeamFromBackend(e) {
    let t = await this.backendService.extension.getTeam(e);
    return Dr.parseTeam(t.team);
  }
};
var _S = (o, e, t, r, i, s, a, n, p) => {
  let d = new rp(e, n);
  return (
    d.loadTeams().catch(l),
    new tp(o, e, n, p, a).init().catch(l),
    new ep(r, d, n, t, s, i, me.SIDEKICK_APP || "")
  );
};
c();
var ip = class {
  constructor(e, t, r, i, s) {
    this.userSettingsService = e;
    this.userService = t;
    this.userSettingsRepository = r;
    this.focusModeService = i;
    this.browserService = s;
  }
  generateFeedbackUrl() {
    return this.userService.generateFeedbackUrl();
  }
  getUserInfo() {
    return this.userService.getUserInfo();
  }
  getUserId() {
    return this.userService.getUserId();
  }
  getSettings() {
    return this.userSettingsRepository.getSettings();
  }
  changeGlobalMute(e) {
    this.userSettingsService.changeGlobalMute(e),
      this.browserService.stopAllNotifications(e).catch(l),
      this.focusModeService.handleFocusMode().catch(l);
  }
  changeIsHiddenSidebarIcons(e) {
    this.userSettingsService.changeIsHiddenSidebarIcons(e);
  }
  changeIsHiddenWelcomeToDistractionBlocker(e) {
    this.userSettingsService.changeIsHiddenWelcomeToDistractionBlocker(e);
  }
  changeEnableDistractionBlocker(e) {
    this.userSettingsService.changeEnableDistractionBlocker(e);
  }
  markDistractionBlockerIntroShowed() {
    this.userSettingsService.markDistractionBlockerIntroShowed();
  }
  addAdBlockerDomain(e) {
    this.userSettingsService.addAdBlockerDomain(e);
  }
  changeDistractionBlockerRules(e) {
    this.userSettingsService.changeDistractionBlockerRules(e);
  }
  changeDistractionBlockerSchedule(e) {
    this.userSettingsService.changeDistractionBlockerSchedule(e);
  }
  removeAdBlockerDomain(e) {
    this.userSettingsService.removeAdBlockerDomain(e);
  }
  addCpuMonitorDomain(e) {
    this.userSettingsService.addCpuMonitorDomain(e);
  }
  removeCpuMonitorDomain(e) {
    this.userSettingsService.removeCpuMonitorDomain(e);
  }
  changeEnableCpuMonitorNotification(e) {
    this.userSettingsService.changeEnableCpuMonitorNotification(e);
  }
  changeEnableCpuMonitorAutoDiscard(e) {
    this.userSettingsService.changeEnableCpuMonitorAutoDiscard(e);
  }
  addNonDiscardableDomain(e) {
    this.userSettingsService.addNonDiscardableDomain(e);
  }
  removeNonDiscardableDomain(e) {
    this.userSettingsService.removeNonDiscardableDomain(e);
  }
  changeMinutesBeforeDiscard(e) {
    this.userSettingsService.changeMinutesBeforeDiscard(e);
  }
  changePreferredWallpaperSettings(e, t) {
    this.userSettingsService.changePreferredWallpaperSettings(e, t);
  }
  changeSidebarSize(e) {
    this.userSettingsService.changeSidebarSize(e);
  }
  changeUseAdBlocker(e) {
    this.userSettingsService.changeUseAdBlocker(e);
  }
  changeInteractiveServiceGrayscale(e) {
    this.userSettingsService.changeInteractiveServiceGrayscale(e);
  }
  showPhotoBackground(e) {
    this.userSettingsService.showPhotoBackground(e);
  }
  changeDisableDiscarding(e) {
    this.userSettingsService.changeDisableDiscarding(e);
  }
  changeUse12Format(e) {
    this.userSettingsService.changeUse12Format(e);
  }
  changeRandomUserAgent(e) {
    this.userSettingsService.changeUseRandomUserAgent(e);
  }
  changeIsHiddenWelcomeToSessions(e) {
    this.userSettingsService.changeIsHiddenWelcomeToSessions(e);
  }
  changeIsHiddenWelcomeGlobalSearch(e) {
    this.userSettingsService.changeIsHiddenWelcomeGlobalSearch(e);
  }
  changeIsHiddenWelcomeToCollections(e) {
    this.userSettingsService.changeIsHiddenWelcomeToCollections(e);
  }
  changeIsHeadlessModeEnabled(e) {
    this.userSettingsService.changeIsHeadlessModeEnabled(e);
  }
  changeCtrlTabOrder(e) {
    this.userSettingsService.changeCtrlTabOrder(e);
  }
  setInvitationBannerClosed() {
    this.userSettingsService.setInvitationBannerClosed();
  }
  acceptInviteBonus() {}
  confirmLocalLawsForVPN() {
    this.userSettingsService.confirmLocalLawsForVPN();
  }
  toggleSelectedSites(e) {
    this.userSettingsService.toggleSelectedSites(e);
  }
  toggleUseProxy(e) {
    this.userSettingsService.toggleUseProxy(e);
  }
  toggleCalendarsIntegration(e) {
    this.userSettingsService.toggleCalendarsIntegration(e);
  }
  updateInviterCode(e) {
    return this.userService.updateInviterCode(e);
  }
  setShortcutsPopupClosed() {
    this.userSettingsService.setShortcutsPopupClosed();
  }
  setGmailSignature() {
    this.userSettingsService.setGmailSignature();
  }
  setGmailSignatureDisabled() {
    this.userSettingsService.setGmailSignatureDisabled();
  }
  addHintToShowed(e) {
    this.userSettingsService.addHintToShowed(e);
  }
  tryHideLaunchpadTeamsBillingAnimation() {
    this.userSettingsService.tryHideLaunchpadTeamsBillingAnimation();
  }
  setDiscountStartTimestamp(e) {
    this.userSettingsService.setDiscountStartTimestamp(e);
  }
  setWasSessionsEnabled() {
    this.userSettingsService.setWasSessionsEnabled();
  }
};
c();
c();
var wh = "actual-minutes-used-report",
  op = class {
    constructor(e, t, r, i, s, a, n, p) {
      this.browserService = e;
      this.browserEventsService = t;
      this.scheduler = r;
      this.analytics = i;
      this.browserStorage = s;
      this.actualUsageDaysRepository = a;
      this.featureFlagsRepository = n;
      this.userSettingsService = p;
      this.init().catch(l);
    }
    counter = null;
    actualUsageDays = 0;
    eventsPerDay = 0;
    isDuringProcessTask = !1;
    async init() {
      (this.actualUsageDays =
        await this.actualUsageDaysRepository.getCountEnsured()),
        await this.loadCounter();
      let e = () => ee(this.checkTimer());
      return (
        this.browserEventsService.subscribeToIdleStateChanged(e),
        this.browserEventsService.subscribeToWindowFocusChanged(e),
        this.featureFlagsRepository.onFeatureFlagsLoaded(e),
        W.on("actual-usage-days-updated", e),
        this.checkTimer()
      );
    }
    async checkTimer() {
      let [e, t] = await Promise.all([
        this.browserService.getNormalLastFocusedWindowId(),
        this.browserService.getIdleState(),
      ]);
      Boolean(this.isDisabled() || t !== "active" || e === void 0)
        ? this.cancelTask()
        : this.hasTask() || this.scheduleTask();
    }
    async processTask() {
      this.isDuringProcessTask = !0;
      try {
        let e = this.actualUsageDaysRepository.getCount();
        e !== void 0 && e !== this.actualUsageDays
          ? ((this.actualUsageDays = e), await this.resetAll())
          : (await this.incrementCounter(1),
            this.isReadyToSend() &&
              (await this.sendEvent(), await this.resetCounter()));
      } finally {
        (this.isDuringProcessTask = !1), this.scheduleTask();
      }
    }
    hasTask() {
      return this.scheduler.hasTask(wh);
    }
    scheduleTask() {
      g(!this.hasTask(), "Failed to schedule task: task not found"),
        !this.isDuringProcessTask &&
          this.scheduler
            .taskSuicidal(wh, () => this.processTask())
            .everyMinute();
    }
    cancelTask() {
      this.scheduler.removeTask(wh);
    }
    async sendEvent() {
      this.assertValueIsLoaded(this.counter),
        (this.eventsPerDay += 1),
        this.userSettingsService.trySetUserActivated(),
        await this.analytics.sendAnalyticsEventWithOptions(
          "system.actual-minutes-used",
          { count: this.counter },
          { disableBatching: !0 }
        );
    }
    async loadCounter() {
      let e = await this.browserStorage.getItem("actual-usage-minutes");
      (this.counter = 0),
        !(!e || e.actualUsageDays !== this.actualUsageDays) &&
          (this.counter = e.count);
    }
    saveCounter() {
      return (
        this.assertValueIsLoaded(this.counter),
        this.browserStorage.setItem("actual-usage-minutes", {
          count: this.counter,
          actualUsageDays: this.actualUsageDays,
          updatedAt: Date.now(),
        })
      );
    }
    resetAll() {
      return (this.eventsPerDay = 0), this.resetCounter();
    }
    resetCounter() {
      return (this.counter = 0), this.saveCounter();
    }
    incrementCounter(e) {
      return (
        this.assertValueIsLoaded(this.counter),
        (this.counter += e),
        this.saveCounter()
      );
    }
    isReadyToSend() {
      let e = this.getHowOftenSendEventInMinutes();
      if (e <= 0) return !1;
      let t = this.getMaxEventsPerDay();
      return t > 0 && this.eventsPerDay >= t
        ? !1
        : (this.assertValueIsLoaded(this.counter), this.counter >= e);
    }
    assertValueIsLoaded(e) {
      g(e !== null, "Counter should be loaded");
    }
    getHowOftenSendEventInMinutes() {
      return this.featureFlagsRepository.getFeatureFlag(
        "actualMinutesUsedReport"
      ).sendEveryMinutes;
    }
    getMaxEventsPerDay() {
      return this.featureFlagsRepository.getFeatureFlag(
        "actualMinutesUsedReport"
      ).maxEventsPerDay;
    }
    isDisabled() {
      return (
        !this.featureFlagsRepository.getFeatureFlag(
          "actualMinutesUsedReportEnabled"
        ) || this.getHowOftenSendEventInMinutes() <= 0
      );
    }
  };
c();
var sp = class {
  constructor(e, t) {
    this.userRepository = e;
    this.browserStorage = t;
    this.update().catch(l),
      setInterval(() => {
        this.update().catch(l);
      }, xe(1));
  }
  count;
  logger = x.createInstance("actual_usage");
  getCount() {
    return this.count;
  }
  async getCountEnsured() {
    let e = this.getCount();
    return e !== void 0
      ? e
      : new Promise((t) => {
          W.once("actual-usage-days-updated", t);
        });
  }
  async update() {
    let e = await this.browserStorage.getItem("actual-usage");
    if (!e) {
      let r = await this.getDefaultCount();
      return (
        this.logger.info("Actual usage set as default", this.count),
        this.saveCount(r)
      );
    }
    return (Xy(e.updatedAt, Date.now()) ?? 0) > 1
      ? this.saveCount(e.count + 1)
      : this.setCount(e.count);
  }
  setCount(e) {
    e !== this.count &&
      ((this.count = e),
      W.emit("actual-usage-days-updated", e),
      this.logger.info("Actual usage updated", this.count));
  }
  saveCount(e) {
    return (
      this.setCount(e),
      this.browserStorage.setItem("actual-usage", {
        count: e,
        updatedAt: Date.now(),
      })
    );
  }
  async getUserRegisteredAt() {
    return (await this.userRepository.getEnsuredUserInfo()).registeredAt;
  }
  async getDefaultCount() {
    let e = Date.now(),
      t = await this.getUserRegisteredAt();
    g(t, "Type of registeredAt must be number");
    let r = t * 1e3,
      i = Rr(e - r);
    return Math.max(Math.floor(i / 2), 0);
  }
};
c();
var ap = class {
  constructor(e, t, r, i) {
    this.userRepository = e;
    this.systemInfoService = t;
    this.backendService = r;
    this.authService = i;
    se.on("billing-plan-loaded", (s, a) => {
      a && this.loadUserInfo().catch(l);
    });
  }
  generateFeedbackUrl() {
    let e = this.userRepository.getUserInfo()?.email;
    if (!e) return "https://meetsidekick.typeform.com/to/fWYUp9";
    let t = Date.now(),
      { browserVersion: r, extensionVersion: i } = this.systemInfoService;
    return `https://meetsidekick.typeform.com/to/fWYUp9#email=${e}&browser_version=${r}&extension_version=${i}&timestamp=${t}`;
  }
  getUserInfo() {
    return this.userRepository.getUserInfo() ?? null;
  }
  getUserId() {
    return this.authService.getUserId();
  }
  updateInviterCode(e) {
    return this.backendService.extension.updateInviterCode(e);
  }
  refreshUserInfo(e) {
    this.userRepository.setStateFromNetwork(e);
  }
  async loadUserInfo() {
    let e = await this.backendService.extension.getMe();
    this.userRepository.setStateFromNetwork(e.user);
  }
};
c();
var np = class {
  constructor(e, t) {
    this.userSettingsRepository = e;
    this.backendService = t;
  }
  trySetUserActivated() {
    let { wasActivated: e } = this.userSettingsRepository.getSettings();
    e ||
      (this.updateGlobalUserSettings({ wasActivated: !0 }),
      W.emit("user-activated"));
  }
  changeGlobalMute(e) {
    this.userSettingsRepository.updateLocalUserSetting({ globalMute: e });
  }
  changeIsHiddenSidebarIcons(e) {
    this.userSettingsRepository.updateLocalUserSetting({
      isHiddenSidebarIcons: e,
    });
  }
  changeSidebarSize(e) {
    this.updateGlobalUserSettings({ sidebarSize: e });
  }
  changeInteractiveServiceGrayscale(e) {
    this.updateGlobalUserSettings({ inactiveServiceGrayscale: e });
  }
  changeIsHiddenWelcomeToDistractionBlocker(e) {
    this.updateGlobalUserSettings({ isHiddenWelcomeToDistractionBlocker: e });
  }
  changeEnableDistractionBlocker(e) {
    this.updateGlobalUserSettings({
      isDistractionBlockerIntroShowed: !0,
      isDistractionBlockerEnabled: e,
    });
  }
  markDistractionBlockerIntroShowed() {
    this.updateGlobalUserSettings({ isDistractionBlockerIntroShowed: !0 });
  }
  changeUseAdBlocker(e) {
    this.updateGlobalUserSettings({ useAdBlocker: e });
  }
  addAdBlockerDomain(e) {
    let t = this.userSettingsRepository.getSettings();
    this.updateGlobalUserSettings({
      adBlockerWhiteList: _o([...t.adBlockerWhiteList, e]),
    });
  }
  changeDistractionBlockerRules(e) {
    this.updateGlobalUserSettings({
      isDistractionBlockerIntroShowed: !0,
      distractionBlockerRules: e,
    });
  }
  changeDistractionBlockerSchedule(e) {
    this.updateGlobalUserSettings({
      isDistractionBlockerIntroShowed: !0,
      distractionBlockerSchedule: e,
    });
  }
  removeAdBlockerDomain(e) {
    let t = this.userSettingsRepository.getSettings();
    this.updateGlobalUserSettings({
      adBlockerWhiteList: t.adBlockerWhiteList.filter((r) => r !== e),
    });
  }
  addCpuMonitorDomain(e) {
    let t = this.userSettingsRepository.getSettings();
    this.updateGlobalUserSettings({
      cpuAutoDiscardUserWhitelist: _o([...t.cpuAutoDiscardUserWhitelist, e]),
    });
  }
  removeCpuMonitorDomain(e) {
    let t = this.userSettingsRepository.getSettings();
    this.updateGlobalUserSettings({
      cpuAutoDiscardUserWhitelist: t.cpuAutoDiscardUserWhitelist.filter(
        (r) => r !== e
      ),
    });
  }
  addShowedOnboardingHint(e) {
    let t = this.userSettingsRepository.getSettings();
    this.updateGlobalUserSettings({
      showedOnboardingHints: _o([...t.showedOnboardingHints, e]),
    });
  }
  changeEnableCpuMonitorNotification(e) {
    this.updateGlobalUserSettings({ cpuMonitorNotificationsEnabledByUser: e });
  }
  changeEnableCpuMonitorAutoDiscard(e) {
    this.updateGlobalUserSettings({ cpuAutoDiscardEnabledByUser: e });
  }
  changeDisableDiscarding(e) {
    this.updateGlobalUserSettings({ disableDiscarding: e });
  }
  addNonDiscardableDomain(e) {
    let t = this.userSettingsRepository.getSettings();
    this.updateGlobalUserSettings({
      noneDiscardableDomains: _o([...t.noneDiscardableDomains, e]),
    });
  }
  removeNonDiscardableDomain(e) {
    let t = this.userSettingsRepository.getSettings();
    this.updateGlobalUserSettings({
      noneDiscardableDomains: t.noneDiscardableDomains.filter((r) => r !== e),
    });
  }
  changeMinutesBeforeDiscard(e) {
    this.updateGlobalUserSettings({ minutesBeforeDiscard: e });
  }
  showPhotoBackground(e) {
    this.updateGlobalUserSettings({ showPhotoBackground: e });
  }
  changeUse12Format(e) {
    this.updateGlobalUserSettings({ use12Format: e });
  }
  changePreferredWallpaperSettings(e, t) {
    this.updateGlobalUserSettings({
      preferredWallpaperId: e,
      rotateWallpapersEnabled: t,
    });
  }
  changeUseRandomUserAgent(e) {
    this.updateGlobalUserSettings({ randomUserAgent: e });
  }
  changeIsHiddenWelcomeToSessions(e) {
    this.updateGlobalUserSettings({ isHiddenWelcomeToSessions: e });
  }
  changeIsHiddenWelcomeGlobalSearch(e) {
    this.updateGlobalUserSettings({ isHiddenWelcomeGlobalSearch: e });
  }
  changeIsHiddenWelcomeToCollections(e) {
    this.updateGlobalUserSettings({ isHiddenWelcomeToCollections: e });
  }
  changeIsHeadlessModeEnabled(e) {
    this.updateGlobalUserSettings({ isHeadlessModeEnabled: e });
  }
  changeCtrlTabOrder(e) {
    this.updateGlobalUserSettings({ ctrlTabOrder: e });
  }
  confirmLocalLawsForVPN() {
    this.userSettingsRepository.updateLocalUserSetting({
      isConfirmedLocalLawsForVPN: !0,
    });
  }
  toggleSelectedSites(e) {
    let { selectedProxySites: t } = this.userSettingsRepository.getSettings();
    t.includes(e.toString())
      ? this.userSettingsRepository.updateLocalUserSetting({
          selectedProxySites: t.filter((r) => r !== e.toString()),
        })
      : this.userSettingsRepository.updateLocalUserSetting({
          selectedProxySites: [...t, e.toString()],
        });
  }
  toggleUseProxy(e) {
    this.userSettingsRepository.updateLocalUserSetting({ useProxy: e });
  }
  toggleCalendarsIntegration(e) {
    this.updateGlobalUserSettings({ enableCalendarsIntegration: e });
  }
  setShortcutsPopupClosed() {
    this.updateGlobalUserSettings({ wasShortcutPopupClosed: !0 });
  }
  setInvitationBannerClosed() {
    this.updateGlobalUserSettings({ wasInvitationBannerClosed: !0 });
  }
  setGmailSignature() {
    this.updateGlobalUserSettings({ wasGmailSignatureSet: !0 });
  }
  setGmailSignatureDisabled() {
    this.updateGlobalUserSettings({ wasGmailSignatureSet: !1 });
  }
  addHintToShowed(e) {
    let t = this.userSettingsRepository.getSettings().showedHintsV2;
    t.includes(e) ||
      this.updateGlobalUserSettings({ showedHintsV2: [...t, e] });
  }
  tryHideLaunchpadTeamsBillingAnimation() {
    let { isHiddenLaunchpadTeamsBillingAnimation: e } =
      this.userSettingsRepository.getSettings();
    e ||
      this.updateGlobalUserSettings({
        isHiddenLaunchpadTeamsBillingAnimation: !0,
      });
  }
  setDiscountStartTimestamp(e) {
    this.updateGlobalUserSettings({ discountStartTimestamp: e });
  }
  setWasSessionsEnabled() {
    this.userSettingsRepository.updateLocalUserSetting({
      wasSessionsEnabled: !0,
    });
  }
  updateGlobalUserSettings(e) {
    let t = this.userSettingsRepository.updateGlobalUserSettings(e);
    this.backendService.extension.updateGlobalSettings(t).catch(l);
  }
};
var FS = (o, e, t, r, i, s, a, n, p, d, u) => {
  let m = new sp(d, o),
    y = new np(p, t),
    b = new ap(d, e, t, u);
  return b.loadUserInfo().catch(l), new op(r, a, i, s, o, m, n, y), [b, y, m];
};
c();
c();
var cp = class {
  constructor(e, t, r, i, s, a, n, p) {
    this.applicationApi = e;
    this.workspaceRepository = t;
    this.workspaceService = r;
    this.billingApi = i;
    this.sessionApi = s;
    this.modalService = a;
    this.analyticsTracker = n;
    p.subscribeToAddWorkspace((d) => {
      this.onAddWorkspaceClick(d);
    }),
      p.subscribeToOpenWorkspaceSettings(
        this.onOpenWorkspaceSettings.bind(this)
      ),
      p.subscribeToOpenWorkspace((d) => {
        this.onWorkspaceClick(d);
      }),
      D.on("apps-activate-in-workspace", (d) => {
        this.openAppAndWorkspace(d).catch(l);
      });
  }
  async openWorkspace(e) {
    let t = this.workspaceRepository.getWorkspaceById(e);
    if (!t) return Promise.resolve();
    let r = this.workspaceRepository
      .getWorkspacesArray()
      .findIndex((n) => n.id === t.id);
    if (
      this.billingApi.showLimitPopupIfBlocked(
        () => this.billingApi.canOpenWorkspace(r),
        "add-app-popup-accounts"
      )
    )
      return Promise.resolve();
    let s = this.workspaceRepository.getIsWorkspaceActive(t.id),
      a = this.sessionApi.prepareDataForNewWorkspaceWindow(t.id, s);
    return this.workspaceService.openOrFocusWorkspace(t, a);
  }
  moveAppInWorkspace(e, t, r) {
    this.workspaceService.moveAppInWorkspace(e, t, r);
  }
  async deleteWorkspaceById(e) {
    return (
      this.applicationApi.removeAppsByWorkspaceId(e),
      this.sessionApi.deleteSessionsByWorkspace(e),
      this.workspaceService.deleteWorkspaceById(e)
    );
  }
  closeWorkspace(e) {
    return this.workspaceService.closeWorkspace(e);
  }
  async createWorkspace(e, t) {
    if (
      this.billingApi.showLimitPopupIfBlocked(
        () => this.billingApi.canAddWorkspace(),
        "add-app-popup-accounts"
      )
    )
      return Promise.resolve();
    let i = await this.workspaceService.createWorkspace(e, t);
    return i
      ? (this.sessionApi.createSession({ workspaceId: i.id, name: i.name }),
        this.openWorkspace(i.id))
      : Promise.resolve();
  }
  changeAppIsPinned(e, t, r, i) {
    if (r) {
      let s = this.workspaceRepository.getWorkspaceIdForWindow(e);
      if (
        !s ||
        this.billingApi.showLimitPopupIfBlocked(
          () => this.billingApi.canPinApp(s),
          "add-app-popup-accounts"
        )
      )
        return;
      this.workspaceService.pinWorkspaceApp(e, t, i);
    } else
      this.workspaceService.unpinWorkspaceApp(e, t),
        this.applicationApi.clearPinnedByWorkspace(t);
  }
  async addApp(e, t, r) {
    let i = this.workspaceRepository.getWorkspaceIdForWindow(e);
    i && (await this.applicationApi.addApp(i, t, e, r));
  }
  async addCustomApp(e, t) {
    let r = this.workspaceRepository.getWorkspaceIdForWindow(e);
    r && (await this.applicationApi.addCustomApp(r, e, t));
  }
  async removeAppFromSidebar(e, t) {
    let r = this.workspaceRepository.getWorkspaceIdForWindow(e);
    return (
      r &&
        this.workspaceRepository.getHasAppPinned(r, t) &&
        (this.workspaceService.unpinWorkspaceApp(e, t),
        this.applicationApi.clearPinnedByWorkspace(t)),
      this.applicationApi.closeApplicationTab(t)
    );
  }
  removeAppFromWorkspace(e, t) {
    return (
      this.workspaceService.removeAppFromWorkspace(e, t),
      this.applicationApi.removeApp(t)
    );
  }
  setWorkspaceMinimized(e, t) {
    this.workspaceService.setWorkspaceMinimized(e, t);
  }
  changeBackground(e, t) {
    let r = this.workspaceRepository.getWorkspaceIdForWindow(e);
    return r ? this.workspaceService.changeBackground(r, t) : Promise.resolve();
  }
  changeBackgroundEmoji(e, t) {
    let r = this.workspaceRepository.getWorkspaceIdForWindow(e);
    return r
      ? this.workspaceService.changeBackgroundEmoji(r, t)
      : Promise.resolve();
  }
  changeBackgroundForWorkspace(e, t) {
    return this.workspaceService.changeBackground(e, t);
  }
  changeBackgroundEmojiForWorkspace(e, t) {
    return this.workspaceService.changeBackgroundEmoji(e, t);
  }
  changeAppPositionInOrderById(e, t, r) {
    return this.workspaceService.changeAppPositionInOrderById(e, t, r);
  }
  changeName(e, t) {
    let r = this.workspaceRepository.getWorkspaceForWindow(e);
    return r ? this.workspaceService.changeName(r, t) : Promise.resolve();
  }
  changeNameForWorkspace(e, t) {
    let r = this.workspaceRepository.getWorkspaceById(e);
    return r ? this.workspaceService.changeName(r, t) : Promise.resolve();
  }
  async openAppAndWorkspace(e) {
    return (
      await this.openWorkspace(e.workspaceId),
      this.applicationApi.activateApplication(e.id)
    );
  }
  onWorkspaceClick(e) {
    let t = this.workspaceRepository.getWorkspaceByPartition(e);
    if (!t) return;
    let r = this.workspaceRepository
      .getWorkspacesArray()
      .findIndex((n) => n.id === t.id);
    if (
      this.billingApi.showLimitPopupIfBlocked(
        () => this.billingApi.canOpenWorkspace(r),
        "add-app-popup-accounts"
      )
    )
      return;
    let s = this.workspaceRepository.getIsWorkspaceActive(t.id),
      a = this.sessionApi.prepareDataForNewWorkspaceWindow(t.id, s);
    this.workspaceService.onOpenWorkspaceHandler(t, a).catch(l);
  }
  onAddWorkspaceClick(e) {
    this.analyticsTracker.sendAnalyticsEvent(
      "profile.add-workspace-clicked",
      void 0
    ),
      !this.billingApi.showLimitPopupIfBlocked(
        () => this.billingApi.canAddWorkspace(),
        "add-app-popup-accounts"
      ) &&
        this.modalService
          .showWorkspaceCreationModal(
            { source: "profile.add-workspace-clicked" },
            e
          )
          .catch(l);
  }
  onOpenWorkspaceSettings(e) {
    this.analyticsTracker.sendAnalyticsEvent(
      "profile.workspaces-settings-clicked",
      void 0
    ),
      this.modalService
        .showWorkspacesManagementModal(
          { source: "profile.workspaces-settings-clicked" },
          e
        )
        .catch(l);
  }
};
c();
c();
var MS = (o, e, t) => {
  let r = o.slice();
  if (t >= r.length)
    for (let s = 0; s <= t - r.length + 1; s += 1) r.push(void 0);
  let [i] = r.splice(e, 1);
  return r.splice(t, 0, i), r;
};
c();
var pp = class {
  static createLocalWorkspace(e) {
    return {
      id: e,
      name: e,
      isTeamWorkspace: !1,
      isMinimized: !1,
      isRemovable: !1,
      orderAppIds: [],
      pinnedOrderAppIds: [],
      avatar: { type: "Basic", text: e.charAt(0), ...Ub },
      sandbox: !1,
      partitionDomain: e,
      teamUuid: null,
    };
  }
};
c();
var IE = 21,
  pi = class {
    static parseWorkspace(e, t) {
      return {
        id: e.uuid,
        name: e.name,
        isTeamWorkspace: e.team_workspace,
        isMinimized: !1,
        isRemovable: e.can_delete,
        orderAppIds: this.removeNanoids(e.services_order?.order ?? []),
        pinnedOrderAppIds: this.removeNanoids(
          e.pinned_services_order?.order ?? []
        ),
        avatar: this.deserializeAvatar(e.background, e.name),
        sandbox: e.sandbox,
        partitionDomain: t ? zr : e.uuid,
        teamUuid: e.team_uuid ?? null,
      };
    }
    static mergeLocalAndExternalWorkspaces(e, t) {
      return { ...t, partitionDomain: e.partitionDomain };
    }
    static removeNanoids(e) {
      return e.filter((t) => t.length !== IE);
    }
    static deserializeAvatar(e, t) {
      return !e || Xs(e) || !e.type || !e.value
        ? {
            type: "Basic",
            text: No(t),
            foregroundColor: "#808080",
            backgroundColor: "#ebebeb",
          }
        : e.type === "Color"
        ? {
            type: "Colored",
            text: No(t),
            foregroundColor: e.value.letterColor,
            backgroundColor: e.value.bg,
          }
        : {
            type: "Emoji",
            text: e.value.symbol,
            foregroundColor: "#000",
            backgroundColor: "#f8e2b2",
          };
    }
  };
var qi = class {
  constructor(e, t, r, i, s, a, n) {
    this.workspaceRepository = e;
    this.analyticsTracker = t;
    this.backendService = r;
    this.browserService = i;
    this.extraDataService = s;
    D.on("apps-added", this.addAppToWorkspace.bind(this)),
      D.on(
        "apps-added-after-onboarding",
        this.addAppsAfterOnboarding.bind(this)
      ),
      D.on(
        "apps-loaded",
        this.migrateOldApplicationsToNewWorkspaces.bind(this)
      ),
      n.subscribeToNormalWindowCreated(this.onWindowCreatedHandler.bind(this)),
      n.subscribeToWindowRemoved(this.onWindowRemovedHandler.bind(this)),
      n.subscribeToOpenProfileMenu(() => {
        this.analyticsTracker.sendAnalyticsEvent("profile.auto-open", void 0);
      }),
      _e.on("team-created", (p) => {
        p.workspaceId &&
          this.workspaceRepository.updateWorkspaceById(p.workspaceId, {
            teamUuid: p.team.uuid,
            isTeamWorkspace: !0,
          });
      }),
      a.subscribe(
        ["updated", "created", "deleted"],
        ["workspace.created", "workspace.updated", "workspace.deleted"],
        async () => {
          await this.loadWorkspaces(), await this.syncWorkspacesWithWindows();
        },
        { uri: Fr.getPath() }
      );
  }
  static async build(e, t, r, i, s, a, n) {
    let p = new qi(e, t, r, i, s, a, n);
    return await p.initWorkspaces(), p;
  }
  setWorkspaceMinimized(e, t) {
    let r = this.workspaceRepository.getWorkspaceIdForWindow(e);
    r && this.workspaceRepository.updateWorkspaceById(r, { isMinimized: t });
  }
  async changeAppPositionInOrderById(e, t, r) {
    let i = this.workspaceRepository.getWorkspaceForWindow(e);
    if (!i) return;
    let s = i.orderAppIds.indexOf(t);
    if (s === -1) return;
    let a = [...i.orderAppIds];
    a.splice(s, 1),
      a.splice(s + r, 0, t),
      this.workspaceRepository.updateWorkspaceById(i.id, { orderAppIds: a }),
      await this.updateWorkspaceById(i.id, { orderAppIds: a });
  }
  async changeBackground(e, t) {
    let r = await this.updateWorkspaceById(e, {
      background: {
        type: "Color",
        value: { bg: t.bg, letterColor: t.letterColor },
      },
    });
    return (
      this.workspaceRepository.updateWorkspaceById(e, r),
      this.updateWorkspacesInfoInBrowser()
    );
  }
  async changeBackgroundEmoji(e, t) {
    let r = await this.updateWorkspaceById(e, {
      background: { type: "Emoji", value: t },
    });
    return (
      this.workspaceRepository.updateWorkspaceById(e, r),
      this.updateWorkspacesInfoInBrowser()
    );
  }
  async changeName(e, t) {
    if (e.name === t) return Promise.resolve();
    let r = Ei(t);
    if (e.avatar.type === "Colored" || e.avatar.type === "Basic")
      return this.updateIcon(e.id, r);
    let i = { name: r };
    return (
      this.workspaceRepository.updateWorkspaceById(e.id, i),
      await this.updateWorkspaceById(e.id, i),
      this.updateWorkspacesInfoInBrowser()
    );
  }
  moveAppInWorkspace(e, t, r) {
    let i = this.workspaceRepository.getWorkspaceForWindow(e);
    if (!i) return;
    let s = i.pinnedOrderAppIds.indexOf(t),
      a = MS(i.pinnedOrderAppIds, s, r);
    this.workspaceRepository.updateWorkspaceById(i.id, {
      pinnedOrderAppIds: a,
    }),
      this.updateWorkspaceById(i.id, { pinnedOrderAppIds: a }).catch(l);
  }
  removeAppFromWorkspace(e, t) {
    let r = this.workspaceRepository.getWorkspaceForWindow(e);
    if (!r) return;
    let i = r.pinnedOrderAppIds.filter((p) => p !== t),
      s = r.orderAppIds.filter((p) => p !== t),
      n =
        r.pinnedOrderAppIds.length === i.length
          ? { orderAppIds: s }
          : { orderAppIds: s, pinnedOrderAppIds: i };
    this.workspaceRepository.updateWorkspaceById(r.id, n),
      this.updateWorkspaceById(r.id, n).catch(l);
  }
  pinWorkspaceApp(e, t, r) {
    let i = this.workspaceRepository.getWorkspaceForWindow(e);
    if (!i) return;
    let s = this.getUpdatedOrderAppIds(i.pinnedOrderAppIds, t, r);
    this.workspaceRepository.updateWorkspaceById(i.id, {
      pinnedOrderAppIds: s,
    }),
      this.updateWorkspaceById(i.id, { pinnedOrderAppIds: s }).catch(l);
  }
  unpinWorkspaceApp(e, t) {
    let r = this.workspaceRepository.getWorkspaceForWindow(e);
    if (!r) return;
    let i = r.pinnedOrderAppIds.filter((a) => a !== t);
    r.pinnedOrderAppIds.length !== i.length &&
      (this.workspaceRepository.updateWorkspaceById(r.id, {
        pinnedOrderAppIds: i,
      }),
      this.updateWorkspaceById(r.id, { pinnedOrderAppIds: i }).catch(l));
  }
  openOrFocusWorkspace(e, t) {
    let r = this.workspaceRepository.getWindowForFocusOnWorkspace(e.id);
    return r ? this.browserService.focusWindow(r) : this.openWorkspace(e, t);
  }
  async createWorkspace(e, t) {
    let r = await this.backendService.desktop.createWorkspace({
      name: e,
      background: t,
    });
    if (!r) return;
    let i = pi.parseWorkspace(r, !1);
    return (
      this.workspaceRepository.addWorkspace(i),
      await this.updateWorkspacesInfoInBrowser(),
      i
    );
  }
  closeWorkspace(e) {
    let t = this.workspaceRepository.getActiveWindowsForWorkspace(e);
    return Promise.all(
      t.map(async (r) => {
        r && (await this.browserService.closeWindow(r));
      })
    );
  }
  async deleteWorkspaceById(e) {
    let t = this.workspaceRepository.getWorkspaceById(e);
    return t
      ? (await this.closeWorkspace(e),
        this.backendService.desktop.deleteWorkspaceById(e).catch(l),
        re.emit("partition-cleared", t.partitionDomain),
        this.browserService
          .clearPartitionForWorkspace(t.partitionDomain)
          .catch(l),
        this.workspaceRepository.deleteWorkspaceById(e),
        this.updateWorkspacesInfoInBrowser())
      : Promise.resolve();
  }
  async onOpenWorkspaceHandler(e, t) {
    let r = this.workspaceRepository.getWindowForFocusOnWorkspace(e.id),
      i = Boolean(r),
      s = Boolean(
        i && r === (await this.browserService.getLastFocusedWindowId())
      );
    return (
      this.analyticsTracker.sendAnalyticsEvent("profile.workspace-selected", {
        "total-workspaces":
          this.workspaceRepository.getWorkspacesArray().length,
        "active-workspaces":
          this.workspaceRepository.getActiveWorkspacesIds().length + 1,
        "workspace.is-active": i,
        "workspace.is-current": s,
      }),
      r
        ? this.browserService.focusWindow(r).then(() => {})
        : this.openWorkspace(e, t)
    );
  }
  convertPersonalWorkspaceToTeam(e) {
    this.workspaceRepository.updateWorkspaceById(e, { isTeamWorkspace: !0 });
  }
  async initWorkspaces() {
    return Boolean(this.workspaceRepository.getWorkspacesArray().length)
      ? (this.loadWorkspaces()
          .then(() => this.syncWorkspacesWithWindows(!1))
          .catch(l),
        this.syncWorkspacesWithWindows())
      : (await this.loadWorkspaces(), this.syncWorkspacesWithWindows(!1));
  }
  async openWorkspace({ id: e, partitionDomain: t }, r) {
    if (r) {
      let s = {
          ...this.extraDataService.createWindowData(r.session.id, !0),
          partitionDomain: t,
        },
        a = await this.browserService.createWindowWithTabs(s, r.sessionTabs);
      if (!a) return;
      this.workspaceRepository.setWorkspaceIdForWindow(a.id, e);
    } else {
      let i = await this.browserService.createWindow({ partitionDomain: t });
      if (!i) return;
      this.workspaceRepository.setWorkspaceIdForWindow(i.id, e);
    }
    this.tryActivateWorkspace(e).catch(l);
  }
  async updateIcon(e, t) {
    let r = await this.updateWorkspaceById(e, { name: t });
    this.workspaceRepository.updateWorkspaceById(e, r),
      this.updateWorkspacesInfoInBrowser().catch(l);
  }
  addAppToWorkspace(e, t, r, i, s = !1) {
    let a = this.workspaceRepository.getWorkspaceById(r);
    if (!a) return;
    let n = i ? a.orderAppIds.indexOf(i) : void 0,
      d = {
        orderAppIds: this.getUpdatedOrderAppIds(a.orderAppIds, e, n).filter(
          (u) => u !== i
        ),
      };
    if (s) {
      let u = i ? a.pinnedOrderAppIds.indexOf(i) : void 0,
        m = this.getUpdatedOrderAppIds(a.pinnedOrderAppIds, e, u).filter(
          (y) => y !== i
        );
      d = { ...d, pinnedOrderAppIds: m };
    }
    this.workspaceRepository.updateWorkspaceById(r, d),
      i &&
        (this.updateWorkspaceById(a.id, d).catch(l),
        this.updateWorkspacesInfoInBrowser().catch(l));
  }
  onWindowCreatedHandler({ partitionDomain: e, id: t }) {
    if (!t || e === void 0) return;
    let r = this.workspaceRepository.getWorkspaceIdByPartition(e);
    r &&
      (this.workspaceRepository.setWorkspaceIdForWindow(t, r),
      this.tryActivateWorkspace(r).catch(l),
      this.trackPartitions().catch(l));
  }
  async trackPartitions() {
    let e = 0;
    (await this.browserService.getAllNormalWindows()).forEach((r) => {
      if (!r.partitionDomain) return;
      let i = this.workspaceRepository.getWorkspaceIdByPartition(
          r.partitionDomain
        ),
        s = this.workspaceRepository.getWorkspaceForWindow(r.id)?.id;
      i !== s && (e += 1);
    }),
      e !== 0 &&
        l(
          new L(
            "Workspaces. Found discrepancy browser and extension partitionDomains cache.",
            { level: "error", extra: { windowsCount: e } }
          )
        );
  }
  onWindowRemovedHandler(e, t) {
    let r = this.workspaceRepository.getWorkspaceIdForWindow(e);
    r &&
      (this.workspaceRepository.deleteWorkspaceIdForWindow(e),
      this.tryDeactivateWorkspace(r, t.hasShutdownStarted).catch(l));
  }
  async tryActivateWorkspace(e) {
    this.workspaceRepository.getIsWorkspaceActive(e) ||
      (this.workspaceRepository.activateWorkspace(e),
      await this.updateWorkspacesInfoInBrowser());
  }
  async tryDeactivateWorkspace(e, t) {
    this.workspaceRepository.getHasWorkspaceActiveWindows(e) ||
      (this.workspaceRepository.deactivateWorkspace(e),
      !t && (await this.updateWorkspacesInfoInBrowser()));
  }
  getUpdatedOrderAppIds(e, t, r) {
    let i = r === void 0 ? e.length : r,
      s = [...e];
    return s.splice(i, 0, t), [...new Set(s)];
  }
  migrateOldApplicationsToNewWorkspaces(e) {
    let t = () => ({ pinnedSet: new Set(), orderedSet: new Set() }),
      r = new Set(),
      i = new Map();
    e.forEach(({ id: n, pinnedByWorkspace: p, workspaceId: d }) => {
      let u = this.workspaceRepository.getWorkspaceById(d);
      r.add(d);
      let { pinnedSet: m, orderedSet: y } = Ai(i, d, t),
        b = u?.pinnedOrderAppIds.includes(n);
      (p[d] || b) && m.add(n),
        y.add(n),
        i.set(d, { orderedSet: y, pinnedSet: m });
    });
    let s = this.workspaceRepository.getDefaultWorkspace();
    g(s, "Couldnt find default workspace to finish app migration");
    let a = new Map();
    r.forEach((n) => {
      let { pinnedSet: p, orderedSet: d } = Ai(i, n, t),
        {
          id: u,
          pinnedOrderAppIds: m,
          orderAppIds: y,
        } = this.workspaceRepository.getWorkspaceById(n) ?? s,
        { set: b, areChanged: v } = this.getCleanWorkspaceAppIdsSet(
          p,
          m,
          (I) => p.has(I) && d.has(I)
        ),
        { set: S, areChanged: w } = this.getCleanWorkspaceAppIdsSet(d, y, (I) =>
          d.has(I)
        );
      if (!v && !w) return;
      let T = {};
      v && (T = { pinnedOrderAppIds: [...b] }),
        w && (T = { ...T, orderAppIds: [...S] }),
        a.set(u, T);
    }),
      new Array(...a.entries()).forEach(([n, p]) => {
        this.workspaceRepository.updateWorkspaceById(n, p),
          this.updateWorkspaceById(n, p).catch(l);
      });
  }
  getCleanWorkspaceAppIdsSet(e, t, r) {
    let i = t.filter(r),
      s = i.length !== t.length;
    i.push(...e);
    let a = new Set(i);
    return (s = s || a.size !== t.length), { areChanged: s, set: a };
  }
  addAppsAfterOnboarding(e) {
    let t = this.workspaceRepository.getDefaultWorkspace();
    if (!t || e.length === 0) return;
    let r = [...t.orderAppIds],
      i = [...t.pinnedOrderAppIds];
    e.forEach(({ app: a, isPinned: n }) => {
      r.push(a.id), n && i.push(a.id);
    });
    let s = { orderAppIds: r, pinnedOrderAppIds: i };
    this.workspaceRepository.updateWorkspaceById(t.id, s),
      this.updateWorkspaceById(t.id, s).catch(l),
      this.updateWorkspacesInfoInBrowser().catch(l);
  }
  async updateWorkspaceById(e, t) {
    let r =
        this.workspaceRepository.getWorkspaceById(e)?.partitionDomain === zr,
      i = await this.backendService.desktop.updateWorkspaceById({
        id: e,
        changes: {
          name: t.name,
          services_order: t.orderAppIds && { order: t.orderAppIds },
          pinned_services_order: t.pinnedOrderAppIds && {
            order: t.pinnedOrderAppIds,
          },
          background: t.background,
        },
      });
    return pi.parseWorkspace(i, r);
  }
  async updateWorkspacesInfoInBrowser() {
    let e = this.workspaceRepository.getWorkspacesArray(),
      t = await Promise.all(
        e.map(async ({ partitionDomain: r, name: i, id: s, avatar: a }) => ({
          iconUrl: await this.browserService.createIconForWorkspace(
            a.type === "Emoji" ? a.text : xb(a.text),
            a.foregroundColor,
            a.backgroundColor
          ),
          name: i,
          partitionDomain: r,
          isActive: this.workspaceRepository.getIsWorkspaceActive(s),
        }))
      );
    return this.browserService.setAllInfoAboutWorkspaces(t);
  }
  async syncWorkspacesWithWindows(e = !0) {
    let t = await this.browserService.getAllNormalWindows(),
      r = !1;
    return (
      t.forEach(({ id: i, partitionDomain: s }) => {
        if (i === void 0 || s === void 0) return;
        let a = this.workspaceRepository.getWorkspaceIdByPartition(s);
        if (!a) {
          if (!e) {
            r = this.safelyCloseWindowInSyncProblems(r, i);
            return;
          }
          let n = pp.createLocalWorkspace(s);
          this.workspaceRepository.addWorkspace(n), (a = n.id);
        }
        this.workspaceRepository.setWorkspaceIdForWindow(i, a),
          this.workspaceRepository.activateWorkspace(a);
      }),
      this.updateWorkspacesInfoInBrowser()
    );
  }
  safelyCloseWindowInSyncProblems(e, t) {
    if (!e) {
      let r = this.workspaceRepository.getWorkspacesArray()[0];
      if (r)
        return (
          this.openWorkspace(r)
            .then(() => this.browserService.closeWindow(t))
            .catch(l),
          !0
        );
    }
    return this.browserService.closeWindow(t).catch(l), !1;
  }
  async loadWorkspaces() {
    let e = await this.backendService.desktop.getWorkspaces();
    g(e[0], "Failed to load workspaces: no workspaces fetched from backend");
    let t = this.workspaceRepository.getWorkspacesById(),
      r = new Map(),
      i = [];
    e.forEach((s, a) => {
      let n = a === 0,
        p = pi.parseWorkspace(s, n),
        d = t.get(p.partitionDomain);
      if (!d) {
        r.set(p.id, p), i.push(p);
        return;
      }
      let u = pi.mergeLocalAndExternalWorkspaces(d, p);
      r.set(p.id, u);
    }),
      this.workspaceRepository.setWorkspacesById(r),
      re.emit("workspaces-loaded", [...r.values()], i);
  }
};
c();
c();
var zi = class extends ot {
  constructor(t) {
    super();
    this.browserStorage = t;
  }
  state = {
    freePlan: { planId: 1, currency: "USD", price: 0, monthlyPrice: 0 },
    proMonthlyPlan: {
      planId: 199,
      currency: "USD",
      price: 168,
      monthlyPrice: 14,
    },
    proYearlyPlan: { planId: 167, currency: "USD", price: 96, monthlyPrice: 8 },
  };
  static async build(t) {
    let r = new zi(t);
    return await r.loadFromCache(), r;
  }
  getPlans() {
    return this.state;
  }
  getProgressiveDiscountOfferPlan() {
    return this.state.progressiveDiscountOffer;
  }
  getAfterTrialDiscountOffer() {
    return this.state.afterTrialDiscountOffer;
  }
  getCancelDiscountOffer() {
    return this.state.cancelDiscountOffer;
  }
  getTeamProPlan() {
    return this.state.teamProMonthlyPlan;
  }
  getTeamEnterprisePlan() {
    return this.state.enterprisePlan;
  }
  setStateFromNetwork(t) {
    (this.state = t),
      (this.isLoadedFromNetwork = !0),
      se.emit("billing-plans-loaded"),
      this.updateCache().catch(l);
  }
  updateCache() {
    return this.state
      ? this.browserStorage.setItem("billing-plans", this.state)
      : this.browserStorage.removeItem("billing-plans");
  }
  async loadFromCache() {
    let t = await this.browserStorage.getItem("billing-plans");
    t &&
      ((this.isLoadedFromCache = !0),
      (this.state = t),
      se.emit("billing-plans-loaded"));
  }
};
c();
var Qi = class {
  constructor(e, t) {
    this.browserStorage = e;
    this.billingUrl = t;
  }
  billingPlan;
  lastBillingPlanReloadTimestamp = null;
  logger = x.createInstance("billing");
  static async build(e, t = me.SIDEKICK_BILLING_PAGE ?? "") {
    let r = new Qi(e, t);
    return await r.loadBillingPlanFromStorage(), r;
  }
  async loadBillingPlanFromStorage() {
    let e = await this.browserStorage.getItem("billing-plan");
    e &&
      (this.setBillingPlan(e),
      this.logger.info("Billing plan loaded from storage", e),
      se.emit("billing-plan-loaded", e));
  }
  getSubscriptionTimeLeftDays() {
    let e = this.getBillingPlan()?.options.subscriptionTimeLeft;
    if (!e || !this.lastBillingPlanReloadTimestamp) return null;
    let r = Date.now() - this.lastBillingPlanReloadTimestamp,
      i = e - Ue(r);
    return Math.ceil(Rr(ce(i)));
  }
  getBillingPlan() {
    return this.billingPlan;
  }
  getBillingPlanName() {
    let e = this.billingPlan?.options;
    return e?.isTeam ? e.planName : `Sidekick ${e?.planName ?? "Free"}`;
  }
  getIsPaid() {
    return Boolean(this.getBillingPlan()?.options.isPaid);
  }
  getIsTeam() {
    return Boolean(this.getBillingPlan()?.options.isTeam);
  }
  getIsMonthlyPaid() {
    return (
      this.getIsPaid() && this.getBillingPlan()?.options.interval === "month"
    );
  }
  getIsGift() {
    return Boolean(this.getBillingPlan()?.options.isGift);
  }
  getIsPro() {
    return Boolean(this.getBillingPlan()?.options.isPro);
  }
  getIsTrial() {
    return Boolean(this.getBillingPlan()?.options.isTrial);
  }
  getCanManagePlan() {
    return Boolean(this.getBillingPlan()?.canManage);
  }
  getShouldUseProBadgesForUI() {
    let e = this.getBillingPlan()?.options;
    return e ? e.isTrial || !e.isPro : !0;
  }
  getBillingPlanOption(e) {
    return this.billingPlan?.planOptions[e];
  }
  getPlanName() {
    return this.getBillingPlan()?.options.planName;
  }
  getUpgradePlanTabUrl(e) {
    return `${this.billingUrl}/redirect?session_id=${e}`;
  }
  getLastBillingPlanReloadTimestamp() {
    return this.lastBillingPlanReloadTimestamp;
  }
  getCancelAt() {
    return this.billingPlan?.cancelAt ?? null;
  }
  setBillingPlan(e) {
    (this.billingPlan = e),
      (this.lastBillingPlanReloadTimestamp = Date.now()),
      this.saveBillingPlanToStorage().catch(l);
  }
  canShareApp() {
    return this.getBillingPlanOption("appSharingLimit") !== 0;
  }
  canUseSplitView() {
    return this.getBillingPlanOption("splitViewLimitPerWindow") !== 0;
  }
  canUseIntercom(e) {
    return Boolean(this.getBillingPlanOption("canUseIntercom"))
      ? !(e && this.billingPlan?.options.isTrial)
      : !1;
  }
  canUseAdblock() {
    return Boolean(this.getBillingPlanOption("canUseAdblock"));
  }
  canAddApp(e) {
    if (!this.billingPlan) return !1;
    let { totalAppsLimit: t } = this.billingPlan.planOptions;
    return t === null ? !0 : e < t;
  }
  canAddAccount(e) {
    if (!this.billingPlan) return !1;
    let { accountsLimitPerApp: t } = this.billingPlan.planOptions;
    return t === null ? !0 : e < t;
  }
  canAddWorkspace(e) {
    if (!this.billingPlan) return !1;
    let { workspacesLimit: t } = this.billingPlan.planOptions;
    return t === null ? !0 : e < t;
  }
  canOpenWorkspace(e) {
    if (!this.billingPlan) return !1;
    let { workspacesLimit: t } = this.billingPlan.planOptions;
    return t === null ? !0 : e < t;
  }
  canAddSessions(e) {
    if (!this.billingPlan) return !1;
    let { sessionsPerWorkspaceLimit: t } = this.billingPlan.planOptions;
    return t === null ? !0 : e < t;
  }
  canEditSessions(e) {
    if (!this.billingPlan) return !1;
    let { sessionsPerWorkspaceLimit: t } = this.billingPlan.planOptions;
    return t === null ? !0 : e < t;
  }
  canPinApp(e) {
    if (!this.billingPlan) return !1;
    let { pinnedAppsLimit: t } = this.billingPlan.planOptions;
    return t === null ? !0 : e < t;
  }
  canOpenLaunchpadApp(e) {
    if (!this.billingPlan) return !1;
    let { totalAppsLimit: t } = this.billingPlan.planOptions;
    return t === null ? !0 : e < t;
  }
  canOpenSidebarApp(e) {
    if (!this.billingPlan) return !1;
    let { pinnedAppsLimit: t } = this.billingPlan.planOptions;
    return t === null ? !0 : e < t;
  }
  saveBillingPlanToStorage() {
    return this.billingPlan
      ? this.browserStorage.setItem("billing-plan", this.billingPlan)
      : Promise.resolve();
  }
};
c();
var lp = class {
  invitationsPlans;
  invitationStats;
  getInvitationsStats() {
    return this.invitationStats;
  }
  getInviteLink() {
    return this.invitationStats?.inviteLink ?? "https://meetsidekick.com";
  }
  getInvitationsPlans() {
    return this.invitationsPlans;
  }
  getBestActivatedPlan() {
    return this.invitationsPlans?.find((e) => e.wasActivated);
  }
  getForeverFreePlan() {
    if (this.invitationsPlans)
      return this.invitationsPlans.find((e) => e.durationInMonths === null);
  }
  getBestAvailablePlanForUpgrade() {
    if (!this.invitationsPlans || !this.invitationStats) return;
    let { activations: e } = this.invitationStats.statistics,
      t = this.invitationsPlans.filter(
        (r) => !r.wasActivated && r.requiredActivations <= Number(e)
      );
    return t[t.length - 1];
  }
  setInvitationsStats(e) {
    (this.invitationStats = e), se.emit("invitations-stats-loaded", e);
  }
  setInvitationsPlans(e) {
    this.invitationsPlans = e;
  }
  isForeverFreePlanActive() {
    return this.getForeverFreePlan()?.wasActivated ?? !1;
  }
  getForeverFreePlanRequiredActivations() {
    return this.getForeverFreePlan()?.requiredActivations ?? 20;
  }
};
c();
var Yi = class extends Wr {
  constructor(t) {
    super();
    this.browserStorage = t;
  }
  state = {};
  activeSessions = {};
  static async build(t) {
    let r = new Yi(t);
    return await r.loadFromCache(), r;
  }
  getSessionsArray() {
    return Object.values(this.state);
  }
  getSessionsByWorkspaceId(t) {
    return this.getSessionsArray().filter((r) => r.workspaceId === t);
  }
  getSessionsByTemporaryStatus(t) {
    return this.getSessionsArray().filter((r) => r.isTemporary === t);
  }
  getWindowIdBySessionId(t) {
    let r = Object.keys(this.activeSessions).find(
      (i) => this.activeSessions[Number(i)] === t
    );
    if (r) return Number(r);
  }
  getSessionsByLastUsedByWorkspaceId(t) {
    return t
      ? this.getSessionsByWorkspaceId(t).sort((r, i) =>
          r.lastTimeUsed
            ? i.lastTimeUsed
              ? i.lastTimeUsed - r.lastTimeUsed
              : -1
            : 1
        )
      : [];
  }
  getOrderedTabs(t) {
    let r = this.state[t];
    return r
      ? r.tabsOrder.reduce((i, s) => {
          let a = r.tabsById[s];
          return a && i.push(a), i;
        }, [])
      : [];
  }
  getSessionById(t) {
    return this.state[t];
  }
  getSessionLastUsedIndexById(t, r) {
    return this.getSessionsByLastUsedByWorkspaceId(r).findIndex(
      (i) => i.id === t
    );
  }
  getActiveSessionsLength() {
    return Object.values(this.activeSessions).length;
  }
  getSessionByWindowId(t) {
    let r = this.activeSessions[t];
    if (r) return this.state[r];
  }
  getIsTabInTabGroup(t, r) {
    return Object.values(r.tabsByGroupId).flat().includes(t);
  }
  getTabGroup(t, r) {
    return this.state[t]?.tabGroupsById[r];
  }
  getTabGroupByBrowserId(t, r) {
    let i = this.state[t]?.tabGroupsById;
    if (i) return Object.values(i).find((s) => s.browserId === r);
  }
  addTabGroup(t, r) {
    let i = this.state[t];
    g(i, "No session for adding tab group"),
      (i.tabGroupsById[r.id] = r),
      this.updateSessionSilently(t, { updatedAt: Date.now() }),
      pe.emit("session-tab-group-changed", t, r.id, r),
      this.updateCache().catch(l);
  }
  deleteTabGroup(t, r) {
    delete this.state[t]?.tabGroupsById[r],
      delete this.state[t]?.tabsByGroupId[r],
      this.updateSessionSilently(t, { updatedAt: Date.now() }),
      pe.emit("session-tab-group-changed", t, r),
      this.updateCache().catch(l);
  }
  updateTabGroup(t, r, i) {
    let s = this.state[t];
    if (!s) return;
    let a = s.tabGroupsById[r];
    a &&
      (this.updateSessionSilently(t, { updatedAt: Date.now() }),
      (s.tabGroupsById[r] = { ...a, ...i }),
      pe.emit("session-tab-group-changed", t, r, i),
      this.updateCache().catch(l));
  }
  updateGroupForTab(t, r, i) {
    let s = this.state[t];
    if (!s) return;
    this.updateSessionSilently(t, { updatedAt: Date.now() });
    let a = this.deleteTabFromGroupSilently(s, r);
    a && pe.emit("session-tab-group-changed", t, a),
      i &&
        (s.tabsByGroupId[i]
          ? s.tabsByGroupId[i]?.push(r)
          : (s.tabsByGroupId[i] = [r]),
        pe.emit("session-tab-group-changed", t, i)),
      pe.emit("session-tab-changed", t, r),
      this.updateCache().catch(l);
  }
  deleteTabFromGroup(t, r) {
    let i = this.state[t];
    if (!i) return;
    let s = this.deleteTabFromGroupSilently(i, r);
    s &&
      (this.updateSessionSilently(t, { updatedAt: Date.now() }),
      pe.emit("session-tab-group-changed", t, s),
      this.updateCache().catch(l));
  }
  getTabGroupForTabBySessionId(t, r) {
    let i = this.state[t];
    if (!i) return;
    let s = Object.keys(i.tabsByGroupId).find((a) =>
      i.tabsByGroupId[a]?.includes(r)
    );
    if (s) return i.tabGroupsById[s];
  }
  deleteTabFromGroupSilently(t, r) {
    for (let [i, s] of Object.entries(t.tabsByGroupId)) {
      let a = s.findIndex((n) => n === r);
      if (a !== -1) return t.tabsByGroupId[i]?.splice(a, 1), i;
    }
  }
  getTab(t, r) {
    return this.state[t]?.tabsById[r];
  }
  getAllTabs() {
    return Object.values(this.state)
      .map((t) => Object.values(t.tabsById))
      .flat();
  }
  getSessionTabsLength(t) {
    return this.state[t]?.tabsOrder.length ?? 0;
  }
  getTabByWindowId(t, r) {
    let i = this.activeSessions[t];
    if (!i) return;
    let s = this.state[i];
    if (s) return Object.values(s.tabsById).find((a) => a.browserId === r);
  }
  getTabAndSessionByBrowserId(t) {
    for (let r of Object.values(this.state)) {
      let i = Object.values(r.tabsById).find((s) => s.browserId === t);
      if (i) return { tab: i, session: r };
    }
  }
  getTabByWindowIdAndTabId(t, r) {
    let i = this.activeSessions[t];
    if (!i) return;
    let s = this.state[i];
    if (s) return s.tabsById[r];
  }
  getIndexOfTab(t, r) {
    return this.state[t]?.tabsOrder.findIndex((i) => i === r) ?? -1;
  }
  getTabByIndex(t, r) {
    let i = this.state[t]?.tabsOrder[r];
    if (i) return this.state[t]?.tabsById[i];
  }
  getHiddenPinnedTabsBeforeIndex(t, r) {
    let i = this.state[t];
    return (
      g(i, "No existing session for ordering"),
      i.tabsOrder.reduce((s, a, n) => {
        let p = i.tabsById[a];
        return !p?.pinned || !p.browserId || n < r || s.push(p), s;
      }, [])
    );
  }
  getAllHiddenPinnedSessionTabs(t, r) {
    let i = this.state[t];
    return (
      g(i, "No existing session for ordering"),
      i.tabsOrder.reduce((s, a) => {
        let n = i.tabsById[a];
        return !n?.pinned || !n.browserId || n.id === r || s.push(n), s;
      }, [])
    );
  }
  getLastActiveTabInSession(t) {
    let r = this.state[t]?.lastActiveSessionTabId;
    return r ? this.getTab(t, r) ?? null : null;
  }
  moveTabToSession(t, r, i, s) {
    this.deleteTab(t, i.id), this.addTab(r, i, s);
  }
  reorderTabInSession(t, r, i) {
    let s = this.state[t];
    g(s, "No session while adding a tab");
    let [a] = s.tabsOrder.splice(r, 1);
    if (a)
      return (
        this.updateSessionSilently(t, { updatedAt: Date.now() }),
        s.tabsOrder.splice(i, 0, a),
        pe.emit("session-tab-changed", t, a),
        this.updateCache().catch(l),
        a
      );
  }
  addTab(t, r, i, s) {
    let a = this.state[t];
    return (
      g(a, "No session while adding a tab"),
      this.updateSessionSilently(t, { updatedAt: Date.now() }),
      (a.tabsById[r.id] = r),
      typeof i == "number"
        ? a.tabsOrder.splice(i, 0, r.id)
        : a.tabsOrder.push(r.id),
      s && a.tabsByGroupId[s]?.push(r.id),
      pe.emit("session-tab-changed", t, r.id, r),
      this.updateCache().catch(l),
      r
    );
  }
  updateTab(t, r, i) {
    let s = this.state[t];
    g(s, "No session while updating");
    let a = s.tabsById[r];
    return (
      g(a, "No tab while updating"),
      this.updateSessionSilently(t, { updatedAt: Date.now() }),
      (s.tabsById[r] = { ...a, ...i }),
      pe.emit("session-tab-changed", t, r, i),
      this.updateCache().catch(l),
      a
    );
  }
  deleteTabByWindowId(t, r) {
    let i = this.activeSessions[t];
    i && this.deleteTab(i, r);
  }
  deleteTab(t, r) {
    let i = this.state[t];
    g(i, "No session while deleting a tab"),
      this.updateSessionSilently(t, { updatedAt: Date.now() }),
      delete i.tabsById[r];
    let s = i.tabsOrder.indexOf(r);
    s !== -1 && i.tabsOrder.splice(s, 1),
      pe.emit("session-tab-changed", t, r),
      this.updateCache().catch(l);
  }
  setActiveSessionByWindowId(t, r, i = !1) {
    let s = this.state[r];
    g(s, "No session for window to set active"), (this.activeSessions[t] = r);
    let a = { lastTimeUsed: Date.now() };
    return (
      (this.state[r] = { ...s, ...a }),
      pe.emit("session-changed", r, a, i),
      pe.emit("session-open", t, i),
      this.updateCache().catch(l),
      s
    );
  }
  addSession(t) {
    return (
      (this.state[t.id] = t),
      pe.emit("session-changed", t.id, t, !0),
      this.updateCache().catch(l),
      t
    );
  }
  getSessionByExternalUUID(t) {
    return this.getSessionsArray().find((r) => r.externalUUID === t);
  }
  deleteSession(t) {
    let r = this.state[t]?.externalUUID;
    delete this.state[t],
      pe.emit("session-changed", t, { externalUUID: r }, void 0, !0),
      this.updateCache().catch(l);
  }
  updateSession(t, r) {
    this.updateSessionSilently(t, r) &&
      (pe.emit("session-changed", t, r), this.updateCache().catch(l));
  }
  deactivateSessionByWindowId(t) {
    let r = this.activeSessions[t];
    if (!r) return;
    let i = this.state[r];
    i &&
      (i.isTemporary && delete this.state[r],
      delete this.activeSessions[t],
      Object.values(i.tabsById).forEach((s) => {
        i.tabsById[s.id] = { ...s, browserId: void 0 };
      }),
      pe.emit("session-changed", r),
      this.updateCache().catch(l));
  }
  updateSessionSilently(t, r) {
    let i = this.state[t];
    return i ? ((this.state[t] = { ...i, ...r }), !0) : !1;
  }
  updateCache() {
    let t = {};
    return (
      Object.entries(this.state).forEach(([r, i]) => {
        i.isTemporary || (t[r] = i);
      }),
      this.browserStorage.setItem("sessions", t)
    );
  }
  async loadFromCache() {
    let t = await this.browserStorage.getItem("sessions");
    t &&
      ((this.state = t),
      (this.isLoadedFromCache = !0),
      pe.emit("session-loaded"));
  }
};
c();
var Xi = class extends ot {
  constructor(t) {
    super();
    this.browserStorage = t;
  }
  state = {};
  static async build(t) {
    let r = new Xi(t);
    return await r.loadFromCache(), r;
  }
  getState() {
    return this.state;
  }
  setStateFromNetwork(t) {
    (this.state = t),
      (this.isLoadedFromNetwork = !0),
      _e.emit("team-browser-policies-loaded", this.state),
      this.updateCache().catch(l);
  }
  updateCache() {
    return this.state
      ? this.browserStorage.setItem("browser-policies", this.state)
      : this.browserStorage.removeItem("browser-policies");
  }
  async loadFromCache() {
    let t = await this.browserStorage.getItem("browser-policies");
    t &&
      ((this.isLoadedFromCache = !0),
      (this.state = t),
      _e.emit("team-browser-policies-loaded", this.state));
  }
};
c();
var Ji = class extends ot {
  constructor(t) {
    super();
    this.browserStorage = t;
  }
  teamsById = {};
  static async build(t) {
    let r = new Ji(t);
    return await r.loadFromCache(), r;
  }
  getTeams() {
    return this.teamsById;
  }
  getTeam(t) {
    return this.teamsById[t] ?? null;
  }
  getIsOwner(t) {
    return t ? this.getTeam(t)?.role === "owner" : !1;
  }
  updateTeamById(t, r) {
    let i = this.getTeam(t);
    i && ((this.teamsById[t] = { ...i, ...r }), this.updateCache().catch(l));
  }
  createTeam(t, r) {
    this.addTeam(t), _e.emit("team-created", { team: t, workspaceId: r });
  }
  addTeam(t) {
    (this.teamsById[t.uuid] = t), this.updateCache().catch(l);
  }
  canAddNewTeamApplications(t) {
    if (!t) return !1;
    let r = this.getTeam(t)?.role ?? null;
    return r === "admin" || r === "owner";
  }
  setStateFromNetwork(t) {
    (this.isLoadedFromNetwork = !0),
      this.setTeamsById(t),
      this.updateCache().catch(l);
  }
  setTeamsById(t) {
    (this.teamsById = t), _e.emit("teams-loaded", this.teamsById);
  }
  async loadFromCache() {
    let t = await this.browserStorage.getItem("teams");
    t && ((this.isLoadedFromCache = !0), this.setTeamsById(t));
  }
  updateCache() {
    return this.browserStorage.setItem("teams", this.teamsById);
  }
};
c();
c();
var dp = class {
  static parseUser(e) {
    return {
      name: e.name ?? null,
      email: e.email,
      avatar: e.avatar ?? null,
      hasTemporaryEmail: e.has_temporary_email,
      hasStripeCustomerId: e.has_stripe_customer_id,
      registeredAt: e.registered_at,
      registeredWith: e.registered_with,
      registeredDomain: e.registered_domain,
      inviterCode: e.inviter_code,
      sidekickIsDefault: e.sidekick_is_default,
    };
  }
};
var Zi = class extends ot {
  constructor(t) {
    super();
    this.browserStorage = t;
  }
  userInfo;
  logger = x.createInstance("user");
  static async build(t) {
    let r = new Zi(t);
    return await r.loadFromCache(), r;
  }
  getUserInfo() {
    return this.userInfo;
  }
  async getEnsuredUserInfo() {
    let t = this.getUserInfo();
    return (
      t ||
      new Promise((r) => {
        W.once("user-loaded", r);
      })
    );
  }
  getIsTemporaryUser() {
    return Boolean(this.getUserInfo()?.hasTemporaryEmail);
  }
  getIsUserAuthorizedWithGSuite() {
    let t = this.getUserInfo();
    return t?.registeredDomain !== null && t?.registeredWith === "google";
  }
  setStateFromNetwork(t) {
    (this.userInfo = dp.parseUser(t)),
      this.logger.info("User info loaded", this.userInfo),
      (this.isLoadedFromNetwork = !0),
      this.updateCache().catch(l),
      W.emit("user-loaded", this.userInfo),
      W.emit("raw-user-settings-loaded", t.app_settings);
  }
  async loadFromCache() {
    (this.userInfo = await this.browserStorage.getItem("user-info")),
      this.userInfo &&
        ((this.isLoadedFromCache = !0), W.emit("user-loaded", this.userInfo));
  }
  updateCache() {
    return this.userInfo
      ? this.browserStorage.setItem("user-info", this.userInfo)
      : Promise.resolve();
  }
};
c();
var eo = class extends ot {
  constructor(t) {
    super();
    this.browserStorage = t;
    W.on("raw-user-settings-loaded", (r) => this.setStateFromNetwork(r));
  }
  settings;
  logger = x.createInstance("user_settings");
  static async build(t) {
    let r = new eo(t);
    return await r.loadFromCache(), r;
  }
  getSettings() {
    return g(this.settings, "No user settings"), this.settings;
  }
  getSidebarWidth() {
    return Hi(this.getSettings().sidebarSize);
  }
  updateGlobalUserSettings(t) {
    return this.updateLocalUserSetting(t), this.getGlobalUserSettings();
  }
  updateLocalUserSetting(t) {
    this.settings &&
      ((this.settings = { ...this.settings, ...t }),
      this.updateCache().catch(l),
      W.emit("user-settings-changed", t));
  }
  async loadFromCache() {
    let t = (await this.browserStorage.getItem("app-settings")) ?? {},
      r = fS(t.sidebarSize ?? "small"),
      { sidebarSize: i, isMigrated: s } = await this.extractSidebarSize(r);
    (this.settings = {
      isHiddenSidebarIcons: t.isHiddenSidebarIcons ?? !1,
      globalMute: t.globalMute ?? !1,
      sidebarSize: i,
      inactiveServiceGrayscale: t.inactiveServiceGrayscale ?? !1,
      useAdBlocker: t.useAdBlocker ?? !0,
      adBlockerWhiteList: t.adBlockerWhiteList ?? [],
      isDistractionBlockerEnabled: t.isDistractionBlockerEnabled ?? !1,
      isDistractionBlockerIntroShowed: t.isDistractionBlockerIntroShowed ?? !1,
      distractionBlockerRules: t.distractionBlockerRules ?? null,
      distractionBlockerSchedule: t.distractionBlockerSchedule ?? null,
      discountStartTimestamp: t.discountStartTimestamp ?? 0,
      disableDiscarding: t.disableDiscarding ?? !1,
      noneDiscardableDomains: t.noneDiscardableDomains ?? [
        "mail.google.com",
        "messenger.com",
        "telegram.org",
        "whatsapp.com",
        "wechat.com",
        "vk.com",
        "slack.com",
        "skype.com",
        "instagram.com",
        "icq.com",
        "messages.google.com",
        "intercom.com",
        "superhuman.com",
      ],
      minutesBeforeDiscard: t.minutesBeforeDiscard ?? "10",
      isHiddenWelcomeToSessions: t.isHiddenWelcomeToSessions ?? !1,
      isHiddenWelcomeToCollections: t.isHiddenWelcomeToCollections ?? !1,
      isHiddenWelcomeGlobalSearch: t.isHiddenWelcomeGlobalSearch ?? !1,
      isHiddenWelcomeToDistractionBlocker:
        t.isHiddenWelcomeToDistractionBlocker ?? !1,
      isHiddenLaunchpadTeamsBillingAnimation:
        t.isHiddenLaunchpadTeamsBillingAnimation ?? !1,
      showPhotoBackground: t.showPhotoBackground ?? !0,
      use12Format: t.use12Format ?? !1,
      preferredWallpaperId: t.preferredWallpaperId ?? null,
      rotateWallpapersEnabled: t.rotateWallpapersEnabled ?? !1,
      randomUserAgent: t.randomUserAgent ?? !1,
      showedOnboardingHints: t.showedOnboardingHints ?? [],
      showedHintsV2: t.showedHintsV2 ?? [],
      lastMigrationNum: 1,
      cpuMonitorNotificationsEnabledByUser:
        t.cpuMonitorNotificationsEnabledByUser ?? !0,
      cpuAutoDiscardEnabledByUser: t.cpuAutoDiscardEnabledByUser ?? !0,
      cpuAutoDiscardUserWhitelist: t.cpuAutoDiscardUserWhitelist ?? [],
      ctrlTabOrder: t.ctrlTabOrder ?? "mru",
      isHeadlessModeEnabled: t.isHeadlessModeEnabled ?? !0,
      isConfirmedLocalLawsForVPN: t.isConfirmedLocalLawsForVPN ?? !1,
      useProxy: t.useProxy ?? !1,
      selectedProxySites: t.selectedProxySites ?? [],
      enableCalendarsIntegration: t.enableCalendarsIntegration ?? !1,
      wasShortcutPopupClosed: t.wasShortcutPopupClosed ?? !1,
      wasInvitationBannerClosed: t.wasInvitationBannerClosed ?? !1,
      wasActivated: t.wasActivated ?? !1,
      wasGmailSignatureSet: t.wasGmailSignatureSet ?? !1,
      wasSessionsEnabled: t.wasSessionsEnabled ?? null,
    }),
      s &&
        (await this.updateCache(), this.logger.info("User settings migrated")),
      this.logger.info("User settings loaded from LS", this.settings),
      (this.isLoadedFromCache = !0),
      W.emit("user-settings-loaded", this.settings);
  }
  async extractSidebarSize(t) {
    return (await this.getMigrationCompleteFlag())
      ? { sidebarSize: t, isMigrated: !1 }
      : (await this.setMigrationComplete(),
        {
          sidebarSize: (() => {
            if (t !== "small")
              return t === "medium"
                ? "large"
                : t === "large"
                ? "huge"
                : "medium";
            let s = window.screen.width;
            return s < 1440
              ? "small"
              : s < 1920
              ? "medium"
              : s < 2560
              ? "large"
              : "huge";
          })(),
          isMigrated: !0,
        });
  }
  getMigrationCompleteFlag() {
    return this.browserStorage.getItem("sidebar-size-migrated");
  }
  setMigrationComplete() {
    return this.browserStorage.setItem("sidebar-size-migrated", !0);
  }
  updateCache() {
    return this.settings
      ? this.browserStorage.setItem("app-settings", this.settings)
      : Promise.resolve();
  }
  setStateFromNetwork(t) {
    g(this.settings, "No user settings when setting state from network"),
      (this.isLoadedFromNetwork = !0);
    let r =
      t.sidebarSize === "unset"
        ? this.settings.sidebarSize
        : t.sidebarSize ?? this.settings.sidebarSize;
    (this.settings = {
      ...this.settings,
      useAdBlocker: t.useAdBlocker ?? this.settings.useAdBlocker,
      adBlockerWhiteList:
        t.adBlockerWhiteList ?? this.settings.adBlockerWhiteList,
      isDistractionBlockerEnabled:
        t.isDistractionBlockerEnabled ??
        this.settings.isDistractionBlockerEnabled,
      isDistractionBlockerIntroShowed:
        t.isDistractionBlockerIntroShowed ??
        this.settings.isDistractionBlockerIntroShowed,
      distractionBlockerRules:
        t.distractionBlockerRules ?? this.settings.distractionBlockerRules,
      distractionBlockerSchedule:
        t.distractionBlockerSchedule ??
        this.settings.distractionBlockerSchedule,
      disableDiscarding: t.disableDiscarding ?? this.settings.disableDiscarding,
      noneDiscardableDomains:
        t.noneDiscardableDomains ?? this.settings.noneDiscardableDomains,
      minutesBeforeDiscard:
        t.minutesBeforeDiscard ?? this.settings.minutesBeforeDiscard,
      sidebarSize: r,
      isHiddenWelcomeToSessions:
        t.isHiddenWelcomeToSessions ?? this.settings.isHiddenWelcomeToSessions,
      isHiddenWelcomeToCollections:
        t.isHiddenWelcomeToCollections ??
        this.settings.isHiddenWelcomeToCollections,
      isHiddenWelcomeGlobalSearch:
        t.isHiddenWelcomeGlobalSearch ??
        this.settings.isHiddenWelcomeGlobalSearch,
      isHiddenWelcomeToDistractionBlocker:
        t.isHiddenWelcomeToDistractionBlocker ??
        this.settings.isHiddenWelcomeToDistractionBlocker,
      inactiveServiceGrayscale:
        t.inactiveServiceGrayscale ?? this.settings.inactiveServiceGrayscale,
      showPhotoBackground:
        t.showPhotoBackground ?? this.settings.showPhotoBackground,
      use12Format: t.use12Format ?? this.settings.use12Format,
      preferredWallpaperId:
        t.preferredWallpaperId ?? this.settings.preferredWallpaperId,
      rotateWallpapersEnabled:
        t.rotateWallpapersEnabled ?? this.settings.rotateWallpapersEnabled,
      randomUserAgent: t.randomUserAgent ?? this.settings.randomUserAgent,
      discountStartTimestamp:
        t.discountStartTimestamp ?? this.settings.discountStartTimestamp,
      showedHintsV2: t.showedHintsV2 ?? this.settings.showedHintsV2,
      showedOnboardingHints:
        t.showedOnboardingHints ?? this.settings.showedOnboardingHints,
      cpuMonitorNotificationsEnabledByUser:
        t.cpuMonitorNotificationsEnabledByUser ??
        this.settings.cpuMonitorNotificationsEnabledByUser,
      cpuAutoDiscardEnabledByUser:
        t.cpuAutoDiscardEnabledByUser ??
        this.settings.cpuAutoDiscardEnabledByUser,
      cpuAutoDiscardUserWhitelist:
        t.cpuAutoDiscardUserWhitelist ??
        this.settings.cpuAutoDiscardUserWhitelist,
      ctrlTabOrder: t.ctrlTabOrder ?? this.settings.ctrlTabOrder,
      wasActivated: t.wasActivated ?? this.settings.wasActivated,
      wasGmailSignatureSet:
        t.wasGmailSignatureSet ?? this.settings.wasGmailSignatureSet,
    }),
      this.updateCache().catch(l),
      this.logger.info("User settings loaded from backend", this.settings),
      W.emit("user-settings-loaded", this.settings);
  }
  getGlobalUserSettings() {
    let t = this.getSettings();
    return {
      adBlockerWhiteList: t.adBlockerWhiteList,
      cpuAutoDiscardEnabledByUser: t.cpuAutoDiscardEnabledByUser,
      cpuAutoDiscardUserWhitelist: t.cpuAutoDiscardUserWhitelist,
      cpuMonitorNotificationsEnabledByUser:
        t.cpuMonitorNotificationsEnabledByUser,
      ctrlTabOrder: t.ctrlTabOrder,
      disableDiscarding: t.disableDiscarding,
      discountStartTimestamp: t.discountStartTimestamp,
      distractionBlockerRules: t.distractionBlockerRules,
      distractionBlockerSchedule: t.distractionBlockerSchedule,
      enableCalendarsIntegration: t.enableCalendarsIntegration,
      inactiveServiceGrayscale: t.inactiveServiceGrayscale,
      isDistractionBlockerEnabled: t.isDistractionBlockerEnabled,
      isDistractionBlockerIntroShowed: t.isDistractionBlockerIntroShowed,
      isHeadlessModeEnabled: t.isHeadlessModeEnabled,
      isHiddenLaunchpadTeamsBillingAnimation:
        t.isHiddenLaunchpadTeamsBillingAnimation,
      isHiddenWelcomeGlobalSearch: t.isHiddenWelcomeGlobalSearch,
      isHiddenWelcomeToCollections: t.isHiddenWelcomeToCollections,
      isHiddenWelcomeToDistractionBlocker:
        t.isHiddenWelcomeToDistractionBlocker,
      isHiddenWelcomeToSessions: t.isHiddenWelcomeToSessions,
      minutesBeforeDiscard: t.minutesBeforeDiscard,
      noneDiscardableDomains: t.noneDiscardableDomains,
      preferredWallpaperId: t.preferredWallpaperId,
      randomUserAgent: t.randomUserAgent,
      rotateWallpapersEnabled: t.rotateWallpapersEnabled,
      showedHintsV2: t.showedHintsV2,
      showedOnboardingHints: t.showedOnboardingHints,
      showPhotoBackground: t.showPhotoBackground,
      sidebarSize: t.sidebarSize,
      use12Format: t.use12Format,
      useAdBlocker: t.useAdBlocker,
      wasActivated: t.wasActivated,
      wasShortcutPopupClosed: t.wasShortcutPopupClosed,
      wasInvitationBannerClosed: t.wasInvitationBannerClosed,
      wasGmailSignatureSet: t.wasGmailSignatureSet,
    };
  }
};
c();
var to = class extends Wr {
  constructor(t) {
    super();
    this.browserStorage = t;
  }
  workspacesById = new Map();
  activeWorkspaceIds = new Set();
  workspaceIdByWindowId = new Map();
  static async build(t) {
    let r = new to(t);
    return await r.loadFromCache(), r;
  }
  getWorkspacesArray() {
    return [...this.workspacesById.values()];
  }
  getWorkspacesById() {
    return this.workspacesById;
  }
  getWorkspaceById(t) {
    return this.workspacesById.get(t);
  }
  getDefaultWorkspace() {
    return this.getWorkspaceByPartition(zr);
  }
  getDefaultWorkspaceId() {
    return this.getWorkspaceIdByPartition(zr);
  }
  getWorkspaceByPartition(t) {
    return this.getWorkspacesArray().find((r) => r.partitionDomain === t);
  }
  getWorkspaceIdByPartition(t) {
    return this.getWorkspaceByPartition(t)?.id;
  }
  getPinnedAppIdByIndex(t, r) {
    return this.getWorkspaceById(t)?.pinnedOrderAppIds[r];
  }
  getPinnedIndexByAppId(t, r) {
    return this.getWorkspaceById(t)?.pinnedOrderAppIds.indexOf(r) ?? -1;
  }
  getPinnedCountById(t) {
    return this.getWorkspaceById(t)?.pinnedOrderAppIds.length ?? 0;
  }
  getTotalAppsById(t) {
    return this.getWorkspaceById(t)?.orderAppIds.length ?? 0;
  }
  getHasAppPinned(t, r) {
    return this.getWorkspaceById(t)?.pinnedOrderAppIds.includes(r) ?? !1;
  }
  getWorkspaceIdForWindow(t) {
    return this.workspaceIdByWindowId.get(t);
  }
  getWorkspaceForWindow(t) {
    let r = this.getWorkspaceIdForWindow(t);
    if (r) return this.getWorkspaceById(r);
  }
  getHasWorkspaceActiveWindows(t) {
    return this.getActiveWorkspacesIds().filter((i) => i === t).length > 0;
  }
  getActiveWorkspacesIds() {
    return [...this.workspaceIdByWindowId.values()];
  }
  getIsWorkspaceActive(t) {
    return this.activeWorkspaceIds.has(t);
  }
  getActiveWindowsForWorkspace(t) {
    let r = new Array();
    return (
      this.workspaceIdByWindowId.forEach((i, s) => {
        t === i && r.push(s);
      }),
      r
    );
  }
  getWindowForFocusOnWorkspace(t) {
    if (!this.getIsWorkspaceActive(t)) return;
    let [i] = this.getActiveWindowsForWorkspace(t);
    if (i) return i;
  }
  addWorkspace(t) {
    this.workspacesById.set(t.id, t),
      re.emit("workspaces-changed", t, t.id),
      this.updateCache().catch(l);
  }
  deleteWorkspaceById(t) {
    this.workspacesById.delete(t),
      this.activeWorkspaceIds.delete(t),
      this.workspaceIdByWindowId.forEach((r, i) => {
        t === r && this.workspaceIdByWindowId.delete(i);
      }),
      this.updateCache().catch(l),
      re.emit("workspaces-changed", {}, t);
  }
  updateWorkspaceById(t, r) {
    let i = this.workspacesById.get(t);
    if (!i) return;
    let s = { ...i, ...r };
    return (
      this.workspacesById.set(i.id, s),
      re.emit("workspaces-changed", r, s.id),
      this.updateCache().catch(l),
      s
    );
  }
  activateWorkspace(t) {
    this.activeWorkspaceIds.add(t), re.emit("workspaces-changed-active");
  }
  deactivateWorkspace(t) {
    this.activeWorkspaceIds.delete(t), re.emit("workspaces-changed-active");
  }
  setWorkspacesById(t) {
    (this.workspacesById = t), this.updateCache().catch(l);
  }
  setWorkspaceIdForWindow(t, r) {
    this.workspaceIdByWindowId.set(t, r);
  }
  deleteWorkspaceIdForWindow(t) {
    this.workspaceIdByWindowId.delete(t);
  }
  async loadFromCache() {
    let t = await this.browserStorage.getItem("workspaces");
    t?.length &&
      ((this.isLoadedFromCache = !0),
      (this.workspacesById = t.reduce(
        (r, i) => (r.set(i.id, i), r),
        new Map()
      )),
      re.emit("workspaces-loaded", t));
  }
  async updateCache() {
    let t = [...this.workspacesById.values()];
    await this.browserStorage.setItem("workspaces", t);
  }
};
c();
var ro = class extends ot {
  constructor(t) {
    super();
    this.browserStorage = t;
  }
  featureFlags;
  emitter = new A();
  static async build(t) {
    let r = new ro(t);
    return await r.loadFromCache(), r;
  }
  getFeatureFlags() {
    return this.featureFlags;
  }
  getFeatureFlag(t) {
    return this.featureFlags[t];
  }
  onFeatureFlagsLoaded(t) {
    return this.emitter.on("feature-flags-loaded", (...r) => ee(t(...r)));
  }
  setStateFromNetwork(t) {
    (this.featureFlags = this.parseFeatureFlags(t)),
      (this.isLoadedFromNetwork = !0),
      this.updateCache().catch(l),
      this.emitter.emit("feature-flags-loaded", this.featureFlags);
  }
  async loadFromCache() {
    let t = await this.browserStorage.getItem("features");
    (this.featureFlags = t ?? this.parseFeatureFlags({})),
      (this.isLoadedFromCache = !0),
      this.emitter.emit("feature-flags-loaded", this.featureFlags, !0);
  }
  updateCache() {
    return this.browserStorage.setItem("features", this.featureFlags);
  }
  parseFeatureFlags(t) {
    return {
      actualMinutesUsedReport: this.parseFeatureParams(
        t.actualMinutesUsedReport,
        R.actualMinutesUsedReport
      ),
      actualMinutesUsedReportEnabled:
        t.actualMinutesUsedReport?.works ?? R.actualMinutesUsedReport.works,
      adblockToolbarButton:
        t.adblockToolbarButton?.works ?? R.adblockToolbarButton?.works,
      adblockWhitelist: this.parseFeatureParams(
        t.nativeAdBlockAllowList,
        R.nativeAdBlockAllowList
      ),
      afterTrialDiscountOffer: this.parseFeatureParams(
        t.afterTrialDiscountOffer,
        R.afterTrialDiscountOffer
      ),
      afterTrialDiscountOfferEnabled:
        t.afterTrialDiscountOffer?.works ?? R.afterTrialDiscountOffer.works,
      autoSyncFocusMode: this.parseFeatureParams(
        t.autoSyncFocusMode,
        R.autoSyncFocusMode
      ),
      b2b: this.parseFeatureParams(t.b2b, R.b2b),
      b2bEnabled: t.b2b?.works ?? R.b2b.works,
      beforeProductHuntPopup: this.parseFeatureParams(
        t.beforeProductHuntPopup,
        R.beforeProductHuntPopup
      ),
      beforeProductHuntPopupEnabled:
        t.beforeProductHuntPopup?.works ?? R.beforeProductHuntPopup.works,
      calendarsIntegrationEnabled:
        t.calendarsIntegrationV2?.works ?? R.calendarsIntegrationV2.works,
      cancelDiscountOfferEnabled:
        t.cancelDiscountOffer?.works ?? R.cancelDiscountOffer.works,
      collectionsEnabled: t.collections?.works ?? R.collections?.works,
      cpuMonitor: this.parseFeatureParams(t.cpuMonitor, R.cpuMonitor),
      cpuMonitorEnabled: t.cpuMonitor?.works ?? R.cpuMonitor.works,
      crashSender: this.parseFeatureParams(t.crashSender, R.crashSender),
      defaultBrowserNotificationV3: this.parseFeatureParams(
        t.defaultBrowserNotificationV3,
        R.defaultBrowserNotificationV3
      ),
      defaultBrowserNotificationV3Enabled:
        t.defaultBrowserNotificationV3?.works ??
        R.defaultBrowserNotificationV3.works,
      distractionBlocker: this.parseFeatureParams(
        t.distractionBlocker,
        R.distractionBlocker
      ),
      enableExploreSidekickV2:
        t.exploreSidekickV2?.works ?? R.exploreSidekickV2.works,
      enableSearchIconInToolbar:
        t.searchIconInToolbar?.works ?? R.searchIconInToolbar.works,
      exploreSidekickV2: this.parseFeatureParams(
        t.exploreSidekickV2,
        R.exploreSidekickV2
      ),
      extensionKicker: this.parseFeatureParams(
        t.extensionKicker,
        R.extensionKicker
      ),
      extensionWatchdog:
        t.extensionWatchdog?.works ?? R.extensionWatchdog.works,
      fcmEnabled: t.fcm?.works ?? R.fcm.works,
      featuresUpdater: this.parseFeatureParams(
        t.featuresUpdater,
        R.featuresUpdater
      ),
      focusModeHint: this.parseFeatureParams(t.focusModeHint, R.focusModeHint),
      focusModeShortcutEnabled:
        t.focusModeShortcut?.works ?? R.focusModeShortcut.works,
      forceCollectionsEnableForTeams:
        t.forceCollectionsEnableForTeams?.works ??
        R.forceCollectionsEnableForTeams.works,
      forcedUserAgents: t?.forcedUserAgents?.params ?? null,
      globalAuthDomains: this.parseFeatureParams(
        t.globalAuthDomains,
        R.globalAuthDomains
      ),
      gmailSignature: this.parseFeatureParams(
        t.gmailSignature,
        R.gmailSignature
      ),
      gmailSignatureEnabled: t.gmailSignature?.works ?? R.gmailSignature.works,
      helpLinks: this.parseFeatureParams(t.helpLinks, R.helpLinks),
      hintsV2: this.parseFeatureParams(t.hintsV2, R.hintsV2),
      hintsV2Enabled: t.hintsV2?.works ?? R.hintsV2.works,
      hoverAppMenuSidebar: this.parseFeatureParams(
        t.hoverAppMenuSidebar,
        R.hoverAppMenuSidebar
      ),
      hoverSessionSwitcherSidebar: this.parseFeatureParams(
        t.hoverSessionSwitcherSidebar,
        R.hoverSessionSwitcherSidebar
      ),
      intercom: this.parseFeatureParams(t.intercom, R.intercom),
      intercomEnabled: t?.intercom?.works ?? R.intercom.works,
      isCollectionModalEnabled:
        t.showCollectionModal?.works ?? R.showCollectionModal.works,
      isDistractionBlockerEnabled:
        t.distractionBlocker?.works ?? R.distractionBlocker.works,
      isHoverAppMenuSidebarEnabled:
        t?.hoverAppMenuSidebar?.works ?? R.hoverAppMenuSidebar.works,
      isHoverSessionSwitcherSidebarEnabled:
        t?.hoverSessionSwitcherSidebar?.works ??
        R.hoverSessionSwitcherSidebar.works,
      isMuteNotificationsPopupEnabled:
        t.muteNotificationsPopup?.works ?? R.muteNotificationsPopup.works,
      isProgressiveDiscountOfferEnabled:
        t.progressiveDiscountOffer?.works ?? R.progressiveDiscountOffer.works,
      isVerticalModalEnabled:
        t.showVerticalTabsModal?.works ?? R.showVerticalTabsModal.works,
      muteNotificationsPopup: this.parseFeatureParams(
        t.muteNotificationsPopup,
        R.muteNotificationsPopup
      ),
      newBilling: this.parseFeatureParams(t.newBilling, R.newBilling),
      newBillingEnabled: t.newBilling?.works ?? R.newBilling.works,
      overrideShortcuts: this.parseFeatureParams(
        t.overrideShortcuts,
        R.overrideShortcuts
      ),
      pmfSurvey: this.parseFeatureParams(t.pmfSurvey2, R.pmfSurvey2),
      pmfSurveyEnabled: t.pmfSurvey2?.works ?? R.pmfSurvey2.works,
      productHuntLivePopup: this.parseFeatureParams(
        t.productHuntPopupLive,
        R.productHuntPopupLive
      ),
      productHuntPopupLiveEnabled:
        t.productHuntPopupLive?.works ?? R.productHuntPopupLive?.works,
      progressiveDiscountOffer: this.parseFeatureParams(
        t.progressiveDiscountOffer,
        R.progressiveDiscountOffer
      ),
      proxy: this.parseFeatureParams(t.proxy, R.proxy),
      proxyEnabled: t.proxy?.works ?? R.proxy.works,
      randomUserAgent: this.parseFeatureParams(
        t.randomUserAgent,
        R.randomUserAgent
      ),
      search: this.parseFeatureParams(t.search, R.search),
      sentrySampling: this.parseFeatureParams(
        t.sentrySampling,
        R.sentrySampling
      ),
      sessionsForOldUsers: this.parseFeatureParams(
        t.sessionsForOldUsers,
        R.sessionsForOldUsers
      ),
      sessionsForOldUsersEnabled:
        t.sessionsForOldUsers?.works ?? R.sessionsForOldUsers.works,
      sharingApps: t.sharingApps?.works ?? R.sharingApps.works,
      shortcutsAnalytics: this.parseFeatureParams(
        t.shortcutsAnalytics,
        R.shortcutsAnalytics
      ),
      shortcutsPopup: this.parseFeatureParams(
        t.shortcutsPopup,
        R.shortcutsPopup
      ),
      shortcutsPopupEnabled: t.shortcutsPopup?.works ?? R.shortcutsPopup.works,
      showCollectionModal: this.parseFeatureParams(
        t.showCollectionModal,
        R.showCollectionModal
      ),
      showHintsConditions: this.parseFeatureParams(
        t.showHintsConditions,
        R.showHintsConditions
      ),
      showHintsConditionsIsEnabled:
        t.showHintsConditions?.works ?? R.showHintsConditions.works,
      showPaidTrialModal: this.parseFeatureParams(
        t.showPaidTrialModal,
        R.showPaidTrialModal
      ),
      showPaidTrialModalIsEnabled:
        t.showPaidTrialModal?.works ?? R.showPaidTrialModal.works,
      signUpDialog: this.parseFeatureParams(t.signUpDialog, R.signUpDialog),
      signUpDialogEnabled: t.signUpDialog?.works ?? R.signUpDialog.works,
      splitViewAppsEnabled: t.splitViewApps?.works ?? R.splitViewApps?.works,
      subscriptionPriceExperimentEnabled:
        t.subscriptionPriceExperiment?.works ??
        R.subscriptionPriceExperiment.works,
      sync: t.syncV2?.works ?? R.syncV2.works,
      syncFocusMode: this.parseFeatureParams(t.syncFocusMode, R.syncFocusMode),
      syncSessions: this.parseFeatureParams(t.syncSessions, R.syncSessions),
      syncSessionsEnabled: t.syncSessions?.works ?? R.syncSessions.works,
      tabsDiscarder2: this.parseFeatureParams(
        t.tabsDiscarder2,
        R.tabsDiscarder2
      ),
      tasksEnabled: t.tasks?.works ?? R.tasks?.works,
      usageAccumulator: this.parseFeatureParams(
        t.usageAccumulator,
        R.usageAccumulator
      ),
      usageTracker: this.parseFeatureParams(t.usageTracker2, R.usageTracker2),
      verticalTabs: this.parseFeatureParams(t.verticalTabs, R.verticalTabs),
      verticalTabsEnabled: t.verticalTabs?.works ?? R.verticalTabs.works,
      walkthrough: t.walkthroughV2?.works ?? R.walkthroughV2.works,
      yearlyOfferPopup: this.parseFeatureParams(
        t.yearlyOfferPopup,
        R.yearlyOfferPopup
      ),
      yearlyOfferPopupEnabled:
        t.yearlyOfferPopup?.works ?? R.yearlyOfferPopup.works,
    };
  }
  parseFeatureParams(t, r) {
    let i = Mu(r.params);
    return t ? { ...i, ...Mu(t.params) } : i;
  }
};
var xS = (o) => {
  let e = ro.build(o),
    t = Qi.build(o),
    r = to.build(o),
    i = eo.build(o),
    s = Zi.build(o),
    a = Ji.build(o),
    n = Xi.build(o),
    p = Yi.build(o),
    d = zi.build(o),
    u = new lp();
  return Promise.all([e, t, r, i, s, a, n, d, u, p]);
};
c();
var AE = "sidekick.adblock-rust",
  PE = "sidekick.adblock-profile-whitelist",
  WS = "sidekick.adblock-page-action-icon",
  up = class {
    constructor(e, t, r, i, s, a, n) {
      this.browserService = e;
      this.userSettingsRepository = t;
      this.featureFlagsRepository = r;
      this.browserEventsService = i;
      this.popupService = s;
      this.userApi = a;
      this.billingRepository = n;
      (this.stats = { block_count: 0, percent: 0 }),
        this.loadAdblockStats().catch(l),
        setInterval(() => {
          this.loadAdblockStats().catch(l);
        }, ye(1)),
        this.loadAdblockSettings(),
        W.on("user-settings-changed", this.loadAdblockSettings.bind(this)),
        this.featureFlagsRepository.onFeatureFlagsLoaded(
          this.loadAdblockSettings.bind(this)
        ),
        this.browserEventsService.subscribeToAdBlockPageActionIconClicked(
          (...p) => this.handleAdblockIconClicked(...p)
        ),
        se.on("billing-plan-loaded", this.loadAdblockSettings.bind(this));
    }
    stats;
    emitter = new A();
    logger = x.createInstance("adblocker");
    onStatsChanged(e) {
      return this.emitter.on("stats-changed", e);
    }
    getStats() {
      return this.stats;
    }
    async addAdblockerDomain(e) {
      this.userApi.addAdBlockerDomain(Vt(e) ?? e),
        await this.reloadPagesByDomain(e);
    }
    async removeAdblockerDomain(e) {
      this.userApi.removeAdBlockerDomain(Vt(e) ?? e),
        await this.reloadPagesByDomain(e);
    }
    handleAdblockIconClicked(e, t, r, i, s) {
      let a = this.getFeaturesWhiteList(),
        n = Boolean(a.find((p) => new RegExp(p).test(t)));
      this.popupService.showAdblockPopupIfIsNotVisible(
        {
          enabled: r,
          requestsCount: i,
          requestsPercent: s,
          domain: t,
          domainInHiddenWhiteList: n,
        },
        e
      );
    }
    async reloadPagesByDomain(e) {
      let t = await this.browserService.getLastFocusedWindowId();
      if (!t) return;
      let r = zs(Ht(e));
      if (!r) return;
      let i = await this.browserService.getAllTabs({ url: r, windowId: t });
      this.logger.info("Reloading tabs", i),
        i.forEach((s) => {
          s.id && this.browserService.reloadTab(s.id).catch(l);
        });
    }
    getFeaturesWhiteList() {
      return (
        this.featureFlagsRepository.getFeatureFlags().adblockWhitelist
          .domains ?? []
      );
    }
    getWhiteList() {
      let { adBlockerWhiteList: e } = this.userSettingsRepository.getSettings(),
        t = this.getFeaturesWhiteList();
      return [...new Set([...e, ...t])];
    }
    loadAdblockSettings() {
      let e = this.billingRepository.canUseAdblock();
      if (!e) {
        this.browserService.setPref(WS, e).catch(l),
          this.changeAdblockEnabled(!1).catch(l);
        return;
      }
      let { useAdBlocker: t } = this.userSettingsRepository.getSettings(),
        r = this.getWhiteList();
      this.changeAdblockEnabled(t).catch(l),
        this.browserService.setPref(PE, r).catch(l);
      let i = this.featureFlagsRepository.getFeatureFlag(
        "adblockToolbarButton"
      );
      this.browserService.setPref(WS, i).catch(l);
    }
    changeAdblockEnabled(e) {
      return this.browserService.setPref(AE, e);
    }
    async loadAdblockStats() {
      let e = await this.browserService.getAdblockStats();
      (this.stats.block_count !== e.block_count ||
        this.stats.percent !== e.percent) &&
        ((this.stats = e),
        this.logger.info("AdBlocker stats loaded", this.stats),
        this.emitter.emit("stats-changed"));
    }
  };
c();
c();
var DS = (o, e, t, r) =>
    typeof o != "object" || o === null
      ? (g(
          !(t in r),
          `Object has multiple leaves for path "${t}": ${JSON.stringify(
            r[t]
          )} and ${JSON.stringify(o)}.`
        ),
        { ...r, [t]: o })
      : Object.entries(o).reduce(
          (i, [s, a]) => DS(a, e, t ? `${t}${e}${s}` : s, i),
          r
        ),
  US = (o, { separator: e = "." } = {}) => DS(o, e, "", {});
c();
var RE = 500,
  OS = 2e4,
  mp = class {
    events = new Set();
    userId = null;
    endpoint;
    anonymousId;
    internalFetch;
    encoder = new TextEncoder();
    constructor({ endpoint: e, anonymousId: t, fetch: r }) {
      (this.endpoint = e), (this.anonymousId = t), (this.internalFetch = r);
    }
    identify(e) {
      let t = this.userId;
      (this.userId = e),
        this.userId !== t &&
          this.userId &&
          this.events.add(
            this.createIdentifyData(this.userId, t ?? this.anonymousId)
          );
    }
    track(e) {
      this.events.add(e);
    }
    async flush() {
      let e = this.getRecordsForSend();
      if (!e.length) return;
      let t = Boolean(this.events.size);
      await this.internalFetch(`${this.endpoint}/batch`, {
        method: "POST",
        body: JSON.stringify({ batch: e }),
        headers: { "Content-Type": "application/json" },
      }),
        t && (await this.flush());
    }
    getRecordsForSend() {
      let e = Array.from(this.events);
      this.events.clear();
      let t = [];
      return (
        e.forEach((r) => {
          this.canPushEvent(t, r) ? t.push(r) : this.events.add(r);
        }),
        t
      );
    }
    canPushEvent(e, t) {
      if (e.length >= RE) return !1;
      let r = [...e, t],
        i = this.encoder.encode(JSON.stringify({ batch: r })).length;
      if (i >= OS) {
        if (r.length !== 1) return !1;
        let s = new L("Big size of event payload", {
          tags: { limit: `${OS}` },
          extra: { bytes: i },
        });
        l(s);
      }
      return !0;
    }
    getTimestampStr(e = Date.now()) {
      return new Date(e).toISOString();
    }
    createEventData(e, t) {
      return {
        event: e,
        userId: this.userId,
        anonymousId: this.anonymousId,
        timestamp: this.getTimestampStr(),
        properties: t,
      };
    }
    createIdentifyData(e, t) {
      let r = { $identified_id: e, $anon_id: t };
      return this.createEventData("$identify", r);
    }
  };
var hp = class {
  constructor(e, t, r, i, s) {
    this.authService = e;
    this.sentry = t;
    this.browserStorage = r;
    this.systemInfo = i;
    this.options = s;
    let { firehose: a, fetch: n } = this.options;
    (this.firehose = a?.endpoint
      ? new mp({ ...a, fetch: n, anonymousId: i.anonymousId })
      : null),
      (this.commonProperties = {
        browser: {
          version: i.browserVersion,
          "version-numeric": this.castVersionToNumeric(i.browserVersion),
        },
        extension: {
          version: i.extensionVersion,
          "version-numeric": this.castVersionToNumeric(i.extensionVersion),
        },
        storage: {
          version: s.storageReport.version,
          "size-in-bytes": s.storageReport.sizeInBytes,
          "size-before-migration-in-bytes":
            s.storageReport.sizeBeforeMigrationInBytes,
        },
        os: { ...i.os, locale: i.locale },
        device: {
          id: i.deviceId.value,
          "is-mac-m1": i.isMacM1,
          "cpu-architecture": i.cpuArchitecture,
          "hardware-concurrency": navigator.hardwareConcurrency,
          memory: navigator.deviceMemory,
        },
        "is-temp-account": null,
        "is-sidekick-team": i.isSidekickTeam || null,
        "billing-plan": null,
      }),
      this.firehose?.identify(this.authService.getUserId()),
      W.on("user-loaded", (p) => {
        this.commonProperties = {
          ...this.commonProperties,
          "is-temp-account": p.hasTemporaryEmail,
        };
      }),
      se.on("billing-plan-loaded", (p) => {
        this.commonProperties = {
          ...this.commonProperties,
          "billing-plan": { id: p.id, name: p.name },
        };
      }),
      i.isFirstStart &&
        this.sendAnalyticsEvent("system.extension-first-start", void 0),
      this.logger.info(
        "Analytics loaded",
        this.systemInfo.anonymousId,
        this.commonProperties
      );
  }
  settings = { enableBatching: !0 };
  extra = {};
  firehose;
  commonProperties;
  eventsDenyList = new Set();
  interval = setInterval(() => {
    this.flush().catch(l);
  }, 6e4);
  extensionStartTimeStamp = Date.now();
  logger = x.createInstance("analytics");
  dispose() {
    clearInterval(this.interval), this.flush().catch(l);
  }
  sendAnalyticsEvent(e, t) {
    this.sendAnalyticsEventWithOptions(e, t).catch(l);
  }
  async sendAnalyticsEventWithOptions(e, t, r = {}) {
    if (this.eventsDenyList.has(e)) return !1;
    let i = Date.now(),
      s = await this.canPrintToConsole(),
      a = await this.canDisableBatching();
    if (
      (s && this.printToConsole(e, t),
      this.printToSentry(e, t),
      this.trackEvent(e, t, i),
      a || !this.settings.enableBatching || r.disableBatching)
    )
      try {
        await this.flush();
      } catch (n) {
        return l(n), !1;
      }
    return !0;
  }
  setExtra(e) {
    this.extra = dr({ ...this.extra, ...e });
  }
  setDenyList(e) {
    this.eventsDenyList.clear(),
      e !== null && e.forEach((t) => this.eventsDenyList.add(t));
  }
  async flush() {
    return this.firehose?.flush()?.catch(l);
  }
  trackEvent(e, t, r) {
    let i = ea(r, this.extensionStartTimeStamp, { roundingMethod: "ceil" }),
      s = {
        event: e,
        anonymousId: this.systemInfo.anonymousId,
        extra: this.systemInfo.extraIds,
        userId: this.authService.getUserId(),
        timestamp: new Date(r).toISOString(),
        properties: dr({
          ...US(this.commonProperties),
          ...(t ?? void 0),
          ...this.extra,
          "extension.started-minutes-ago": i,
        }),
      };
    this.firehose?.track(s);
  }
  async canPrintToConsole() {
    return Boolean(
      await this.browserStorage.getGlobalItem("PRINT_ANALYTICS_TO_CONSOLE")
    );
  }
  async canDisableBatching() {
    return Boolean(await this.browserStorage.getGlobalItem("DISABLE_BATCHING"));
  }
  printToConsole(e, t) {
    let r = "font-weight: bold",
      i = "color: cornflowerblue";
    console.log(`%cEvent: %c${e}`, r, i),
      console.log("%cProps:", r, t),
      console.log("%cCommon Properties:", r, this.commonProperties),
      console.log("%cExtra:", r, this.extra),
      console.log("%cUser id:", r, this.authService.getUserId()),
      console.log(`

`);
  }
  printToSentry(e, t) {
    this.sentry.addBreadcrumb({ message: e, data: t ?? void 0, level: "info" });
  }
  castVersionToNumeric(e) {
    return Number(
      e
        .split(".")
        .map((t) => (t.length === 1 ? `0${t}` : t))
        .join("")
    );
  }
};
c();
var jS = ye(5),
  yp = class {
    constructor(e, t, r, i) {
      this.browserEventsService = e;
      this.analyticsTracker = t;
      this.featureFlagsRepository = r;
      this.browserService = i;
      this.init().catch(l),
        this.browserEventsService.subscribeToIdleStateChanged((s) => {
          (s !== "idle" && s !== "locked") || this.aggregateCurrentUsage(s);
        }),
        this.browserEventsService.subscribeToTabActivated(({ tabId: s }) => {
          (this.activeTabId = s),
            this.tryUpdateCurrentTrackingTargetWithTimeout(s);
        }),
        this.browserEventsService.subscribeToTabUpdated((s, a) => {
          s !== this.activeTabId ||
            a.url === void 0 ||
            this.tryUpdateCurrentTrackingTargetWithTimeout(s);
        });
    }
    currentTargetTimer = null;
    currentTrackingTarget = null;
    activeTabId = null;
    lastLivedAt = Date.now();
    browserUsageEventAggregate = null;
    lastTargetUpdateIdleState = "active";
    initedAt = Date.now();
    async init() {
      let e = await this.browserService.getActiveTab();
      e?.id &&
        ((this.activeTabId = e.id),
        (this.currentTrackingTarget = this.getTrackingTarget(e, Date.now()))),
        this.checkIfAlive(),
        this.scheduleNextFlushBrowsingUsage();
    }
    checkIfAlive() {
      this.shouldIgnoreAfterHibernating() &&
        (this.currentTrackingTarget = null),
        (this.lastLivedAt = Date.now()),
        setTimeout(() => this.checkIfAlive(), jS);
    }
    aggregateCurrentUsage(e = "active") {
      if (!this.currentTrackingTarget) return;
      let t = Date.now(),
        { startedAt: r } = this.currentTrackingTarget,
        i = t - r;
      if (((this.currentTrackingTarget = null), i < 0)) {
        l(
          new L("Browser usage should be positive", {
            extra: {
              durationMs: i,
              now: t,
              currentTrackingTargetStartedAt: r,
              lastLivedAt: this.lastLivedAt,
              idleState: e,
              lastTargetUpdateIdleState: this.lastTargetUpdateIdleState,
            },
          })
        );
        return;
      }
      this.shouldIgnoreAfterHibernating() ||
        (this.browserUsageEventAggregate = {
          durationMs: (this.browserUsageEventAggregate?.durationMs ?? 0) + i,
          finishedAt: t,
          "service.name": "Browsing",
        });
    }
    scheduleNextFlushBrowsingUsage() {
      setTimeout(
        () => this.flushBrowsingUsage(),
        ce(
          (() => {
            let t =
                this.featureFlagsRepository.getFeatureFlag(
                  "usageAccumulator"
                ).browsingUsage,
              r = Date.now() - this.initedAt;
            return (
              t.find((s, a) => {
                if (t.length - 1 === a) return !0;
                if (!s.durationSeconds) return !1;
                let p = ce(s.durationSeconds);
                return r <= p ? !0 : ((r -= p), !1);
              })?.sendIntervalSeconds ?? 1800
            );
          })()
        )
      );
    }
    flushBrowsingUsage() {
      this.scheduleNextFlushBrowsingUsage(),
        this.browserUsageEventAggregate &&
          (this.analyticsTracker.sendAnalyticsEvent(
            "ping-browsing-usage",
            this.browserUsageEventAggregate
          ),
          (this.browserUsageEventAggregate = null));
    }
    tryUpdateCurrentTrackingTargetWithTimeout(e) {
      let t = Date.now();
      this.currentTargetTimer && clearTimeout(this.currentTargetTimer);
      let { activateTimeoutMs: r } =
        this.featureFlagsRepository.getFeatureFlag("usageTracker");
      this.currentTargetTimer = setTimeout(() => {
        this.tryUpdateCurrentTrackingTarget(e, t).catch(l);
      }, r);
    }
    async tryUpdateCurrentTrackingTarget(e, t) {
      let r = await this.browserService.getTabById(e),
        i = r ? this.getTrackingTarget(r, t) : null;
      this.targetsAreEqual(i) ||
        (this.aggregateCurrentUsage(),
        (this.currentTrackingTarget = i),
        (this.lastTargetUpdateIdleState =
          await this.browserService.getIdleState()));
    }
    getTrackingTarget(e, t) {
      let { id: r, url: i, partitionName: s } = e,
        a = i && At(i);
      return !r || s === void 0 || !a
        ? null
        : { tabId: r, startedAt: t, hostname: a, partitionId: s };
    }
    targetsAreEqual(e) {
      return this.currentTrackingTarget !== null && e !== null
        ? this.currentTrackingTarget.hostname === e.hostname &&
            this.currentTrackingTarget.partitionId === e.partitionId
        : this.currentTrackingTarget === null && e === null;
    }
    shouldIgnoreAfterHibernating() {
      return Date.now() - this.lastLivedAt > jS * 2;
    }
  };
c();
var EE = "default-browser-check",
  bp = class {
    constructor(e, t, r, i, s, a) {
      this.browserService = e;
      this.backend = t;
      this.userRepository = r;
      this.analytics = i;
      this.scheduler = s;
      this.defaultBrowserService = a;
      this.init().catch(l);
    }
    isDefaultBrowserLastTime;
    async init() {
      let { sidekickIsDefault: e } =
        await this.userRepository.getEnsuredUserInfo();
      (this.isDefaultBrowserLastTime = e),
        await this.checkDefaultBrowser(),
        this.scheduler
          .task(EE, () => this.checkDefaultBrowser())
          .everySixHours();
    }
    async checkDefaultBrowser() {
      let e = await this.browserService.isDefaultBrowser();
      this.analytics.setExtra({ "browser.is-default": e }),
        this.isDefaultBrowserLastTime !== e &&
          (e === !1 &&
            this.isDefaultBrowserLastTime === !0 &&
            (await this.defaultBrowserService.showBrowserMakeDefaultPopupExternal()),
          (this.isDefaultBrowserLastTime = e),
          await this.backend.extension.updateUserDefaultBrowser(e));
    }
  };
c();
var gp = class {
  constructor(e, t, r) {
    this.savedMemoryStatistic = e;
    this.analyticsTracker = r;
    t.task("memory-report", () => this.update()).hourly(),
      e.onSavedMemoryUpdated(() => this.update()),
      this.update();
  }
  maxSavedMemoryByHours = new Map();
  getMaxSavedMemoryInLast24H() {
    return Math.max(0, ...this.maxSavedMemoryByHours.values());
  }
  update() {
    let e = Math.floor(Pi(Date.now())),
      t = this.savedMemoryStatistic.getSavedMemory(),
      r = this.maxSavedMemoryByHours.get(e) ?? 0;
    t > r && this.maxSavedMemoryByHours.set(e, t),
      this.pruneOldValues(e),
      this.setExtra();
  }
  setExtra() {
    this.analyticsTracker.setExtra({
      "system.max-saved-memory-in-last-24h": this.getMaxSavedMemoryInLast24H(),
    });
  }
  pruneOldValues(e) {
    Array.from(this.maxSavedMemoryByHours.keys())
      .filter((t) => t <= e - 24)
      .forEach((t) => this.maxSavedMemoryByHours.delete(t));
  }
};
c();
var vp = class {
  constructor(e, t, r, i) {
    this.tabsDiscarderService = e;
    this.mergedProcessesStatistic = t;
    this.startupTabsDiscarderService = r;
    this.tabsConsumedMemoryStatistic = i;
  }
  getSavedMemory() {
    let e = 0;
    return (
      this.startupTabsDiscarderService
        .getDiscardedTabsDomains()
        .forEach((r) => {
          let i = this.tabsConsumedMemoryStatistic.getAvgPrivateMemory(r) || 0;
          e += i;
        }),
      this.tabsDiscarderService.getStats().savedTabsMemory +
        this.mergedProcessesStatistic.savedMemory +
        e
    );
  }
  onSavedMemoryUpdated(e) {
    let t = [
      this.tabsDiscarderService.onStatsUpdated(e),
      this.mergedProcessesStatistic.subscribeToMergedMemory(e),
      this.tabsConsumedMemoryStatistic.subscribeToStatisticLoaded(e),
    ];
    return F(t);
  }
};
c();
var BE = 30,
  kh = "user-activation-report",
  fp = class {
    constructor(e, t, r, i, s) {
      this.browserService = e;
      this.browserEventsService = t;
      this.scheduler = r;
      this.analytics = i;
      this.browserStorage = s;
      this.init().catch(l);
    }
    counter = null;
    unsubscribe = null;
    isDuringProcessTask = !1;
    dispose() {
      this.cancelTask(), this.unsubscribe?.();
    }
    async init() {
      if ((await this.loadCounter(), this.isCounterFinished()))
        return this.dispose();
      let e = () => ee(this.checkTimer()),
        t = [
          this.browserEventsService.subscribeToIdleStateChanged(e),
          this.browserEventsService.subscribeToWindowFocusChanged(e),
        ];
      return (this.unsubscribe = F(t)), this.checkTimer();
    }
    async checkTimer() {
      let [e, t] = await Promise.all([
        this.browserService.getNormalLastFocusedWindowId(),
        this.browserService.getIdleState(),
      ]);
      Boolean(t !== "active" || e === void 0)
        ? this.cancelTask()
        : this.hasTask() || this.scheduleTask();
    }
    async processTask() {
      return (
        (this.isDuringProcessTask = !0),
        this.cancelTask(),
        await this.incrementCounter(1),
        this.isCounterFinished()
          ? (this.sendEvent(), this.dispose())
          : ((this.isDuringProcessTask = !1), this.scheduleTask())
      );
    }
    hasTask() {
      return this.scheduler.hasTask(kh);
    }
    scheduleTask() {
      g(!this.hasTask(), "Failed to schedule task: task not found"),
        !this.isDuringProcessTask &&
          this.scheduler
            .taskSuicidal(kh, () => this.processTask())
            .everyMinute();
    }
    cancelTask() {
      this.scheduler.removeTask(kh);
    }
    sendEvent() {
      this.analytics
        .sendAnalyticsEventWithOptions("system.user-activated", void 0, {
          disableBatching: !0,
        })
        .catch(l);
    }
    async loadCounter() {
      this.counter = (await this.browserStorage.getItem("user-activated")) ?? 0;
    }
    incrementCounter(e) {
      return (
        this.assertValueIsLoaded(this.counter),
        (this.counter += e),
        this.browserStorage.setItem("user-activated", this.counter)
      );
    }
    isCounterFinished() {
      return this.assertValueIsLoaded(this.counter), this.counter >= BE;
    }
    assertValueIsLoaded(e) {
      g(e !== null, "Counter should be loaded");
    }
  };
c();
c();
c();
c();
var jt = (o, e, t = 0) =>
    o === 32 ? e : (t ? e | 0 : e << (32 - o)) + o * 1099511627776,
  Th = (o) => Math.round(o / 1099511627776) || 32,
  CE = (o, e, t = 0, r = []) => {
    let i,
      s = 0,
      a = e,
      n = t;
    for (; a >= 32; a -= 32) r.push(n), (n = 0);
    if (a === 0) return r.concat(o);
    for (i = 0; i < o.length; i += 1)
      r.push(n | (Number(o[i]) >>> a)), (n = Number(o[i]) << (32 - a));
    s = Number(o.length ? o[o.length - 1] : 0);
    let p = Th(s);
    return r.push(jt((a + p) & 31, a + p > 32 ? n : Number(r.pop()), 1)), r;
  },
  Ih = (o, e) => {
    let t = [...o],
      r = e;
    if (t.length * 32 < r) return t;
    t = t.slice(0, Math.ceil(r / 32));
    let i = t.length;
    return (
      (r &= 31),
      i > 0 &&
        r &&
        (t[i - 1] = jt(r, Number(t[i - 1]) & (2147483648 >> (e - 1)), 1)),
      o
    );
  };
var ds = (o, e) => {
    if (o.length === 0 || e.length === 0) return o.concat(e);
    let t = Number(o[o.length - 1]),
      r = Th(t);
    return r === 32 ? o.concat(e) : CE(e, r, t | 0, o.slice(0, o.length - 1));
  },
  Nt = (o) => {
    let e = o.length;
    if (e === 0) return 0;
    let t = o[e - 1];
    return (e - 1) * 32 + Th(Number(t));
  };
var NS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  LS = (o, e, t) => {
    let r = "",
      i,
      s = 0,
      a = NS,
      n = 0,
      p = Nt(o);
    for (t && (a = `${a.substr(0, 62)}-_`), i = 0; r.length * 6 < p; )
      (r += a.charAt((n ^ (Number(o[i]) >>> s)) >>> 26)),
        s < 6
          ? ((n = Number(o[i]) << (6 - s)), (s += 26), (i += 1))
          : ((n <<= 6), (s -= 6));
    for (; r.length & 3 && !e; ) r += "=";
    return r;
  },
  GS = (o, e) => {
    let t = o.replace(/\s|=/g, ""),
      r = [],
      i,
      s = 0,
      a = NS,
      n = 0,
      p;
    for (e && (a = `${a.substr(0, 62)}-_`), i = 0; i < t.length; i += 1) {
      if (((p = a.indexOf(t.charAt(i))), p < 0))
        throw new TypeError("this isn't base64!");
      s > 26
        ? ((s -= 26), r.push(n ^ (p >>> s)), (n = p << (32 - s)))
        : ((s += 6), (n ^= p << (32 - s)));
    }
    return s & 56 && r.push(jt(s & 56, n, 1)), r;
  };
c();
var Ah = (o) => {
    let e = [],
      t = Nt(o),
      r,
      i;
    for (r = 0; r < t / 8; r += 1)
      r & 3 || (i = o[r / 4]), (i = Number(i)), e.push(i >>> 24), (i <<= 8);
    return e;
  },
  Ph = (o) => {
    let e = [],
      t = 0,
      r = 0;
    for (t = 0; t < o.length; t += 1)
      (r = (r << 8) | Number(o[t])), (t & 3) === 3 && (e.push(r), (r = 0));
    return t & 3 && e.push(jt(8 * (t & 3), r)), e;
  };
c();
var HS = (o) => {
  let e = "";
  for (let t = 0; t < o.length; t += 1)
    e += ((Number(o[t]) | 0) + 0xf00000000000).toString(16).substr(4);
  return e.substr(0, Nt(o) / 4);
};
c();
c();
c();
c();
var VS = (o) => {
    let e = "",
      t = Nt(o),
      r,
      i = 0;
    for (r = 0; r < t / 8; r += 1)
      r & 3 || (i = o[r / 4]),
        (e += String.fromCharCode(((i >>> 8) >>> 8) >>> 8)),
        (i <<= 8);
    return decodeURIComponent(escape(e));
  },
  li = (o) => {
    let e = unescape(encodeURIComponent(o)),
      t = new Array(),
      r,
      i = 0;
    for (r = 0; r < e.length; r += 1)
      (i = (i << 8) | e.charCodeAt(r)), (r & 3) === 3 && (t.push(i), (i = 0));
    return r & 3 && t.push(jt(8 * (r & 3), i)), t;
  };
var or = class {
  h = [];
  buffer = [];
  length = 0;
  blockSize = 512;
  static hash(e) {
    return new or().update(e).finalize();
  }
  init = [];
  key = [];
  constructor(e) {
    this.key[0] || this.precompute(),
      e
        ? ((this.h = e.h.slice(0)),
          (this.buffer = e.buffer.slice(0)),
          (this.length = e.length))
        : this.reset();
  }
  reset() {
    return (
      (this.h = this.init.slice(0)), (this.buffer = []), (this.length = 0), this
    );
  }
  update(e) {
    typeof e == "string" && (e = li(e));
    let t,
      r = (this.buffer = ds(this.buffer, e)),
      i = this.length,
      s = (this.length = i + Nt(e));
    if (s > 9007199254740991)
      throw new TypeError("Cannot hash more than 2^53 - 1 bits");
    if (typeof Uint32Array < "u") {
      let a = new Uint32Array(r),
        n = 0;
      for (t = 512 + i - ((512 + i) & 511); t <= s; t += 512)
        this.block(a.subarray(16 * n, 16 * (n + 1))), (n += 1);
      r.splice(0, 16 * n);
    } else
      for (t = 512 + i - ((512 + i) & 511); t <= s; t += 512)
        this.block(r.splice(0, 16));
    return this;
  }
  finalize() {
    let e = this.buffer,
      { h: t } = this;
    e = ds(e, [jt(1, 1)]);
    for (let r = e.length + 2; r & 15; r += 1) e.push(0);
    for (
      e.push(Math.floor(this.length / 4294967296)), e.push(this.length | 0);
      e.length;

    )
      this.block(e.splice(0, 16));
    return this.reset(), t;
  }
  precompute() {
    let e = 0,
      t = 2,
      r,
      i,
      s = (a) => ((a - Math.floor(a)) * 4294967296) | 0;
    for (; e < 64; t += 1) {
      for (i = !0, r = 2; r * r <= t; r += 1)
        if (t % r === 0) {
          i = !1;
          break;
        }
      i &&
        (e < 8 && (this.init[e] = s(t ** (1 / 2))),
        (this.key[e] = s(t ** (1 / 3))),
        (e += 1));
    }
  }
  block(e) {
    let t,
      r,
      i,
      s,
      { h: a } = this,
      n = this.key,
      p = Number(a[0]),
      d = Number(a[1]),
      u = Number(a[2]),
      m = Number(a[3]),
      y = Number(a[4]),
      b = Number(a[5]),
      v = Number(a[6]),
      S = Number(a[7]);
    for (t = 0; t < 64; t += 1)
      t < 16
        ? (r = Number(e[t]))
        : ((i = Number(e[(t + 1) & 15])),
          (s = Number(e[(t + 14) & 15])),
          (r = e[t & 15] =
            (((i >>> 7) ^ (i >>> 18) ^ (i >>> 3) ^ (i << 25) ^ (i << 14)) +
              ((s >>> 17) ^ (s >>> 19) ^ (s >>> 10) ^ (s << 15) ^ (s << 13)) +
              Number(e[t & 15]) +
              Number(e[(t + 9) & 15])) |
            0)),
        (r =
          r +
          S +
          ((y >>> 6) ^
            (y >>> 11) ^
            (y >>> 25) ^
            (y << 26) ^
            (y << 21) ^
            (y << 7)) +
          (v ^ (y & (b ^ v))) +
          Number(n[t])),
        (S = v),
        (v = b),
        (b = y),
        (y = (m + r) | 0),
        (m = u),
        (u = d),
        (d = p),
        (p =
          (r +
            ((d & u) ^ (m & (d ^ u))) +
            ((d >>> 2) ^
              (d >>> 13) ^
              (d >>> 22) ^
              (d << 30) ^
              (d << 19) ^
              (d << 10))) |
          0);
    (a[0] = (Number(a[0]) + p) | 0),
      (a[1] = (Number(a[1]) + d) | 0),
      (a[2] = (Number(a[2]) + u) | 0),
      (a[3] = (Number(a[3]) + m) | 0),
      (a[4] = (Number(a[4]) + y) | 0),
      (a[5] = (Number(a[5]) + b) | 0),
      (a[6] = (Number(a[6]) + v) | 0),
      (a[7] = (Number(a[7]) + S) | 0);
  }
};
var us = class {
  updated = void 0;
  resultHash;
  baseHash;
  mac;
  hash;
  constructor(e, t) {
    (this.mac = this.encrypt.bind(this)), (this.hash = t = t || or);
    let r = [[], []],
      i = t.prototype.blockSize / 32;
    (this.baseHash = [new t(), new t()]), e.length > i && (e = t.hash(e));
    for (let s = 0; s < i; s += 1)
      (r[0][s] = Number(e[s]) ^ 909522486),
        (r[1][s] = Number(e[s]) ^ 1549556828);
    this.baseHash[0].update(r[0]),
      this.baseHash[1].update(r[1]),
      (this.resultHash = new t(this.baseHash[0]));
  }
  encrypt(e) {
    if (!this.updated) return this.update(e), this.digest();
    throw new TypeError("encrypt on already updated hmac called!");
  }
  reset() {
    (this.resultHash = new this.hash(this.baseHash[0])), (this.updated = !1);
  }
  update(e) {
    (this.updated = !0), this.resultHash.update(e);
  }
  digest() {
    let e = this.resultHash.finalize(),
      t = new this.hash(this.baseHash[1]).update(e).finalize();
    return this.reset(), t;
  }
};
var KS = (o, e, t, r, i) => {
  let s,
    a = [],
    n = [];
  (i = i || or),
    typeof r == "string" && (r = li(r)),
    typeof t == "string" ? (t = li(t)) : t || (t = []),
    (s = new us(t, i));
  let p = s.mac(o),
    d = Nt(p),
    u = Math.ceil(e / d);
  if (u > 255) throw new TypeError("key bit length is too large for hkdf");
  s = new us(p, i);
  for (let m = 1; m <= u; m += 1)
    s.update(n), s.update(r), s.update([jt(8, m)]), (a = ds(a, n));
  return Ih(a, e);
};
var QS = "23456789ABCDEFGHJKLMNPQRSTVWXYZ",
  xE = 6,
  WE = Eu(QS, 6),
  DE = Eu(QS, 5),
  Rh = (o) => new TextEncoder().encode(o),
  io = (o) => LS(Ph(o)),
  Eh = (o) => Ah(GS(o)),
  Sp = (o) => li(o),
  qS = (o) => VS(Ph(o)),
  UE = (o) => HS(o),
  Bh = (o) => Ah(o),
  zS = (o, e, t = "PBES2g-HS256") => KS(o, 256, e, t, or),
  OE = (o, e) => o.map((t, r) => t ^ Number(e[r]));
var YS = ({ crypto: o, storage: e }) => {
  let t = async (C, G) => {
      let K = { name: "PBKDF2" },
        B = new Uint8Array(Bh(Sp(C))),
        X = await o.subtle.importKey("raw", B, K, !1, ["deriveKey"]),
        ie = new Uint8Array(Bh(Sp(G))),
        Z = {
          name: "PBKDF2",
          iterations: 1e5,
          hash: { name: "SHA-256" },
          salt: ie,
        },
        ve = { name: "AES-GCM", length: 256 },
        Qe = await o.subtle.deriveKey(Z, X, ve, !0, ["encrypt"]),
        St = await o.subtle.exportKey("raw", Qe);
      return new Uint8Array(St);
    },
    r = () => {
      let C = {
        name: "RSA-OAEP",
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: { name: "SHA-256" },
      };
      return o.subtle.generateKey(C, !0, ["encrypt", "decrypt"]);
    },
    i = (C) => {
      switch (C) {
        case "RSA-OAEP-256":
          return { name: "RSA-OAEP", hash: { name: "SHA-256" } };
        default:
          return { name: "AES-GCM" };
      }
    },
    s = (C) => o.subtle.importKey("jwk", C, i(String(C.alg)), !0, C.key_ops),
    a = async (C, G) => ({ ...(await o.subtle.exportKey("jwk", C)), kid: G }),
    n = (C) => {
      let G = { name: "AES-GCM" };
      return o.subtle.importKey("raw", C, G, !0, ["encrypt", "decrypt"]);
    },
    p = async ({ key: C, kid: G, jwk: K }) =>
      C
        ? (g(G, "No kid to create key"),
          { crypto: C, id: G, jwk: await a(C, G) })
        : (g(K, "No jwk to create key"),
          { jwk: K, id: String(K.kid), crypto: await s(K) }),
    d = async () => {
      let C = await r(),
        [G, K] = await Promise.all([
          p({ key: C.privateKey, kid: Gs() }),
          p({ key: C.publicKey, kid: Gs() }),
        ]);
      return { privateKey: G, publicKey: K };
    },
    u = (C) => o.getRandomValues(new Uint8Array(C)),
    m = () => {
      let C = { name: "AES-GCM", length: 256 };
      return o.subtle.generateKey(C, !0, ["encrypt", "decrypt"]);
    },
    y = (C, G, K) => {
      let B = { name: "AES-GCM", iv: C };
      return o.subtle.encrypt(B, G, K);
    },
    b = (C, G) => {
      let K = { name: "RSA-OAEP" };
      return o.subtle.encrypt(K, C, G);
    },
    v = async (C, G, K) => {
      let X = { name: "AES-GCM", iv: new Uint8Array(Eh(C)) },
        ie = new Uint8Array(Eh(K)).buffer,
        Z = await o.subtle.decrypt(X, G, ie);
      return qS(new Uint8Array(Z));
    },
    S = async (C, G) => {
      let K = { name: "RSA-OAEP" },
        B = new Uint8Array(Eh(G)).buffer,
        X = await o.subtle.decrypt(K, C, B);
      return qS(new Uint8Array(X));
    },
    w = () => io(u(12)),
    T = async (C, G) => {
      let K = u(12),
        B = Rh(JSON.stringify(G.jwk)),
        X = await y(K, C.crypto, B),
        ie = io(new Uint8Array(X));
      return {
        kid: "main",
        enc: "A256GCM",
        cty: "b5+jwk+json",
        iv: io(K),
        data: ie,
      };
    },
    I = (() => {
      let C = (G) => {
        let [K, ...B] = G.split("-");
        return { raw: G, id: String(K), value: B.join("") };
      };
      return {
        get: async () => {
          let G = await e.get();
          return G ? C(G) : null;
        },
        generate: () => {
          let G = [];
          for (let K = 0; K < xE; K += 1) G.push(K < 2 ? WE() : DE());
          return C(G.join("-"));
        },
        reset: () => e.remove(),
        set: (G) => e.set(G),
      };
    })(),
    k = async ({
      masterPassword: C = "0000",
      recoveryKey: G,
      salt: K,
      userId: B,
    }) => {
      let X = await t(C, UE(zS(String(Sp(K)), B))),
        ie = Bh(zS(String(Sp(G.value)), G.id)),
        Z = new Uint8Array(OE(X, ie));
      return n(Z);
    },
    _ = async ({ publicKey: C }) => {
      let G = await p({ key: await m(), kid: Gs() }),
        K = Rh(JSON.stringify(G.jwk)),
        B = await b(C.crypto, K),
        X = io(new Uint8Array(B));
      return {
        encrypted: { kid: C.id, enc: "RSA-OAEP", cty: "b5+jwk+json", data: X },
        id: G.id,
        crypto: G.crypto,
      };
    },
    O = async ({ encryptedData: C, privateKey: G }) => {
      let K = await S(G.crypto, C.data),
        B = Oe(K);
      return (
        g(B, "No jwk to decrypt key"), { crypto: (await p({ jwk: B })).crypto }
      );
    },
    E = async ({ publicKey: C, data: G }) => {
      let K = await _({ publicKey: await p({ jwk: C }) }),
        B = u(12),
        X = await y(B, K.crypto, Rh(JSON.stringify(G)));
      return {
        key: K,
        encrypted: {
          kid: K.id,
          enc: "A256GCM",
          cty: "b5+jwk+json",
          iv: io(B),
          data: io(new Uint8Array(X)),
        },
      };
    };
  return {
    recoveryKeyManager: I,
    createKeySet: async ({ userId: C, recoveryKey: G }) => {
      let K = w(),
        [B, { publicKey: X, privateKey: ie }] = await Promise.all([
          Promise.resolve()
            .then(() => k({ userId: C, recoveryKey: G, salt: K }))
            .then((Z) => p({ kid: "main", key: Z })),
          d(),
        ]);
      return { salt: K, mainKey: B, publicKey: X, privateKey: ie };
    },
    decryptKeySet: async ({
      userId: C,
      recoveryKey: G,
      publicKeyRaw: K,
      encryptedPrivateKey: B,
      salt: X,
    }) => {
      let ie = await p({
          kid: "main",
          key: await k({ userId: C, recoveryKey: G, salt: X }),
        }),
        Z = await v(B.iv, ie.crypto, B.data),
        ve = Oe(Z);
      g(ve, "Must have privateJwk to decrypt keyset");
      let [Qe, St] = await Promise.all([p({ jwk: ve }), p({ jwk: K })]);
      return { mainKey: ie, privateKey: Qe, publicKey: St };
    },
    encryptCredential: E,
    decryptCredential: async ({
      encryptedData: C,
      encryptedKeyData: G,
      privateKey: K,
    }) => {
      let B = await O({ encryptedData: G, privateKey: K }),
        X = await v(C.iv, B.crypto, C.data),
        ie = Oe(X);
      return g(ie, "Failed to decrypt credentials"), ie;
    },
    encryptPrivateKey: T,
    prepareUserCredentials: async ({ keySet: C, data: G }) => {
      let K = await E({ data: G, publicKey: C.publicKey });
      return {
        data: K.encrypted,
        key: K.key.encrypted,
        publicKey: C.publicKey,
      };
    },
  };
};
c();
var oo = class {
  static parseKeyset(e) {
    return {
      publicKeyRaw: e.record.public_key,
      publicKeyId: e.record.public_key_id,
      encryptedPrivateKey: e.record.private_key_data,
      salt: e.record.salt,
    };
  }
  static parseCredentials(e) {
    return {
      collection: e.collection.map((t) => ({
        id: t.credential_id,
        access: {
          status: t.access.status,
          data: t.access.data,
          keyData: t.access.key_data,
        },
        pendingPublicKeys: t.pending_public_keys.map((r) => ({
          id: r.id,
          data: r.data,
        })),
      })),
    };
  }
};
var wp = class {
  constructor(e, t, r, i, s) {
    this.backendService = e;
    this.authService = t;
    this.applicationRepository = i;
    let a = this.authService.getUserId(),
      n = `${"USER_"}${a}`;
    (this.cryptoLibrary = YS({
      crypto: globalThis.crypto,
      storage: {
        get: () => s.getGlobalItem(n),
        set: (p) => s.setGlobalItem(n, p),
        remove: () => s.removeGlobalItem(n),
      },
    })),
      this.init().catch(l),
      r.subscribe(
        ["updated"],
        ["credentials.updated"],
        async ({ version: p, payload: d }) => {
          if (
            (p === "firebase" || d.isTeamSubscription) &&
            d.public_key_id &&
            this.keyset?.publicKeyId !== d.public_key_id
          ) {
            await this.initCredentials();
            return;
          }
          await this.initCredentials();
        },
        { uri: "/desktop/credentials" },
        { needsTeamSubscription: !0 }
      ),
      D.on("apps-loaded", () => {
        this.tryToRequestMissingCredentials().catch(l);
      });
  }
  cryptoLibrary;
  keyset = null;
  credentials = null;
  async init() {
    (this.keyset = await this.loadKeyset()), await this.initCredentials();
  }
  async initCredentials() {
    (this.credentials = await this.loadCredentials()),
      await this.shareCredentials(),
      await this.tryToRequestMissingCredentials();
  }
  getCredentialsById(e) {
    if (!e || !this.credentials || !this.keyset) return null;
    let t = this.credentials[e];
    return t?.decrypted
      ? (this.notifyAccess(e, this.keyset.publicKeyId).catch(l), t.decrypted)
      : null;
  }
  async loadKeyset() {
    let e = this.authService.getUserId(),
      t = await this.cryptoLibrary.recoveryKeyManager.get();
    if (t)
      try {
        let n = await this.backendService.teamAppSharing.getKeyset(t.id),
          p = oo.parseKeyset(n);
        return {
          ...(await this.cryptoLibrary.decryptKeySet({
            ...p,
            userId: e,
            recoveryKey: t,
          })),
          recoveryKey: t,
          salt: p.salt,
          publicKeyId: p.publicKeyId,
        };
      } catch (n) {
        if (n instanceof Error && !n.message && n.name === "OperationError")
          throw new L("Can't decrypt KeySet", { extra: { key: t.raw } });
        if (!(n instanceof lt) || n.status !== 404) throw n;
      }
    let r = this.cryptoLibrary.recoveryKeyManager.generate();
    await this.cryptoLibrary.recoveryKeyManager.set(r.raw);
    let i = await this.cryptoLibrary.createKeySet({
        userId: e,
        recoveryKey: r,
      }),
      s = await this.backendService.teamAppSharing.createKeyset({
        privateKey: await this.cryptoLibrary.encryptPrivateKey(
          i.mainKey,
          i.privateKey
        ),
        publicKey: i.publicKey.jwk,
        salt: i.salt,
        recoveryKeyId: r.id,
      }),
      { publicKeyId: a } = oo.parseKeyset(s);
    return { ...i, publicKeyId: a, recoveryKey: r };
  }
  async loadCredentials() {
    g(this.keyset, "No keyset to load credentials");
    let { keyset: e } = this,
      t = await this.backendService.teamAppSharing.getCredentials(
        this.keyset.publicKeyId
      ),
      { collection: r } = oo.parseCredentials(t),
      i = await Promise.all(
        r.map(async (s) => ({
          ...s,
          decrypted:
            s.access.status === "active"
              ? await this.cryptoLibrary.decryptCredential({
                  encryptedData: s.access.data,
                  encryptedKeyData: s.access.keyData,
                  privateKey: e.privateKey,
                })
              : null,
        }))
      );
    return Object.fromEntries(i.map((s) => [s.id, s]));
  }
  async tryToRequestMissingCredentials() {
    let { keyset: e, credentials: t } = this;
    if (!e || !t) return;
    let i = this.applicationRepository.getAllApps().filter((s) => {
      if (!s.isTeamApp || !s.teamCredentialId) return !1;
      let a = t[s.teamCredentialId];
      if (!a) return !0;
      let { status: n } = a.access;
      return n !== "active" && n !== "pending";
    });
    await Promise.all(
      i.map(
        ({ teamCredentialId: s }) => (
          g(
            s,
            "Must have teamCredentialId to request missing credential for app"
          ),
          this.requestAccess(s, e.publicKeyId)
        )
      )
    );
  }
  async shareCredentials() {
    g(this.credentials, "Cant share credentials: credentials not found");
    let t = (
      await Promise.all(
        Object.values(this.credentials).map(
          async ({ id: r, pendingPublicKeys: i, decrypted: s }) =>
            s
              ? Promise.all(
                  i.map(async ({ data: a, id: n }) => {
                    let p = await this.cryptoLibrary.encryptCredential({
                      publicKey: a,
                      data: s,
                    });
                    return {
                      credentialId: r,
                      publicKeyId: n,
                      data: p.encrypted,
                      keyData: p.key.encrypted,
                    };
                  })
                )
              : []
        )
      )
    ).flat();
    t.length &&
      (await this.backendService.teamAppSharing.shareCredentials({
        accesses: t,
      }));
  }
  async requestAccess(e, t) {
    await this.backendService.teamAppSharing.requestAccess(e, t);
  }
  async notifyAccess(e, t) {
    await this.backendService.teamAppSharing.checkAccess(e, t);
  }
};
c();
var so = class {
  constructor(e, t) {
    this.onboardingDataService = e;
    this.browserService = t;
  }
  token;
  userId;
  getToken() {
    return this.token;
  }
  getUserId() {
    return this.userId;
  }
  static async build(e, t) {
    let r = new so(e, t),
      i = await e.isUserOnboarded(),
      s = await r.fetchAuthToken(i);
    if (s)
      try {
        return (
          r.processAuthToken(s),
          i || (await r.saveAuthToken(), await e.setUserOnboarded()),
          r
        );
      } catch {}
    return await r.signOut(), r;
  }
  async signOut(e) {
    return await this.clearAuthToken(), this.onboardingDataService.signOut(e);
  }
  updateToken(e) {
    return this.processAuthToken(e), this.saveAuthToken();
  }
  async fetchAuthToken(e) {
    return e
      ? this.loadAuthToken()
      : (await this.onboardingDataService.fetchOnboardingData()).token;
  }
  async loadAuthToken() {
    let e = (
      await this.browserService.getFromLocalBrowserStorage("auth-state")
    )?.["auth-state"];
    if (e?.sidekick?.token) return e.sidekick.token;
    let r = Oe(localStorage.getItem("auth-state"))?.sidekick.token ?? "";
    if (r)
      return (
        await this.browserService.saveIntoLocalBrowserStorage({
          ["auth-state"]: { sidekick: { token: r } },
        }),
        r
      );
  }
  saveAuthToken() {
    return this.browserService.saveIntoLocalBrowserStorage({
      ["auth-state"]: { sidekick: { token: this.token } },
    });
  }
  clearAuthToken() {
    return this.browserService.saveIntoLocalBrowserStorage({
      ["auth-state"]: { sidekick: { token: "" } },
    });
  }
  processAuthToken(e) {
    (this.userId = this.parseUserId(e)), (this.token = e);
  }
  parseUserId(e) {
    let t = e.split(".")[1];
    if (!t) throw new Error("User id was not loaded properly");
    let r = Oe(atob(t));
    if (!r) throw new Error("User id was not loaded properly");
    return r.uuid;
  }
};
c();
var ao = class {
  constructor(e, t, r) {
    this.googleApiService = e;
    this.slackApiService = t;
    this.browserStorage = r;
  }
  activeCredentials = {
    ["google"]: {
      ["CALENDAR"]: {},
      ["CONTACTS"]: {},
      ["EMAIL_SIGNATURES"]: {},
    },
    ["slack"]: { ["CALENDAR"]: {}, ["CONTACTS"]: {}, ["EMAIL_SIGNATURES"]: {} },
  };
  static async build(e, t, r) {
    let i = new ao(e, t, r);
    return await i.loadCredentialsFromLS(), i;
  }
  removeGoogleCalendar(e) {
    this.removeOauthData("google", "CALENDAR", e);
  }
  getGoogleCredentials(e) {
    return this.activeCredentials["google"][e];
  }
  getLastCredentialsByScope(e, t) {
    let r = this.activeCredentials[e][t];
    return Object.entries(r)[0];
  }
  getAccessTokenForGoogleEmail(e, t) {
    return this.activeCredentials["google"][e][t]?.accessToken;
  }
  updateGoogleCredentialsKey(e, t, r) {
    let i = this.activeCredentials["google"][e][t];
    g(i, "No data by key for exchange"),
      (this.activeCredentials["google"][e][r] = { ...i }),
      delete this.activeCredentials["google"][e][t],
      this.saveCredentialsToLS();
  }
  getOauthUrl(e, t) {
    return e === "google"
      ? this.googleApiService.getAuthUrl(t)
      : this.slackApiService.getAuthUrl(t);
  }
  setOauthData(e, t, r) {
    let i = le();
    return (this.activeCredentials[e][t][i] = r), this.saveCredentialsToLS(), i;
  }
  removeOauthData(e, t, r) {
    delete this.activeCredentials[e][t][r], this.saveCredentialsToLS();
  }
  async tryRefreshGoogleAccessToken(e, t) {
    let r = "google",
      i = this.activeCredentials[r][e][t]?.refreshToken;
    g(i, "Failed to refresh google access token: refreshToken not found");
    let s = await this.googleApiService.tryRefreshToken(i);
    return (
      (this.activeCredentials[r][e][t] = {
        accessToken: s.access_token,
        refreshToken: i,
      }),
      this.saveCredentialsToLS(),
      s.access_token
    );
  }
  updateGoogleCalendarName(e, t) {
    let r = this.activeCredentials["google"].CALENDAR[t];
    r &&
      ((this.activeCredentials["google"].CALENDAR[e] = r),
      delete this.activeCredentials["google"].CALENDAR[t]),
      this.saveCredentialsToLS();
  }
  async loadCredentialsFromLS() {
    let e = await this.browserStorage.getItem(
      "external-auth-credentials-by-type"
    );
    e && (this.activeCredentials = e);
  }
  saveCredentialsToLS() {
    this.browserStorage
      .setItem("external-auth-credentials-by-type", this.activeCredentials)
      .catch(l);
  }
};
c();
var kp = class {
  constructor(e, t) {
    this.backendService = e;
    this.endpoint = t;
  }
  SCOPE_FOR_REQUESTS = {
    ["CALENDAR"]: ["https://www.googleapis.com/auth/calendar.readonly"],
    ["CONTACTS"]: [
      "https://www.googleapis.com/auth/userinfo.email",
      "https://www.googleapis.com/auth/admin.directory.user.readonly",
      "https://www.googleapis.com/auth/contacts.readonly",
    ],
    ["EMAIL_SIGNATURES"]: [
      "https://www.googleapis.com/auth/gmail.settings.basic",
    ],
  };
  getAuthUrl(e) {
    let t = this.SCOPE_FOR_REQUESTS[e],
      r = `${this.endpoint}/oauth2/google/authorize`;
    return this.composeUrl(r, `scope=${t.join(" ")}`);
  }
  async getUserInfo(e) {
    let t = "https://www.googleapis.com/oauth2/v3/userinfo",
      r = this.composeUrl(t, `access_token=${e}`),
      i = new Request(r, { method: "GET" }),
      s = await fetch(i);
    return je(s, i);
  }
  async getCalendarsInfo(e, t) {
    let r = "https://www.googleapis.com/calendar/v3/calendars/primary/events",
      i = new Date(),
      s = Uu(i),
      a = Uu(ta(Js(i, 1))),
      n = new URLSearchParams({
        orderBy: "startTime",
        singleEvents: "true",
        access_token: e,
        timeMin: s,
        timeMax: a,
      }),
      p = this.composeUrl(r, n.toString()),
      d = new Request(p, { method: "GET" }),
      u = await fetch(d);
    if (u.status === 401) {
      let m = await u.json();
      throw new L("The client provides no credentials or invalid credentials", {
        extra: {
          message: btoa(m?.error?.message ?? ""),
          params: btoa(n.toString()),
          tokenBeforeLength: t?.length ?? -1,
          newTokenLength: e.length ?? -1,
        },
      });
    }
    return je(u, d);
  }
  async getUserDomainContacts(e, t) {
    let r = "https://admin.googleapis.com/admin/directory/v1/users",
      i = new URLSearchParams({
        access_token: e,
        viewType: "domain_public",
        domain: t,
      }),
      s = this.composeUrl(r, i.toString()),
      a = new Request(s, { method: "GET" }),
      n = await fetch(a);
    if (n.status > 400) throw new lt(n, a);
    return je(n, a);
  }
  async getUserPersonalContacts(e) {
    let t = "https://people.googleapis.com/v1/people/me/connections",
      r = new URLSearchParams({
        access_token: e,
        personFields: "photos,names,emailAddresses",
        pageSize: "999",
        sortOrder: "LAST_NAME_ASCENDING",
      }),
      i = this.composeUrl(t, r.toString()),
      s = new Request(i, { method: "GET" }),
      a = await fetch(s);
    return je(a, s);
  }
  async getSignatures(e) {
    let t = "https://gmail.googleapis.com/gmail/v1/users/me/settings/sendAs/",
      r = new Request(t, { method: "GET", headers: this.getAuthHeaders(e) }),
      i = await fetch(r);
    return je(i, r);
  }
  async makeGmailSignature(e, t) {
    let r = "https://gmail.googleapis.com/gmail/v1/users/me/settings/sendAs/",
      i = await this.getSignatures(e),
      s = i.sendAs.find((u) => u.isDefault),
      a = i.sendAs.find((u) => u.isPrimary),
      d = (s?.sendAsEmail === a?.sendAsEmail ? [a] : [s, a])
        .filter(de)
        .map((u) =>
          fetch(`${r}${u.sendAsEmail}`, {
            method: "PUT",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
              ...this.getAuthHeaders(e),
            },
            body: JSON.stringify({ isDefault: !0, signature: t }),
          }).catch(l)
        );
    await Promise.allSettled(d);
  }
  tryRefreshToken(e) {
    return this.backendService.oauth.refreshGoogleToken({ refresh_token: e });
  }
  composeUrl(e, t) {
    let r = new URL(e);
    return (r.search = t), r.toString();
  }
  getAuthHeaders(e) {
    return { Authorization: `Bearer ${e}` };
  }
};
c();
var Tp = class {
  constructor(e) {
    this.endpoint = e;
  }
  SCOPE_FOR_REQUESTS = {
    ["CALENDAR"]: [],
    ["CONTACTS"]: ["users:read", "users:read.email"],
    ["EMAIL_SIGNATURES"]: [],
  };
  getAuthUrl(e) {
    let t = this.SCOPE_FOR_REQUESTS[e],
      r = `${this.endpoint}/oauth2/slack/authorize?`;
    return this.composeUrl(r, `scope=${t.join(" ")}`);
  }
  async getContacts(e) {
    let t = "https://slack.com/api/users.list",
      r = new Request(t, {
        method: "GET",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Authorization: `Bearer ${e}`,
        },
      }),
      i = await fetch(r);
    return je(i, r);
  }
  composeUrl(e, t) {
    let r = new URL(e);
    return (r.search = t), r.toString();
  }
};
c();
var Ch = "sidekick.user_is_onboarded",
  Ip = class {
    constructor(e, t) {
      this.browserService = e;
      this.browserEventsService = t;
    }
    onboardingRecipes;
    isAfterOnboarding = !1;
    isFirstTimeOnboarding = !0;
    anonymousMetaInfo;
    logger = x.createInstance("auth");
    getOnboardingRecipes() {
      return this.onboardingRecipes;
    }
    getIsAfterOnboarding() {
      return this.isAfterOnboarding;
    }
    getIsFirstTimeOnboarding() {
      return this.isFirstTimeOnboarding;
    }
    getIsInitialOnboarding() {
      return this.getIsAfterOnboarding() && this.getIsFirstTimeOnboarding();
    }
    getShouldRestoreDataAfterOnboarding() {
      return this.getIsAfterOnboarding() && !this.getIsFirstTimeOnboarding();
    }
    async fetchOnboardingData() {
      let e = await new Promise((t) => {
        let r = this.browserEventsService.subscribeToUserOnboarded(
          (i, s, a, n) => {
            t({ token: i, anonymousMetaInfo: s, firstTime: a, recipes: n }),
              r();
          }
        );
      });
      return (
        (this.isAfterOnboarding = !0),
        (this.anonymousMetaInfo = e.anonymousMetaInfo),
        (this.isFirstTimeOnboarding = e.firstTime),
        (this.onboardingRecipes = e.recipes),
        this.logger.info(
          "Onboarding data loaded",
          this.onboardingRecipes,
          this.isFirstTimeOnboarding
        ),
        e
      );
    }
    async isUserOnboarded() {
      return (await this.browserService.getPref(Ch)).value;
    }
    async setUserOnboarded() {
      await this.browserService.setPref(Ch, !0);
    }
    async signOut(e) {
      let t = await this.browserService.getLastFocusedWindowId();
      return (
        await this.browserService.setPref(Ch, !1),
        this.browserService.signOut(t, e)
      );
    }
    getAnonymousMetaInfo() {
      return this.anonymousMetaInfo;
    }
  };
c();
var Ap = class {
  constructor(e, t, r) {
    this.onboardingDataService = e;
    this.applicationApi = t;
    this.backendService = r;
    this.onboardingDataService.getIsInitialOnboarding() &&
      (this.backendService.extension.updateUserOnboarded().catch(l),
      D.once("accounts-loaded", () => {
        this.setupAfterOnboarding().catch(l);
      }));
  }
  async setupAfterOnboarding() {
    await this.addAppsAfterOnboarding();
  }
  async addAppsAfterOnboarding() {
    let e = this.onboardingDataService.getOnboardingRecipes();
    return e
      ? this.applicationApi.addAppsAfterOnboarding(e)
      : Promise.resolve();
  }
};
c();
c();
var XS = J({ token: M().required(), user: La.required() });
var Pp = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m, y) {
    this.browserService = e;
    this.browserEventsService = t;
    this.authService = r;
    this.systemInfoService = i;
    this.themeService = s;
    this.actualUsageDaysRepository = a;
    this.featureFlagsRepository = n;
    this.userService = p;
    this.userRepository = d;
    this.modalService = u;
    this.analyticsTracker = m;
    this.appUrl = y;
    this.subscribeToCheckConditions(),
      this.subscribeToShowPopups(),
      t.subscribeToMessageExternal((b) => this.handleExternalMessage(b));
  }
  shouldShowPopup = !1;
  showModal(e, t) {
    let r = this.getIsPopupClosable();
    return this.modalService.showSignUpModal(
      {
        ...e,
        actualUsageDays: this.actualUsageDaysRepository.getCount() ?? -1,
        isClosable: this.getIsPopupClosable(),
        iframeSrc: this.getPopupIframeSrc(),
      },
      t,
      !r
    );
  }
  getIsPopupClosable() {
    if (!this.featureFlagsRepository.getFeatureFlags().signUpDialogEnabled)
      return !0;
    let t = this.actualUsageDaysRepository.getCount() ?? 0,
      { blockAfterDays: r } =
        this.featureFlagsRepository.getFeatureFlags().signUpDialog;
    return r === null || t <= r;
  }
  getIsPopupVisibleAtStartup() {
    if (!this.featureFlagsRepository.getFeatureFlags().signUpDialogEnabled)
      return !1;
    let t = this.actualUsageDaysRepository.getCount() ?? 0,
      r = this.userRepository.getIsTemporaryUser(),
      { showAfterDays: i } =
        this.featureFlagsRepository.getFeatureFlags().signUpDialog;
    return r && i !== null && t >= i;
  }
  getPopupIframeSrc() {
    let e = this.authService.getToken(),
      t = this.themeService.getTheme(),
      {
        extensionVersion: r,
        browserVersion: i,
        deviceId: s,
        versionInfo: a,
      } = this.systemInfoService,
      n = new URLSearchParams();
    n.set("token", e),
      n.set("type", "self"),
      n.set("ext", r),
      n.set("browser", i),
      n.set("deviceId", s.value),
      Object.keys(a).forEach((d) => {
        n.set(`s-${d}`, String(a[d]));
      });
    let p = n.toString();
    return `${this.appUrl}/login/ext-signup-dialog${p ? `?${p}` : ""}#${
      t || "auto"
    }`;
  }
  subscribeToCheckConditions() {
    let e = [
      W.onSeveral(
        ["user-loaded", "actual-usage-days-updated"],
        this.checkConditions.bind(this)
      ),
      this.featureFlagsRepository.onFeatureFlagsLoaded(
        this.checkConditions.bind(this)
      ),
    ];
    return this.checkConditions(), F(e);
  }
  checkConditions() {
    let e = this.getIsPopupVisibleAtStartup();
    e !== this.shouldShowPopup &&
      ((this.shouldShowPopup = e),
      this.shouldShowPopup
        ? this.showPopupInExistedWindows().catch(l)
        : this.tryClosePopup());
  }
  subscribeToShowPopups() {
    let e = [
      W.on("actual-usage-days-updated", () => {
        this.shouldShowPopup && this.showPopupInExistedWindows().catch(l);
      }),
      this.browserEventsService.subscribeToNormalWindowCreated((t) => {
        let r = !this.shouldShowPopup || this.getIsPopupClosable();
        !t.id ||
          r ||
          this.showModal({ source: "condition-trigger" }, t.id).catch(l);
      }),
    ];
    return F(e);
  }
  async showPopupInExistedWindows() {
    if (this.getIsPopupClosable()) {
      let t = await this.browserService.getLastFocusedWindowId();
      if (t === void 0) return;
      await this.showModal({ source: "condition-trigger" }, t);
      return;
    }
    let e = await this.browserService.getAllNormalWindows();
    e.length &&
      (await Promise.all(
        e.map(
          (t) => t.id && this.showModal({ source: "condition-trigger" }, t.id)
        )
      ));
  }
  tryClosePopup() {
    this.modalService.closeAllModalsById("signup");
  }
  async handleExternalMessage(e) {
    if (!this.getIsAuthMessage(e)) return;
    XS.validateSync(e.payload);
    let { token: t, user: r } = e.payload,
      i = this.authService.getToken(),
      s = t === i;
    if (
      (s &&
        this.analyticsTracker.sendAnalyticsEvent("system.new-user-signed-up", {
          source: "sign-up",
        }),
      this.analyticsTracker.sendAnalyticsEvent("system.user-signed-in", {
        source: "sign-up",
        "is-new-user": s,
      }),
      s)
    ) {
      this.tryClosePopup(), this.userService.refreshUserInfo(r);
      return;
    }
    try {
      await this.authService.updateToken(t);
    } catch {
      await this.authService.signOut();
    }
    globalThis.location.reload();
  }
  getIsAuthMessage(e) {
    return Ge(e) && oe(e, "type") && e.type === "AUTH_TOKEN";
  }
};
c();
c();
var Rp = class {
  constructor(e) {
    this.routes = e;
    this.routesWithCache = this.routes.filter((t) => t.cache.size);
  }
  routesWithCache;
  getRouteForCache(e) {
    let { pathname: t, search: r } = new URL(e.url),
      i = `${t}${r}`,
      s = Fg(e),
      a = this.routesWithCache.find((n) => n.match(i));
    if (a?.cache.has(s)) return a;
  }
};
c();
var JS = (o, e, t) => {
  let r = (n) => {
      console.warn(`Request for ${n.url} was restored from cache.`);
    },
    i = (n) => n.ok && n.status !== 204,
    s = (n) => n.status >= 500 || n.status === 429,
    a = async (n) => {
      let d = (await t.includes(n)) ? o : e;
      try {
        let u = await d(n);
        if (i(u)) await t.saveResponse(n, u);
        else if (s(u)) {
          let m = await t.loadResponse(n);
          if (m) return r(n), m;
        }
        return u;
      } catch (u) {
        let m = await t.loadResponse(n);
        if (m) return r(n), m;
        throw u;
      }
    };
  return (n, p) => {
    let d = new Request(n, p);
    return a(d);
  };
};
c();
var Ep = class {
  constructor(e, t) {
    this.browserStorage = e;
    this.router = t;
  }
  async includes(e) {
    return this.getRoute(e) ? (await this.readFromStorage(e)) !== void 0 : !1;
  }
  async loadResponse(e) {
    try {
      if (!this.getRoute(e)) return null;
      let t = await this.readFromStorage(e);
      return t === void 0
        ? null
        : new Response(t, { status: 200, statusText: "OK from Ext-Cache" });
    } catch (t) {
      return l(t), null;
    }
  }
  async saveResponse(e, t) {
    let r = this.getRoute(e);
    if (!r) return;
    let i = await t.clone().text();
    await r.schema?.validate(Oe(i)), await this.saveToStorage(e, i);
  }
  getRoute(e) {
    return this.router.getRouteForCache(e);
  }
  getStorageKey(e) {
    let { pathname: t, search: r } = new URL(e.url);
    return `${"backend_cache_"}${t}${r}`;
  }
  readFromStorage(e) {
    return this.browserStorage.getItem(this.getStorageKey(e));
  }
  saveToStorage(e, t) {
    return this.browserStorage.setItem(this.getStorageKey(e), t);
  }
};
c();
var ZS = (o, e, t) => {
  let r = async (i) => {
    let { request: s, resolve: a } = i,
      n = (p, d = null) => {
        throw (e({ ...i, callback: r }, d), p);
      };
    return (
      t(i),
      o(s.clone()).then((p) => {
        if ((p.status >= 500 && p.status < 600) || p.status === 429) {
          let d = p.headers.get("retry-after"),
            u = d !== null ? Number(d) : null,
            m = new Error(
              `Couldn't fetch data: ${s.method} ${p.url} - status: ${p.status}`
            );
          n(m, u);
        }
        return a(p), p;
      }, n)
    );
  };
  return (i, s) => {
    let a = new Request(i, s);
    return new Promise((n) => r({ request: a, resolve: n, callback: r }));
  };
};
c();
var jE = (o) => {
  let t = ce(10);
  return 3 ** Math.min(o, 4) * t;
};
var ew = (o, e, t) => {
  let r = new A(),
    i = new Set(),
    s = 0,
    a = null,
    n = () => {
      a !== null && (t(a), (a = null), r.emit("reconnect"));
    },
    p = async () => {
      if (me.DISABLE_RETRY_DECORATOR) {
        console.warn("Retry decorator is turned off"), i.clear(), (s = 0);
        return;
      }
      n(),
        await Promise.all(Array.from(i).map((y) => y.callback(y))),
        (s = 0),
        r.emit("connectSuccess");
    },
    d = (y) => {
      let b = y || jE(s);
      (s += 1), (a = e(p, b)), r.emit("connectFailed", Date.now() + b);
    };
  return {
    retryQueuedRequests: p,
    enqueueRequest: (y, b) => {
      i.add(y), o.onLine && (a || d(b));
    },
    dequeueRequest: (y) => {
      i.delete(y);
    },
    subscribeToStartReconnect: r.on.bind(r, "reconnect"),
    subscribeToConnectSuccess: r.on.bind(r, "connectSuccess"),
    subscribeToConnectFailed: r.on.bind(r, "connectFailed"),
  };
};
var tw = (o) => {
  let e = window.fetch.bind(window),
    {
      retryQueuedRequests: t,
      enqueueRequest: r,
      dequeueRequest: i,
      subscribeToStartReconnect: s,
      subscribeToConnectSuccess: a,
      subscribeToConnectFailed: n,
    } = ew(window.navigator, window.setTimeout, window.clearTimeout),
    p = ZS(e, r, i);
  window.addEventListener("online", t);
  let d = new Rp([
      ...Object.values(um),
      ...Object.values(vm),
      ...Object.values(xm),
      ...Object.values(cm),
      ...Object.values(Lm),
    ]),
    u = new Ep(o, d);
  return {
    fetch: JS(e, p, u),
    originalFetch: e,
    retryApi: {
      retryQueuedRequests: t,
      subscribeToStartReconnect: s,
      subscribeToConnectSuccess: a,
      subscribeToConnectFailed: n,
    },
  };
};
c();
var NE = (o, e, t, r) => {
    let i = `Bearer ${r}`,
      s = () =>
        e.body
          ? e.body instanceof FormData
            ? e.body
            : JSON.stringify(e.body)
          : null;
    return {
      method: o,
      headers: dr({
        ...(e.headers || {}),
        Authorization: i,
        "Content-Type": e.body instanceof FormData ? null : "application/json",
        "X-Request-Id": e.reqId,
        "X-Browser-Version": t.browserVersion,
        "X-Ext-Version": t.extensionVersion,
        "X-Device-Id": t.deviceId.value,
      }),
      body: s(),
    };
  },
  Bp = class {
    constructor(e, t, r, i, s) {
      this.systemInfo = e;
      this.performanceTransactionManager = t;
      this.endpoint = r;
      this.fetch = i;
      g(r, "Endpoint should be provided!"), (this.token = s.getToken());
    }
    token;
    get(e, t, r = {}) {
      return this.request("GET", e, r, t);
    }
    post(e, t, r = {}) {
      return this.request("POST", e, r, t);
    }
    patch(e, t, r = {}) {
      return this.request("PATCH", e, r, t);
    }
    put(e, t, r = {}) {
      return this.request("PUT", e, r, t);
    }
    delete(e, t, r = {}) {
      return this.request("DELETE", e, r, t);
    }
    head(e, t, r = {}) {
      return this.request("HEAD", e, r, t);
    }
    async request(e, t, r, i) {
      let s = `${this.endpoint}${t}`,
        a = this.startPerfTracing(e, i.route),
        n = new Request(s, NE(e, r, this.systemInfo, this.token)),
        p = await this.fetch(n);
      if (!p.ok) throw (a(null), new lt(p, n));
      if (r.raw) return a(p.status), p;
      if (p.status === 204) return a(p.status), null;
      try {
        return await je(p, n);
      } finally {
        a(p.status);
      }
    }
    startPerfTracing(e, t) {
      let r = this.performanceTransactionManager.map((i) => {
        let s = "http",
          a = `${e} ${t}`,
          n = `${s}[${e}] ${t}`,
          p = i.data[n] ?? 0;
        return i.setData(n, p + 1), i.startChild({ op: s, description: a });
      });
      return (i) => {
        r.forEach((s) => {
          s.setTag("http.status_code", i), s.finish();
        });
      };
    }
  };
c();
var iw = (o) => o.startsWith(sb) || o.startsWith(ab),
  rw = (o) => Boolean(o.url && o.status === "complete" && !iw(o.url)),
  no = class {
    constructor(e, t) {
      this.browserService = e;
      this.missedWindowsFromOnCreated = t;
    }
    static async build(e) {
      let t = await e.getPendingWindowOnCreatedEvents();
      return new no(e, t);
    }
    subscribeToMessage(e) {
      return this.subscribeChromeEvent(chrome.runtime.onMessage, (t, r, i) =>
        ee(e(t, r, i))
      );
    }
    subscribeToMessageExternal(e) {
      return this.subscribeChromeEvent(
        chrome.runtime.onMessageExternal,
        (t, r, i) => ee(e(t, r, i))
      );
    }
    subscribeToExtensionInstalled(e) {
      return this.subscribeChromeEvent(chrome.runtime.onInstalled, (t) =>
        ee(e(t))
      );
    }
    subscribeToWindowCreated(e) {
      return this.subscribeChromeEvent(chrome.windows.onCreated, (t) =>
        ee(e(t))
      );
    }
    subscribeToNormalWindowCreated(e) {
      return this.subscribeChromeEvent(chrome.windows.onCreated, (t) => {
        t.type === "normal" && ee(e(t));
      });
    }
    subscribeToWindowFocusChanged(e) {
      return this.subscribeChromeEvent(chrome.windows.onFocusChanged, e, {
        windowTypes: ["normal"],
      });
    }
    subscribeToNormalWindowFocusChanged(e) {
      return this.subscribeChromeEvent(chrome.windows.onFocusChanged, e, {
        windowTypes: ["normal"],
      });
    }
    subscribeToWindowRemoved(e) {
      return this.subscribeChromeEvent(chrome.windows.onRemoved, e);
    }
    subscribeToTabCreated(e) {
      return this.subscribeChromeEvent(chrome.tabs.onCreated, (t) =>
        e(this.browserService.normalizeTab(t))
      );
    }
    subscribeToTabUpdated(e) {
      return this.subscribeChromeEvent(chrome.tabs.onUpdated, (t, r, i) =>
        ee(e(t, r, this.browserService.normalizeTab(i)))
      );
    }
    subscribeToTabRemoved(e) {
      return this.subscribeChromeEvent(chrome.tabs.onRemoved, e);
    }
    subscribeToTabReplaced(e) {
      return this.subscribeChromeEvent(chrome.tabs.onReplaced, e);
    }
    subscribeToTabMoved(e) {
      return this.subscribeChromeEvent(chrome.tabs.onMoved, e);
    }
    subscribeToTabAttached(e) {
      return this.subscribeChromeEvent(chrome.tabs.onAttached, e);
    }
    subscribeOnTabClosedByGesture(e) {
      return this.subscribeChromeEvent(chrome.tabs.onClosedByGesture, e);
    }
    subscribeToTabDetached(e) {
      return this.subscribeChromeEvent(chrome.tabs.onDetached, (t, r) =>
        ee(e(t, r))
      );
    }
    subscribeToTabActivated(e) {
      return this.subscribeChromeEvent(chrome.tabs.onActivated, (t) =>
        ee(e(t))
      );
    }
    subscribeToMouseEnterHotZone(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.browserUi.onMouseEnterHotZone,
        (t) => ee(e(t))
      );
    }
    subscribeToMouseExitHotZone(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.browserUi.onMouseExitHotZone,
        (t) => ee(e(t))
      );
    }
    subscribeOnBrowserUpdateCompleted(e) {
      chrome.sidekick.update.onCompleted.addListener(e);
    }
    subscribeOnBrowserUpdateFailed(e) {
      chrome.sidekick.update.onFailed.addListener(e);
    }
    subscribeOnBrowserDownloadCompleted(e) {
      chrome.sidekick.update.onDownloadCompleted.addListener(e);
    }
    subscribeOnBrowserDownloadStarted(e) {
      chrome.sidekick.update.onDownloadStarted.addListener(e);
    }
    subscribeOnBrowserInstallStarted(e) {
      chrome.sidekick.update.onInstallStarted.addListener(e);
    }
    subscribeOnBrowserInstallCompleted(e) {
      chrome.sidekick.update.onInstallCompleted.addListener(e);
    }
    subscribeOnBeforeShutdown(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.system.onBeforeShutdown,
        e
      );
    }
    subscribeToDOMContentLoaded(e) {
      return this.subscribeChromeEvent(
        chrome.webNavigation.onDOMContentLoaded,
        (t) => ee(e(t))
      );
    }
    subscribeToPageVisited(e) {
      let t = (i) => {
          i.discarded || (rw(i) && ee(e(i)));
        },
        r = [
          this.subscribeToTabCreated((i) => {
            t(i);
          }),
          this.subscribeToTabUpdated((i, s, a) => {
            (!oe(s, "status") && !oe(s, "url")) || t(a);
          }),
        ];
      return F(r);
    }
    subscribeToPageChanged(e) {
      let t = ["favIconUrl", "title"];
      return this.subscribeToTabUpdated((r, i, s) => {
        t.some((a) => oe(i, a)) && rw(s) && ee(e(s));
      });
    }
    subscribeToFirstFocusLeave(e) {
      let t = null,
        r = () => {
          if (t?.tab && t.tab.url && !iw(t.tab.url)) {
            let s = t.tab.id,
              a = t.at,
              n = Date.now();
            g(s, "Failed to emit focus leave: no tabId");
            let p = Ie(t.tab, ["title", "favIconUrl"]);
            this.browserService
              .getTabById(s)
              .then(
                (d) => d ?? p,
                () => p
              )
              .then((d) => e({ tab: d, visitAt: a, leaveAt: n }))
              .catch(l);
          }
        },
        i = [
          this.subscribeToTabCreated((s) => {
            s.active && (r(), (t = { at: Date.now(), tab: s }));
          }),
          this.subscribeToTabUpdated((s, a, n) => {
            if (!a.url) return;
            let p = t?.tab.id;
            (p !== void 0 && s !== p) ||
              (r(), (t = { at: Date.now(), tab: n }));
          }),
          this.subscribeToTabActivated(() => {
            r(), (t = null);
          }),
          this.subscribeToTabRemoved((s) => {
            s === t?.tab.id && (r(), (t = null));
          }),
        ];
      return () => {
        i.forEach((s) => s()), (i.length = 0);
      };
    }
    subscribeToExtensionPingPong(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.extensionPingPong.onPing,
        e
      );
    }
    subscribeToPrefsChanged(e) {
      return this.subscribeChromeEvent(
        chrome.settingsPrivate.onPrefsChanged,
        e
      );
    }
    subscribeToIdleStateChanged(e) {
      return this.subscribeChromeEvent(chrome.idle.onStateChanged, e);
    }
    subscribeToPopupClosed(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.overlay.onPopupClosed,
        e
      );
    }
    subscribeToSidebarButtonMouseEvents(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.sidebar.onButtonMouseEvent,
        e
      );
    }
    subscribeToSidebarToggleMinimized(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.sidebar.onToggleButtonsMinimized,
        e
      );
    }
    subscribeToSidebarAppMouseEvents(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.sidebar.onAppMouseEvent,
        e
      );
    }
    subscribeToSidebarAddAppClicked(e) {
      return this.subscribeChromeEvent(chrome.sidekick.sidebar.onNewApp, e);
    }
    subscribeToSidebarAppRemoved(e) {
      return this.subscribeChromeEvent(chrome.sidekick.sidebar.onAppRemoved, e);
    }
    subscribeToSidebarAppPinChanged(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.sidebar.onAppPinChanged,
        e
      );
    }
    subscribeToSidebarAppMoved(e) {
      return this.subscribeChromeEvent(chrome.sidekick.sidebar.onAppMoved, e);
    }
    subscribeToSidebarNewAppAdded(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.sidebar.onNewAppAdded,
        e
      );
    }
    subscribeToCommand(e) {
      return this.subscribeChromeEvent(chrome.commands.onCommand, (t, r) =>
        ee(e(t, r))
      );
    }
    subscribeToTabMenuItemClicked(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.tabMenu.onTabMenuItemClicked,
        (t, r) => ee(e(t, r))
      );
    }
    subscribeToContextMenuItemClicked(e) {
      return this.subscribeChromeEvent(chrome.contextMenus.onClicked, (t, r) =>
        ee(e(t, r))
      );
    }
    subscribeToVisitRemoved(e) {
      return this.subscribeChromeEvent(chrome.history.onVisitRemoved, e);
    }
    subscribeToBookmarkCreated(e) {
      return this.subscribeChromeEvent(chrome.bookmarks.onCreated, e);
    }
    subscribeToBookmarkChanged(e) {
      return this.subscribeChromeEvent(chrome.bookmarks.onChanged, e);
    }
    subscribeToBookmarkRemoved(e) {
      return this.subscribeChromeEvent(chrome.bookmarks.onRemoved, e);
    }
    subscribeToBookmarkChildrenReordered(e) {
      return this.subscribeChromeEvent(chrome.bookmarks.onChildrenReordered, e);
    }
    subscribeToBookmarkMoved(e) {
      return this.subscribeChromeEvent(chrome.bookmarks.onMoved, e);
    }
    subscribeToBookmarksImportEnded(e) {
      return this.subscribeChromeEvent(chrome.bookmarks.onImportEnded, e);
    }
    subscribeToOmniboxInputChanged(e) {
      return this.subscribeChromeEvent(chrome.omnibox.onInputChanged, e);
    }
    subscribeToOmniboxInputEntered(e) {
      return this.subscribeChromeEvent(chrome.omnibox.onInputEntered, e);
    }
    subscribeToSplitViewRequested(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.splitView.onSplitRequested,
        e
      );
    }
    subscribeToGlobalSplitViewRequested(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.splitView.onGlobalSplitRequested,
        e
      );
    }
    subscribeToGlobalSplitResized(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.splitView.onGlobalSplitResized,
        e
      );
    }
    subscribeToSplitViewChange(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.splitView.onSplitStateChanged,
        (t) => ee(e(t))
      );
    }
    subscribeToGreedyProcessFound(e) {
      return this.subscribeChromeEvent(
        chrome.processes.onGreedyProcessFound,
        e
      );
    }
    subscribeToAutofillPassword(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.system.onAutofillPassword,
        (t, r, i, s) => ee(e(t, r, i, s))
      );
    }
    subscribeToBrowserStorageChanged(e) {
      return this.subscribeChromeEvent(chrome.storage.onChanged, (t, r) =>
        ee(e(t, r))
      );
    }
    subscribeToShortcutsUpdated(e) {
      return this.subscribeChromeEvent(
        chrome.developerPrivate.onItemStateChanged,
        ({ event_type: t, extensionInfo: r }) => {
          ![
            chrome.developerPrivate.EventType.COMMAND_ADDED,
            chrome.developerPrivate.EventType.COMMAND_REMOVED,
          ].includes(t) ||
            !r?.commands ||
            e(r.commands);
        }
      );
    }
    subscribeToUserOnboarded(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.system.onOnboardingData,
        e
      );
    }
    subscribeToSidebarVisibilityChanged(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.sidebar.onVisibilityChanged,
        e
      );
    }
    subscribeToAuthRequired(e, t, r) {
      return this.subscribeChromeEvent(
        chrome.webRequest.onAuthRequired,
        e,
        t,
        r
      );
    }
    subscribeToBeforeRedirect(e, t, r) {
      return this.subscribeChromeEvent(
        chrome.webRequest.onBeforeRedirect,
        (i) => ee(e(i)),
        t,
        r
      );
    }
    subscribeToBeforeRequest(e, t, r) {
      return this.subscribeChromeEvent(
        chrome.webRequest.onBeforeRequest,
        e,
        t,
        r
      );
    }
    subscribeToImportEnded(e) {
      return this.subscribeChromeEvent(chrome.sidekick.import.onImportEnded, e);
    }
    subscribeToAlarm(e) {
      return this.subscribeChromeEvent(chrome.alarms.onAlarm, e);
    }
    subscribeToAddWorkspace(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.workspaces.onAddWorkspace,
        e
      );
    }
    subscribeToOpenWorkspaceSettings(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.workspaces.onOpenSettings,
        e
      );
    }
    subscribeToOpenWorkspace(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.workspaces.onOpenWorkspace,
        e
      );
    }
    subscribeToOpenProfileMenu(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.workspaces.onOpenProfileMenu,
        e
      );
    }
    subscribeToGlobalSearchButtonPressed(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.browserUi.onGlobalSearchButtonPressed,
        e
      );
    }
    subscribeToTabGroupCreated(e) {
      return this.subscribeChromeEvent(chrome.tabGroups.onCreated, e);
    }
    subscribeToTabGroupUpdated(e) {
      return this.subscribeChromeEvent(chrome.tabGroups.onUpdated, e);
    }
    subscribeToTabGroupRemoved(e) {
      return this.subscribeChromeEvent(chrome.tabGroups.onRemovedEx, e);
    }
    subscribeToAdBlockPageActionIconClicked(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.adBlock.onAdBlockPageActionIconClicked,
        e
      );
    }
    subscribeToChromeThemeChanged(e) {
      return this.subscribeChromeEvent(
        chrome.sidekick.browserUi.onThemeChanged,
        e
      );
    }
    subscribeChromeEvent(e, ...t) {
      if (e === void 0) return () => {};
      let [r, ...i] = t,
        s = (...a) => {
          let n;
          try {
            n = r(...a);
          } catch (p) {
            l(p);
          }
          return n;
        };
      return e.addListener(s, ...i), () => e.removeListener(s);
    }
  };
c();
c();
var ow = (o) => {
    let e = o.indexOf("#");
    return e !== -1 ? o.substring(0, e) : o;
  },
  sw = (o) => o && (Array.isArray(o) ? o.map(ow) : ow(o));
var LE = [
    "extraData",
    "hadFormInteraction",
    "hidden",
    "hideDevTools",
    "injectionPermissions",
    "notificationPermission",
    "sidekick",
    "partitionName",
  ],
  GE = (o) => LE.includes(o),
  HE = [
    /^Cannot access/,
    /^No tab with id: (\d+).$/,
    /^The tab was closed.$/,
    /^The extensions gallery cannot be scripted\.$/,
    /^The frame was removed.$/,
  ],
  aw = (o) => {
    let e = o instanceof Error && o.message;
    if (!e || !HE.some((t) => t.test(e))) throw o;
  },
  Cp = class {
    constructor(e) {
      this.performanceTransactionManager = e;
    }
    async getAllNormalWindows(e) {
      return this.getAllWindows({ populate: e, windowTypes: ["normal"] });
    }
    async getNormalWindowsById(e) {
      return this.getWindowsById({ populate: e, windowTypes: ["normal"] });
    }
    async getWindowById(e, t = {}) {
      try {
        return await this.callBrowser((r, i) => r.windows.get(e, t, i));
      } catch {
        return;
      }
    }
    async getActiveTab(e) {
      let [t] = await this.getActiveTabs(
        e ? { windowId: e } : { currentWindow: !0 }
      );
      return t;
    }
    getActiveTabs(e) {
      return this.getAllTabs({ ...e, active: !0 });
    }
    async getLastFocusedWindow(e) {
      try {
        return await this.callBrowser((t, r) =>
          e ? t.windows.getLastFocused(e, r) : t.windows.getLastFocused(r)
        );
      } catch {
        return;
      }
    }
    async getNormalLastFocusedWindow() {
      return this.getLastFocusedWindow({ windowTypes: ["normal"] });
    }
    async getLastFocusedWindowId() {
      let e = await this.getLastFocusedWindow({ windowTypes: ["normal"] });
      return e?.id === void 0 || e.id === Km ? void 0 : e.id;
    }
    async getNormalLastFocusedWindowId() {
      let e = await this.getLastFocusedWindow({ windowTypes: ["normal"] });
      return e?.id === void 0 || e.id === Km || !e.focused ? void 0 : e.id;
    }
    async getAllTabs(e = {}) {
      let [t, r] = this.splitQueryInfoBySupport(e);
      t.url = sw(t.url);
      let i = await this.callBrowser((n, p) => n.tabs.query(t, p)),
        s = Object.entries(r),
        a = (n) => s.every(([p, d]) => n[p] === d);
      return i.map((n) => this.normalizeTab(n)).filter(a);
    }
    async getTabsById(e = {}) {
      let t = await this.getAllTabs(e);
      return Object.fromEntries(
        t.map((r) => (r.id ? [r.id, r] : null)).filter(de)
      );
    }
    async getTabById(e) {
      try {
        let t = await this.callBrowser((r, i) => r.tabs.get(e, i));
        return this.normalizeTab(t);
      } catch {
        return;
      }
    }
    async updateTabById({ tabId: e, changes: t }) {
      try {
        let r = await this.callBrowser((i, s) => i.tabs.update(e, t, s));
        return r && this.normalizeTab(r);
      } catch {
        return;
      }
    }
    async activateTab(e) {
      await this.updateTabById({ tabId: e, changes: { active: !0 } });
    }
    async moveTab(e, t, r) {
      let i = await this.callBrowser((s, a) =>
        s.tabs.move(e, { index: t, windowId: r }, a)
      );
      return this.normalizeTab(i);
    }
    isNTP(e) {
      if (e.startsWith(Er.newtab)) return !0;
      let r = chrome.runtime.getManifest()?.chrome_url_overrides?.newtab;
      return r ? e.startsWith(this.getUrl(r)) : !1;
    }
    reloadTab(e) {
      return this.callBrowser((t, r) => t.tabs.reload(e, {}, r));
    }
    duplicateTab(e) {
      return this.callBrowser((t, r) => t.tabs.duplicate(e, r));
    }
    restartBrowserAfterUpdate() {
      chrome.sidekick.update.relaunchBrowser();
    }
    showDefaultBrowserPrompt() {
      chrome.sidekick.system.showDefaultBrowserPrompt();
    }
    startBrowserUpdate(e, t) {
      chrome.sidekick.update.start(e, t);
    }
    async createWindow(e) {
      return this.callBrowser((t, r) => t.windows.create(e, r));
    }
    async updateWindow(e, t) {
      return this.callBrowser((r, i) => r.windows.update(e, t, i));
    }
    async closeWindow(e) {
      return this.callBrowser((t, r) => t.windows.remove(e, r));
    }
    async focusWindow(e) {
      return this.updateWindow(e, { focused: !0 });
    }
    async createWindowWithTabs(e, t, r) {
      let s = Boolean(t.length) ? "about:blank" : void 0,
        a = await this.createWindow({ ...e, url: s }),
        n = a?.id;
      if (n) {
        let p = t.map((d) =>
          this.createTabDataFromSessionTab({
            sessionTab: d,
            isActive: d.id === r,
          })
        );
        await this.replaceAllWindowTabs(n, p);
      }
      return a;
    }
    async switchWindowTabs(e, t, r) {
      let i = e.map((s) =>
        this.createTabDataFromSessionTab({
          sessionTab: s,
          isActive: s.id === r,
        })
      );
      return this.replaceAllWindowTabs(t, i);
    }
    checkIsDefaultBrowser() {
      return this.callBrowser((e, t) =>
        e.sidekick.system.checkIsDefaultBrowser(t)
      );
    }
    startSetAsDefaultBrowser() {
      return chrome.sidekick.system.startSetAsDefaultBrowser();
    }
    async isDefaultBrowser() {
      return (await this.checkIsDefaultBrowser()) === "IsDefault";
    }
    addBrowserToAutoRun() {
      chrome.sidekick.system.addBrowserToAutoRun &&
        chrome.sidekick.system.addBrowserToAutoRun();
    }
    removeBrowserFromAutoRun() {
      chrome.sidekick.system.removeBrowserFromAutoRun &&
        chrome.sidekick.system.removeBrowserFromAutoRun();
    }
    ackShutdown() {
      return chrome.sidekick.system.ackShutdown();
    }
    async enableWindowHeadlessMode(e, t = "DESCRIBE_PLUS_BUTTON") {
      return this.callBrowser((i, s) =>
        i.sidekick.browserUi.hideWindowHead(e, !1, t, s)
      );
    }
    async disableWindowHeadlessMode(e) {
      return this.callBrowser((t, r) =>
        t.sidekick.browserUi.showWindowHead(e, r)
      );
    }
    async closeTab(e) {
      return this.callBrowser((t, r) => t.tabs.remove(e, r));
    }
    async setAllInfoAboutWorkspaces(e) {
      return this.callBrowser((t, r) => t.sidekick.workspaces.setAllInfo(e, r));
    }
    async createIconForWorkspace(e, t, r) {
      return this.callBrowser((i, s) =>
        i.sidekick.workspaces.createIcon(e, t, r, s)
      );
    }
    isReusableTab(e) {
      if (!e) return !1;
      if (e === Er.newtab) return !0;
      let r = chrome.runtime.getManifest()?.chrome_url_overrides?.newtab,
        i = (r && this.getUrl(r)) ?? null;
      return i ? e.startsWith(i) : !1;
    }
    async createTab(e) {
      try {
        return await this.unsafeCreateTab(e);
      } catch (t) {
        if (t instanceof Error && t.message === "No current window") {
          let { windowId: r, ...i } = e;
          return (
            await this.createWindow({ focused: !0 }), this.unsafeCreateTab(i)
          );
        }
        return;
      }
    }
    createNTP(e) {
      return this.createTab({ url: Er.newtab, ...e });
    }
    createActiveTab(e) {
      this.createTab({ url: e, active: !0 }).catch(l);
    }
    async unsafeCreateTab(e) {
      let t = await this.callBrowser((r, i) => r.tabs.create(e, i));
      return this.normalizeTab(t);
    }
    async createTabFromSessionTab({
      sessionTab: e,
      windowId: t,
      position: r,
      isActive: i = !1,
    }) {
      let a = {
        ...this.createTabDataFromSessionTab({ sessionTab: e, isActive: i }),
        windowId: t,
        index: r,
      };
      return this.createTab(a);
    }
    getUrl(e) {
      return chrome.runtime.getURL(e);
    }
    async getPackageDirectory() {
      return this.callBrowser((e, t) => e.runtime.getPackageDirectoryEntry(t));
    }
    getAdblockStats() {
      return this.callBrowser((e, t) =>
        e.sidekick.adblockStatistic.getAdblockStats(t)
      );
    }
    getLocalBrowserStorageSize(e) {
      return this.callBrowser((t, r) =>
        t.storage.local.getBytesInUse(e, (i) => r(i))
      );
    }
    getFromLocalBrowserStorage(e) {
      return this.callBrowser((t, r) => t.storage.local.get(e, (i) => r(i)));
    }
    saveIntoLocalBrowserStorage(e) {
      return this.callBrowser((t, r) => t.storage.local.set(e, r));
    }
    removeFromLocalBrowserStorage(e) {
      return this.callBrowser((t, r) => t.storage.local.remove(e, r));
    }
    clearLocalBrowserStorage() {
      return this.callBrowser((e, t) => e.storage.local.clear(t));
    }
    getSyncBrowserStorageSize(e) {
      return this.callBrowser((t, r) =>
        t.storage.sync.getBytesInUse(e, (i) => r(i))
      );
    }
    getFromSyncBrowserStorage(e) {
      return this.callBrowser((t, r) => t.storage.sync.get(e, (i) => r(i)));
    }
    saveIntoSyncBrowserStorage(e) {
      return this.callBrowser((t, r) => t.storage.sync.set(e, r));
    }
    removeFromSyncBrowserStorage(e) {
      return this.callBrowser((t, r) => t.storage.sync.remove(e, r));
    }
    clearSyncBrowserStorage() {
      return this.callBrowser((e, t) => e.storage.sync.clear(t));
    }
    pongBrowser() {
      this.callBrowser((e, t) => e.sidekick.extensionPingPong.pong(t)).catch(l);
    }
    requestMultipleUpload() {
      this.callBrowser((e, t) =>
        e.sidekick.crashes.requestMultipleUpload(t)
      ).catch(l);
    }
    async getNotUploadedCrashes() {
      return (
        await this.callBrowser((t, r) => t.sidekick.crashes.getCrashList(r))
      ).filter(
        ({ state: t }) => t === chrome.sidekick.crashes.UploadState.NOT_UPLOADED
      );
    }
    async loadAllCommands() {
      let e = await this.callBrowser((t, r) => t.commands.getAll(r));
      return Object.fromEntries(
        e.map((t) => (t.name ? [t.name, t] : null)).filter(de)
      );
    }
    sendMessageToTab(e, t) {
      chrome.tabs.sendMessage(e, t);
    }
    async executeScript(e, t) {
      try {
        return (
          await this.callBrowser((r, i) => {
            r.tabs.executeScript(e, t, i);
          }),
          !0
        );
      } catch (r) {
        return aw(r), !1;
      }
    }
    async executeScriptWithResponse(e, t) {
      try {
        return (
          (
            await this.callBrowser((i, s) => {
              i.tabs.executeScript(e, t, s);
            })
          )[0] ?? null
        );
      } catch (r) {
        return aw(r), null;
      }
    }
    toggleOverlay(e, t) {
      t
        ? this.callBrowser((r, i) => r.sidekick.overlay.show(e, i)).catch(fe)
        : this.callBrowser((r, i) => r.sidekick.overlay.hide(e, i)).catch(fe);
    }
    showSidecar(e, t, r, i, s) {
      this.callBrowser((a, n) =>
        a.sidekick.sidecar.show(e, t, r, i, s, n)
      ).catch(l);
    }
    hideSidecar(e, t) {
      this.callBrowser((r, i) => r.sidekick.sidecar.hide(e, t, i)).catch(l);
    }
    expandFullscreen(e) {
      this.callBrowser((t, r) =>
        t.sidekick.sidecar.expandFullscreen(e, r)
      ).catch(fe);
    }
    collapseFullscreen(e) {
      this.callBrowser((t, r) =>
        t.sidekick.sidecar.collapseFullscreen(e, r)
      ).catch(fe);
    }
    showPopup(e, t, r, i, s, a, n) {
      let d = `globalThis.sidekickPopupInfo='${JSON.stringify(n).replaceAll(
          "'",
          "\\'"
        )}';`,
        u = i ? `${d}${i}` : d,
        m = "globalThis.sidekickPopupInfo=undefined;",
        y = s ? `${m}${s}` : m;
      this.callBrowser((b, v) =>
        b.sidekick.overlay.showPopup(e, "app", r, u, y, t, a, v)
      ).catch(fe);
    }
    hidePopup(e, t) {
      this.callBrowser((r, i) => r.sidekick.overlay.hidePopup(e, t, i)).catch(
        l
      );
    }
    closeAllPopups() {
      return this.callBrowser((e, t) => {
        e.sidekick.overlay.hideAllPopups(), t();
      });
    }
    async closeAllOverlays() {
      (await this.getAllWindows({ windowTypes: ["normal"] })).forEach((t) => {
        t.id === void 0 || t.incognito || this.toggleOverlay(t.id, !1);
      });
    }
    getAllPrefs() {
      return this.callBrowser((e, t) => {
        e.settingsPrivate.getAllPrefs(t);
      });
    }
    getPref(e) {
      return this.callBrowser((t, r) => t.settingsPrivate.getPref(e, r));
    }
    setPref(e, t) {
      return this.callBrowser((r, i) => r.settingsPrivate.setPref(e, t, i));
    }
    async getAllProcesses() {
      let e = chrome.processes.onUpdatedWithMemory;
      return new Promise((t) => {
        e.addListener(function r(i) {
          e.removeListener(r), t(Object.values(i));
        });
      });
    }
    async getProcessByTabId(e) {
      return (
        (await this.getAllProcesses()).find((r) =>
          r.tasks.some((i) => i.tabId === e)
        ) ?? null
      );
    }
    async getProfileName() {
      let { value: e } = await this.getPref("profile.name");
      return e;
    }
    getExtTabsCount(e) {
      let t = chrome.runtime.getManifest(),
        r = this.getUrl(t?.chrome_url_overrides?.newtab || ""),
        i = this.getUrl("dist/general.html");
      return Object.values(e).filter((s) =>
        [Er.newtab, i, r].some((a) => s?.url?.startsWith(a))
      ).length;
    }
    async openHomeTab() {
      let e = await this.getLastFocusedWindowId(),
        t = await this.getTabsById({ windowId: e, url: Er.newtab }),
        r = Object.values(t);
      if (r.length) {
        let [i] = r;
        if (i?.id)
          return await this.activateTab(i.id), { tabId: i.id, isFocus: !0 };
      } else return { tabId: (await this.createNTP())?.id, isFocus: !1 };
      return { tabId: void 0, isFocus: !1 };
    }
    processTabAfterExtReload(e) {
      !(e.url && this.isNTP(e.url)) ||
        !this.isBrokenNTP(e.title, e.url) ||
        this.replaceBrokenNTP(e).catch(l);
    }
    restartExtension() {
      this.callBrowser((e, t) =>
        e.sidekick.system.restartExtension(e.runtime.id, t)
      ).catch(l);
    }
    updateSidebarState(e, t) {
      return this.callBrowser((r, i) =>
        r.sidekick.sidebar.updateState(e, JSON.stringify(t), i)
      );
    }
    getManifestVersion() {
      return ca();
    }
    async getBrowserVersionFromSidekick() {
      return this.callBrowser((e, t) => {
        e.sidekick.system.getProductVersion(t);
      });
    }
    async getCPUArchitecture() {
      return this.callBrowser((e, t) => {
        e.sidekick.system.getCPUArchitecture(t);
      });
    }
    async getDeviceId() {
      return this.callBrowser((e, t) => {
        e?.sidekick?.system?.getDeviceId
          ? e.sidekick.system.getDeviceId(t)
          : t("");
      });
    }
    async getVersionInfo() {
      return this.callBrowser((e, t) => {
        e.sidekick.system.getVersionInfo(t);
      });
    }
    async getProfileStatistics() {
      return this.callBrowser((e, t) => {
        e.sidekick.system.getProfileStatistics(t);
      });
    }
    appendTabMenuItems(e) {
      return this.callBrowser((t, r) =>
        t.sidekick.tabMenu.appendMenuItems(e, r)
      );
    }
    async getWholeChromeHistory() {
      return this.callBrowser((e, t) => {
        e.history.search(
          { text: "", startTime: Date.now() - lb, maxResults: pb },
          t
        );
      });
    }
    async getWholeBookmarks() {
      return this.callBrowser((e, t) => {
        e.bookmarks.getRecent(1e4, t);
      });
    }
    getBookmarksTree() {
      return this.callBrowser((e, t) => {
        e.bookmarks.getTree(t);
      });
    }
    createBookmark(e) {
      return this.callBrowser((t, r) => {
        t.bookmarks.create(e, r);
      });
    }
    updateBookmark(e, t) {
      return this.callBrowser((r, i) => {
        r.bookmarks.update(e, t, i);
      });
    }
    removeBookmark(e) {
      return this.callBrowser((t, r) => {
        t.bookmarks.remove(e, r);
      });
    }
    removeBookmarkTree(e) {
      return this.callBrowser((t, r) => {
        t.bookmarks.removeTree(e, r);
      });
    }
    moveBookmark(e, t) {
      return this.callBrowser((r, i) => {
        r.bookmarks.move(e, t, i);
      });
    }
    getVisitsByUrls(e) {
      return Promise.all(
        e.map(async (t) => {
          let r = await this.callBrowser((i, s) => {
            i.history.getVisits({ url: t }, s);
          });
          return {
            url: t,
            visits: r.map((i) => Math.floor(i.visitTime || 0)).filter(Boolean),
          };
        })
      );
    }
    getSearchEngine() {
      return this.callBrowser((e, t) => {
        e.sidekick.system.getSearchEngine(t);
      });
    }
    getBrowserPath() {
      return this.callBrowser((e, t) => {
        e.sidekick.system.getBrowserPath(t);
      });
    }
    openSearchPage(e) {
      return this.callBrowser((t, r) => t.search.query({ text: e }, r));
    }
    normalizeTab(e) {
      return { hidden: !1, partitionName: "", ...e };
    }
    setGlobalSplitView(e, t) {
      this.callBrowser((r, i) => r.sidekick.splitView.setGlobal(e, t, i)).catch(
        l
      );
    }
    resetGlobalSplitView(e) {
      this.callBrowser((t, r) => t.sidekick.splitView.resetGlobal(e, r)).catch(
        l
      );
    }
    addLocalSplitView(e, t) {
      this.callBrowser((r, i) =>
        r.sidekick.splitView.addLocal({ left: e, right: t }, i)
      ).catch(l);
    }
    resetLocalSplitView(e) {
      this.callBrowser((t, r) => t.sidekick.splitView.removeLocal(e, r)).catch(
        l
      );
    }
    async showSplitViewMenu() {
      let e = await this.getNormalLastFocusedWindowId();
      e &&
        this.callBrowser((t, r) =>
          t.sidekick.splitView.showMenuOnToolbarButton(e, r)
        ).catch(l);
    }
    async getSplitState() {
      return this.callBrowser((e, t) => {
        e.sidekick.splitView.getState(t);
      });
    }
    getRuntimeId() {
      return chrome.runtime.id;
    }
    getIdleState(e = 60) {
      return this.callBrowser((t, r) => {
        t.idle.queryState(e, r);
      });
    }
    async discardTabById(e) {
      try {
        let t = await this.callBrowser((r, i) => {
          r.tabs.discard(e, i);
        });
        return this.normalizeTab(t);
      } catch (t) {
        return (
          fe(
            new L(
              t instanceof Error ? t.message : `Can't discard tab with id ${e}`,
              { extra: { tab: await this.getTabById(e) } }
            )
          ),
          null
        );
      }
    }
    async removeRecentlyClosedItem(e) {
      try {
        return await this.callBrowser((t, r) => t.sessions.removeItem(e, r));
      } catch {
        return;
      }
    }
    getRecentlyClosed(e = {}) {
      return this.callBrowser((t, r) => t.sessions.getRecentlyClosed(e, r));
    }
    setCPUGreedyThresholds(e, t, r) {
      this.callBrowser((i, s) =>
        i.processes.setCPUGreedyThresholds(e, t, r, s)
      ).catch(l);
    }
    async getTabsForMarketplace() {
      return this.getAllTabs({
        windowId: chrome.windows.WINDOW_ID_CURRENT,
        url: "*://*/*",
      });
    }
    setAutofillPasswordForm(e, t, r, i, s, a) {
      this.callBrowser((n, p) => {
        n.sidekick.system.setAutofillPasswordForm(e, t, r, i, s, a), p();
      }).catch(l);
    }
    clearPartition(e, t) {
      return this.callBrowser((r, i) =>
        r.sidekick.workspaces.clearStoragePartition(e, t, i)
      );
    }
    clearPartitionForWorkspace(e) {
      return this.callBrowser((t, r) =>
        t.sidekick.workspaces.clearStoragePartition(e, "", r)
      );
    }
    signOut(e, t) {
      return this.callBrowser((r, i) =>
        r.sidekick.system.signOut(e, !0, !0, !0, !0, t ?? !1, i)
      );
    }
    addShortcut(e, t) {
      this.callBrowser((r, i) => r.sidekick.system.addShortcut(e, t, i)).catch(
        l
      );
    }
    notifyExtensionReady() {
      chrome.sidekick.system.notifyExtensionReady();
    }
    handleAuth({ userId: e, email: t, name: r, avatar: i }) {
      return this.callBrowser((s, a) =>
        s.sidekick.system.handleAuth(
          { userId: e, email: t, name: r, avatar: i },
          a
        )
      );
    }
    resetAuth() {
      return this.callBrowser((e, t) => e.sidekick.system.resetAuth(t));
    }
    setSidebarVisible(e, t) {
      return this.callBrowser((r, i) => r.sidekick.sidebar.setVisible(e, t, i));
    }
    scrollSidebarToApp(e, t) {
      return this.callBrowser((r, i) =>
        r.sidekick.sidebar.scrollToApp(e, t, i)
      );
    }
    getSidebarVisibilityMap() {
      return this.callBrowser((e, t) => e.sidekick.sidebar.getVisibilityMap(t));
    }
    setProxyConfig(e) {
      chrome.proxy.settings.set({ ...e });
    }
    setProxyCredentials({ url: e, username: t, password: r }) {
      return this.callBrowser((i, s) =>
        i.sidekick.system.setSidekickProxyCredentials(e, t, r, s)
      );
    }
    clearProxyConfig() {
      chrome.proxy.settings.clear({});
    }
    launchWebAuthFlow(e, t) {
      return this.callBrowser((r, i) =>
        r.identity.launchWebAuthFlow({ url: e, interactive: t }, i)
      );
    }
    getPendingWindowOnCreatedEvents() {
      return this.callBrowser((e, t) => {
        typeof chrome.windows.getPendingOnCreatedEvents == "function"
          ? e.windows.getPendingOnCreatedEvents?.(t)
          : t([]);
      });
    }
    createAlarm(e, t) {
      chrome.alarms.create(e, t);
    }
    getAlarmByName(e) {
      return this.callBrowser((t, r) => {
        t.alarms.get(e, r);
      });
    }
    clearAlarmByName(e) {
      return this.callBrowser((t, r) => {
        t.alarms.clear(e, r);
      });
    }
    stopNotificationForSite(e, t) {
      return this.callBrowser((r, i) => {
        t
          ? r.contentSettings.notifications.set(
              { primaryPattern: e, setting: "block" },
              i
            )
          : r.contentSettings.notifications.clear({}, i);
      });
    }
    stopAllNotifications(e) {
      return this.stopNotificationForSite("<all_urls>", e);
    }
    getAllTabGroups() {
      return this.callBrowser((e, t) => {
        e.tabGroups.query({}, t);
      });
    }
    createTabGroup(e, t, r) {
      return this.callBrowser((i, s) => {
        let a = {
          createProperties: { windowId: e, groupExtraData: r },
          tabIds: t,
        };
        i.tabs.group(a, s);
      });
    }
    addTabsToExistingTabGroup(e, t) {
      return this.callBrowser((r, i) => {
        let s = { groupId: t, tabIds: e };
        r.tabs.group(s, i);
      });
    }
    async ungroupTabs(e) {
      return this.callBrowser((t, r) => t.tabs.ungroup(e, r));
    }
    updateTabGroup(e, t) {
      return this.callBrowser((r, i) => {
        r.tabGroups.update(e, t, i);
      });
    }
    async getAllWindows(e = {}) {
      return this.callBrowser((t, r) => t.windows.getAll(e, r));
    }
    async getWindowsById(e = {}) {
      let t = await this.getAllWindows(e);
      return Object.fromEntries(
        t.map((r) => (r.id ? [r.id, r] : null)).filter(de)
      );
    }
    async onAdBlockPopupClosed(e) {
      return this.callBrowser((t, r) => {
        t.sidekick.adBlock.onAdBlockPopupClosed(e, r);
      });
    }
    createContextMenu(e) {
      return this.callBrowser((t, r) => {
        t.contextMenus.create(e, r);
      });
    }
    updateContextMenu(e, t) {
      return this.callBrowser((r, i) => {
        r.contextMenus.update(e, t, i);
      });
    }
    removeContextMenu(e) {
      return this.callBrowser((t, r) => {
        t.contextMenus.remove(e, r);
      });
    }
    clearContextMenus() {
      return this.callBrowser((e, t) => {
        e.contextMenus.removeAll(t);
      });
    }
    applyPolicy(e) {
      return this.callBrowser((t, r) => {
        t.sidekick.system.applyPolicy(e, r);
      });
    }
    replaceAllWindowTabs(e, t) {
      return this.callBrowser((r, i) => {
        r.tabs.replaceAllInWindow(e, t, i);
      });
    }
    createTabDataFromSessionTab({ sessionTab: e, isActive: t = !1 }) {
      e.url ||
        l(
          new L("Switching to session tab with empty url", {
            extra: { sessionTab: e },
          })
        );
      let r = { sessionTabId: e.id };
      return {
        discarded: !0,
        url: e.url,
        partitionName: e.partitionId || void 0,
        favIconUrl: e.favIconUrl || void 0,
        title: e.title || void 0,
        extraData: JSON.stringify(r),
        active: t,
        pinned: e.pinned,
      };
    }
    splitQueryInfoBySupport(e) {
      let t = {},
        r = {};
      return (
        Object.entries(e).forEach(([i, s]) => {
          GE(i) ? (r[i] = s) : (t[i] = s);
        }),
        [t, r]
      );
    }
    isBrokenNTP(e, t) {
      return e === mr.newtab && t === Er.newtab;
    }
    async replaceBrokenNTP(e) {
      e.id &&
        (await this.closeTab(e.id),
        await this.createTab({
          url: Er.newtab,
          active: e.active,
          index: e.index,
        }));
    }
    async callBrowser(e) {
      return new Promise((t, r) => {
        let i = new Error(),
          s = [],
          a = (p) => {
            s.forEach((u) => u.finish());
            let { lastError: d } = chrome.runtime;
            d
              ? ((i.message = d.message || "Chrome Error without message"),
                r(i))
              : t(p);
          },
          n = this.createSpy(chrome, (p, d) => {
            this.performanceTransactionManager.forEach((b) => {
              let v = p.join("."),
                S = "chrome",
                w = b.startChild({ op: S, description: v }),
                T = `${S}.${v}`,
                I = b.data[T] ?? 0;
              b.setData(T, I + 1), s.push(w);
            });
            let u = p.slice(0, -1).reduce((b, v) => b[v], chrome),
              m = p[p.length - 1],
              y = u[m];
            y ||
              l(
                new L("Creating a spy on chrome call has failed", {
                  level: "error",
                  extra: {
                    obj: u,
                    accessChain: p,
                    fnName: m,
                    fn: y,
                    argumentList: d,
                  },
                })
              ),
              y.apply(u, d.slice());
          });
        e(n, a);
      });
    }
    createSpy(e, t, r = []) {
      return new Proxy(e || Object.freeze(Kr), {
        get: (i, s) => {
          let a = i[s];
          return (Ge(a) || typeof a == "function") && a !== null
            ? this.createSpy(a, t, [...r, s])
            : a;
        },
        apply: (i, s, a) => {
          t(r, a);
        },
      });
    }
  };
c();
var _p = class {
  lockedTabIds = new Map();
  constructor(e) {
    e.subscribeToTabRemoved((t) => this.lockedTabIds.delete(t));
  }
  lock(e) {
    let t = this.lockedTabIds.get(e);
    return t
      ? t.wait().then(() => this.lock(e))
      : (this.lockedTabIds.set(e, new cb()), Promise.resolve());
  }
  unlock(e) {
    let t = this.lockedTabIds.get(e);
    return t ? (this.lockedTabIds.delete(e), t.mark(!0), !0) : !1;
  }
};
c();
c();
var VE = 5,
  Fp = {
    UpdateStatusChanged: "update-status-changed",
    AvailableUpdateChanged: "available-update-changed",
  },
  Mp = class {
    constructor(e, t, r, i, s) {
      this.systemInfoService = e;
      this.backendService = t;
      this.browserService = r;
      this.isBrowserSupportAutoUpdate() &&
        (s.subscribeOnBrowserUpdateCompleted(() =>
          this.setUpdateStatus("Completed")
        ),
        s.subscribeOnBrowserUpdateFailed(() => {
          this.resetUpdateStatus();
        }),
        s.subscribeOnBrowserDownloadStarted(() => {
          i.sendAnalyticsEvent("update.download-started", void 0);
        }),
        s.subscribeOnBrowserDownloadCompleted(() => {
          i.sendAnalyticsEvent("update.download-completed", void 0);
        }),
        s.subscribeOnBrowserInstallStarted(() => {
          i.sendAnalyticsEvent("update.install-started", void 0);
        }),
        s.subscribeOnBrowserInstallCompleted((n) => {
          i.sendAnalyticsEvent("update.install-completed", { code: n });
        }));
      let a = () => {
        this.checkUpdate().catch(l);
      };
      setTimeout(a, ye(1)), setInterval(a, xe(12));
    }
    emitter = new A();
    status = "NotAvailable";
    availableUpdate = null;
    incorrectDirFailuresCount = 0;
    logger = x.createInstance("browser");
    onUpdateStatusChanged(e) {
      return this.emitter.on(Fp.UpdateStatusChanged, e);
    }
    onAvailableUpdateChanged(e) {
      return this.emitter.on(Fp.AvailableUpdateChanged, e);
    }
    continueUpdating() {
      if (
        (g(
          this.canAutoUpdate(),
          "Cannot continue updating if autoupdate is unavailable"
        ),
        this.getIsUpdateCompleted())
      ) {
        this.browserService.restartBrowserAfterUpdate();
        return;
      }
      if (this.status === "Available") {
        this.startBrowserUpdate();
        return;
      }
      this.logger.error(
        "Someone is calling to continue updating, but there is no reason to continue"
      );
    }
    getUpdateInfo() {
      return this.status === "NotAvailable"
        ? null
        : this.canAutoUpdate()
        ? {
            status: this.status,
            text: this.getUpdateText(),
            buttonText: this.getUpdateButtonText(),
            manualDownloadLink: null,
          }
        : this.availableUpdate
        ? {
            status: this.status,
            text: this.availableUpdate.text || "Please update browser",
            buttonText: "Download update",
            manualDownloadLink: this.availableUpdate.url,
          }
        : null;
    }
    getIsUpdateCompleted() {
      return this.status === "Completed";
    }
    getUpdateText() {
      switch (this.status) {
        case "Available":
          return (
            this.availableUpdate?.text || "New browser version is available"
          );
        case "InProgress":
          return "Please wait while we download the update";
        case "Completed":
          return "Please update browser";
        default:
          throw new TypeError(`Unhandled case: ${this.status}`);
      }
    }
    getUpdateButtonText() {
      switch (this.status) {
        case "Available":
        case "Completed":
          return "Update";
        case "InProgress":
          return "Downloading";
        default:
          throw new TypeError(`Unhandled case: ${this.status}`);
      }
    }
    resetUpdateStatus() {
      this.setUpdateStatus(this.availableUpdate ? "Available" : "NotAvailable");
    }
    setUpdateStatus(e) {
      (this.status = e),
        this.logger.info(`Browser update status changed, now: ${e}`),
        this.emitter.emit(Fp.UpdateStatusChanged, e);
    }
    async checkUpdate() {
      (this.availableUpdate = await this.fetchAvailableUpdate()),
        this.emitter.emit(Fp.AvailableUpdateChanged, this.availableUpdate),
        !["InProgress", "Completed"].includes(this.status) &&
          (this.resetUpdateStatus(),
          this.availableUpdate && this.startBrowserUpdate());
    }
    async fetchAvailableUpdate() {
      let e = await this.backendService.extension.getBrowserUpdate(
        this.systemInfoService.browserVersion,
        this.systemInfoService.extensionVersion,
        this.systemInfoService.isMacM1
      );
      return e.url
        ? { url: e.url, text: e.text ?? "", canAutoUpdate: e.can_autoupdate }
        : null;
    }
    hasReachedFailuresLimit() {
      return this.incorrectDirFailuresCount >= VE;
    }
    isBrowserSupportAutoUpdate() {
      return !this.systemInfoService.isLinux;
    }
    canAutoUpdate() {
      return Boolean(
        this.isBrowserSupportAutoUpdate() &&
          this.availableUpdate?.canAutoUpdate &&
          !this.hasReachedFailuresLimit()
      );
    }
    startBrowserUpdate() {
      let e = this.availableUpdate?.url;
      if (
        (g(
          e,
          "Couldn't start browser update because it has no URL to download update"
        ),
        !this.canAutoUpdate())
      ) {
        this.setUpdateStatus("Completed");
        return;
      }
      this.setUpdateStatus("InProgress"),
        this.browserService.startBrowserUpdate(
          e,
          ({ success: t, reason: r }) => {
            if (!t) {
              if (r === "InProgress") {
                this.logger.warn("Browser update is already in progress");
                return;
              }
              r === "CannotUpdateInThisDir"
                ? ((this.incorrectDirFailuresCount += 1),
                  this.reportCannotUpdateInThisDir().catch(l))
                : this.reportUpdateError(r),
                this.resetUpdateStatus();
            }
          }
        );
    }
    async reportCannotUpdateInThisDir() {
      let e = await this.browserService.getBrowserPath();
      this.reportUpdateError("CannotUpdateInThisDir", { browserFullPath: e });
    }
    reportUpdateError(e, t) {
      l(new L("Failed to start updating", { tags: { reason: e }, extra: t }));
    }
  };
c();
var xp = class {
  constructor(e, t, r) {
    this.browserEventsService = e;
    this.browserService = t;
    this.authService = r;
    this.browserEventsService.subscribeToMessageExternal((i, s, a) => {
      if (this.isMessage(i)) {
        if (this.isShowLaunchpadMessage(i))
          this.browserService.openHomeTab().catch(l);
        else if (this.isRequestAuthToken(i)) {
          let n = this.authService.getToken();
          a(n);
        }
      }
    });
  }
  isShowLaunchpadMessage(e) {
    return e.type === "SHOW_LAUNCHPAD";
  }
  isRequestAuthToken(e) {
    return e.type === "REQUEST_AUTH_TOKEN";
  }
  isMessage(e) {
    return (
      Ge(e) &&
      oe(e, "type") &&
      (typeof e.type == "string" || typeof e.type == "number")
    );
  }
};
c();
var Wp = class {
  constructor(e) {
    this.browserService = e;
  }
  async getTabExtraDataByTabId(e) {
    let t = await this.browserService.getTabById(e);
    return t ? this.getTabExtraData(t) : null;
  }
  getTabExtraData({ extraData: e }) {
    let t = Oe(e);
    return t
      ? { app: t.app, sessionTabId: t.sessionTabId ?? t.sessionLinkId }
      : null;
  }
  async ensureTabExtraData(e) {
    await Promise.all(
      e.map(async (t) => {
        if (!t.browserId) return;
        let r = { sessionTabId: t.id };
        await this.browserService.updateTabById({
          tabId: t.browserId,
          changes: { extraData: await this.createTabExtraData(r, t.browserId) },
        });
      })
    );
  }
  async createTabExtraData(e, t) {
    let i = {
      ...(t !== void 0 ? await this.getTabExtraDataByTabId(t) : null),
      ...e,
    };
    return JSON.stringify(dr(i));
  }
  getTabGroupExtraData(e) {
    let t = Oe(e.extraData);
    return t ? { sessionTabGroupId: t.sessionTabGroupId } : null;
  }
  async ensureTabGroupExtraData(e) {
    await Promise.all(
      e.map(async (t) => {
        if (!t.browserId) return;
        let r = this.createTabGroupExtraData(t.id);
        try {
          await this.browserService.updateTabGroup(t.browserId, r);
        } catch (i) {
          if (
            i instanceof Error &&
            i.message.startsWith("Tabs cannot be edited right now")
          ) {
            this.browserService.updateTabGroup(t.browserId, r).catch(fe);
            return;
          }
          fe(i);
        }
      })
    );
  }
  createTabGroupExtraData(e) {
    return { extraData: JSON.stringify({ sessionTabGroupId: e }) };
  }
  getWindowExtraData(e) {
    return Oe(e.extraData);
  }
  async ensureWindowExtraData(e) {
    await Promise.all(
      e.map(async ({ session: t, windowId: r }) => {
        if (!r) return;
        let i = this.createWindowData(t.id, !1);
        await this.browserService.updateWindow(r, i);
      })
    );
  }
  createWindowData(e, t = !1, r = 0) {
    let i = {
      sessionId: e,
      createdProgrammatically: t,
      hasBlankTabAfterCreating: Boolean(r),
    };
    return { extraData: JSON.stringify(i) };
  }
};
c();
c();
var nw = /: Sidekick$/,
  Dp = (o) =>
    o.type === "extension" ||
    o.tasks.some((e) => e.title.startsWith("Extension:") || nw.test(e.title)),
  cw = (o) => o.tasks.some((e) => nw.test(e.title));
var $E = -1,
  KE = Qy(12),
  Up = class {
    constructor(e, t, r) {
      this.browserService = e;
      this.tabsConsumedMemoryStatistic = r;
      let i = Ys(() => {
          this.getSavedMemory()
            .then((a) => {
              (this.savedMemory = a), this.emitter.emit("report", a);
            })
            .catch(l);
        }, KE),
        s = () => {
          this.emitter.size() && i();
        };
      i(),
        (this.subscriptions = [
          t.subscribeToTabCreated(s),
          t.subscribeToTabUpdated(s),
          t.subscribeToTabRemoved(s),
          t.subscribeToTabReplaced(s),
        ]);
    }
    savedMemory = 0;
    emitter = new A();
    subscriptions;
    dispose() {
      this.subscriptions.forEach((e) => e()), (this.subscriptions.length = 0);
    }
    subscribeToMergedMemory(e) {
      return this.emitter.on("report", e);
    }
    async getSavedMemory() {
      return (await this.getRendererProcessesWithTabs())
        .map((t) => this.calculateProcessSavedMemory(t))
        .reduce((t, r) => t + r, 0);
    }
    async getRendererProcessesWithTabs() {
      let [e, t, r] = await Promise.all([
        this.browserService.getAllProcesses(),
        this.browserService.getProfileName(),
        this.browserService.getTabsById(),
      ]);
      return e
        .filter(
          (i) =>
            i.profile === t &&
            i.type === tn.RENDERER &&
            i.tasks.filter((s) => s.tabId).length > 0 &&
            !Dp(i)
        )
        .map((i) => {
          let a = i.tasks
            .map((n) => n.tabId)
            .filter(de)
            .map((n) => r[n])
            .filter(de);
          return { ...i, tabs: a };
        });
    }
    calculateProcessSavedMemory(e) {
      let { tabs: t } = e,
        r = t.length;
      if (r <= 1) return 0;
      let i = this.getKnownProcessMemory(e);
      if (!i) return 0;
      let s = t.find((d) => d.url);
      if (!s?.url) return 0;
      let a = At(s.url),
        n = a ? this.tabsConsumedMemoryStatistic.getAvgPrivateMemory(a) : 0,
        p = Math.floor(n && n * r >= i ? n * r - i : i * (r - 1) * 0.3);
      return p > 0 ? p : 0;
    }
    getKnownProcessMemory(e) {
      let { privateMemory: t } = e;
      return t !== void 0 && t !== $E ? t : null;
    }
  };
c();
var co = class {
  tabsByWindowId = {};
  detachInfo = {};
  static async build(e, t) {
    let r = await e.getNormalWindowsById(!0);
    return new co(t, r);
  }
  constructor(e, t) {
    (this.tabsByWindowId = Object.fromEntries(
      Object.values(t).map(
        (r) => (
          g(r.id, "Tab strip observer: no window id"),
          g(r.tabs, "Tab strip observer: no window tabs"),
          [
            r.id,
            r.tabs.reduce(
              (i, s) => (
                s.id && i.push({ tabId: s.id, isHidden: s.hidden }), i
              ),
              []
            ),
          ]
        )
      )
    )),
      e.subscribeToNormalWindowCreated(({ id: r }) => this.onWindowCreated(r)),
      e.subscribeToTabCreated(this.onTabCreated.bind(this)),
      e.subscribeToTabUpdated(this.onTabUpdated.bind(this)),
      e.subscribeToTabRemoved(this.onTabRemoved.bind(this)),
      e.subscribeToTabReplaced(this.onTabReplaced.bind(this)),
      e.subscribeToTabAttached(this.onTabAttached.bind(this)),
      e.subscribeToTabDetached(this.onTabDetached.bind(this)),
      e.subscribeToTabMoved(this.onTabMoved.bind(this));
  }
  getIndexForInternalIndex(e, t) {
    let r = this.tabsByWindowId[e] ?? [],
      s = r.filter((a) => !a.isHidden)[t] ?? r.at(-1);
    return g(s, "targetTab is undefined"), r.indexOf(s);
  }
  getInternalIndexForIndex(e, t) {
    return (this.tabsByWindowId[e] ?? [])
      .filter((i) => !i.isHidden)
      .findIndex((i) => i.tabId === t);
  }
  isTabOfNormalWindow(e) {
    return Boolean(this.tabsByWindowId[e.windowId]);
  }
  getTabInfoForWindow(e) {
    return this.tabsByWindowId[e];
  }
  getTabInfoByWindowId() {
    return this.tabsByWindowId;
  }
  onWindowCreated(e) {
    e && (this.tabsByWindowId[e] = []);
  }
  onTabCreated(e) {
    this.addTabInfo(e);
  }
  onTabUpdated(e, t, r) {
    (!oe(t, "hidden") && (!oe(t, "status") || t.status !== "loading")) ||
      this.updateTabInfo(r);
  }
  onTabRemoved(e, t) {
    this.removeTabInfo(e, t.windowId);
  }
  onTabReplaced(e, t) {
    Object.entries(this.tabsByWindowId).forEach(([r, i]) => {
      let s = i.map((a) => (a.tabId === t ? { ...a, tabId: e } : a));
      this.tabsByWindowId[Number(r)] = s;
    });
  }
  onTabMoved(e, t) {
    let { windowId: r, toIndex: i, fromIndex: s } = t,
      a = this.tabsByWindowId[r];
    if (!a) return;
    let n = a.find((m) => m.tabId === e);
    if (!n) return;
    let p = { tabId: e, isHidden: n.isHidden },
      u = i > s ? i + 1 : i;
    this.tabsByWindowId[r] = [...a.slice(0, u), p, ...a.slice(u)].filter(
      (m) => m !== n
    );
  }
  onTabDetached(e, t) {
    this.detachInfo[e] = t;
  }
  onTabAttached(e, t) {
    let r = this.detachInfo[e];
    if (!r) return;
    delete this.detachInfo[e];
    let i = this.tabsByWindowId[r.oldWindowId]?.find((p) => p.tabId === e);
    if (!i) return;
    let s = t.newWindowId,
      n = [...(this.tabsByWindowId[s] ?? [])];
    n.splice(t.newPosition, 0, i),
      (this.tabsByWindowId[s] = n),
      this.removeTabInfo(i.tabId, r.oldWindowId);
  }
  addTabInfo(e) {
    let { windowId: t } = e,
      r = this.tabsByWindowId[t];
    if (!r) return;
    let i = [...r];
    i.splice(e.index, 0, { tabId: e.id, isHidden: e.hidden }),
      (this.tabsByWindowId[t] = i);
  }
  updateTabInfo(e) {
    let { windowId: t } = e,
      r = this.tabsByWindowId[t];
    r &&
      (this.tabsByWindowId[t] = r.map((i) =>
        i.tabId === e.id ? { tabId: e.id, isHidden: e.hidden } : i
      ));
  }
  removeTabInfo(e, t) {
    let r = this.tabsByWindowId[t];
    if (!r) return;
    let i = r.filter((s) => s.tabId !== e);
    this.tabsByWindowId[t] = i;
  }
};
c();
var Op = class {
  constructor(e, t, r) {
    this.browserService = e;
    this.browserEventsService = t;
    this.browserStorage = r;
    this.init().catch(l);
  }
  records = {};
  emitter = new A();
  getAvgPrivateMemory(e) {
    return this.records[e];
  }
  subscribeToStatisticLoaded(e) {
    return this.emitter.on("loaded", e);
  }
  setAvgPrivateMemory(e, t) {
    let r = this.records[e];
    (this.records[e] = r ? Math.floor((t + r) / 2) : t), this.saveToStorage();
  }
  async init() {
    let e = await this.browserStorage.getGlobalItem(
      "avg-private-memory-stat-key"
    );
    if (!e) {
      this.browserEventsService.subscribeToDOMContentLoaded(({ tabId: t }) =>
        this.collectAvgMemoryUsage(t)
      );
      return;
    }
    Object.entries(e).forEach(([t, r]) => {
      let i = this.records[t];
      this.records[t] = i ? Math.floor((r + i) / 2) : r;
    }),
      this.browserEventsService.subscribeToDOMContentLoaded(({ tabId: t }) =>
        this.collectAvgMemoryUsage(t)
      ),
      this.emitter.emit("loaded");
  }
  async collectAvgMemoryUsage(e) {
    let t = await this.browserService.getTabById(e);
    if (!t?.url) return;
    let r = At(t.url);
    if (!r) return;
    let i = await this.browserService.getProcessByTabId(e);
    if (
      !(
        i?.privateMemory === void 0 || i.tasks.filter((a) => a.tabId).length > 1
      ) &&
      !Dp(i)
    ) {
      if (i.privateMemory <= 0) {
        setTimeout(() => {
          this.collectAvgMemoryUsage(e).catch(l);
        }, ce(1));
        return;
      }
      this.setAvgPrivateMemory(r, i.privateMemory);
    }
  }
  flushToStorage() {
    return this.browserStorage.setGlobalItem(
      "avg-private-memory-stat-key",
      this.records
    );
  }
  saveToStorage = yt(() => {
    this.flushToStorage().catch(l);
  }, ce(1));
};
c();
var jp = class {
  constructor(e, t, r, i, s) {
    this.browserService = e;
    this.tabStripObserver = r;
    this.userSettingsRepository = i;
    this.extraDataService = s;
    let a = (n) => {
      this.handleUpdate(n).catch(l);
    };
    t.subscribeToTabCreated((n) => a(n.windowId)),
      t.subscribeToTabRemoved((n, p) => {
        p.isWindowClosing || this.handleTabRemovedUpdate(p.windowId).catch(l);
      }),
      t.subscribeToTabUpdated((n, p, d) => a(d.windowId)),
      t.subscribeToTabAttached((n, p) => a(p.newWindowId)),
      t.subscribeToTabActivated(({ windowId: n }) => a(n)),
      t.subscribeToWindowRemoved(this.removeIsHeadlessEnabled.bind(this)),
      W.onSeveral(Ce, (n) => {
        n.isHeadlessModeEnabled !== void 0 && this.checkAllWindows().catch(l);
      }),
      this.checkAllWindows().catch(l);
  }
  emitter = new A();
  isHeadlessEnabledByWindowId = {};
  isHeadlessPermanent = !1;
  lockedWindowIds = new Set();
  logger = x.createInstance("browser");
  enablePermanentHeadless() {
    (this.isHeadlessPermanent = !0), this.checkAllWindows().catch(l);
  }
  disablePermanentHeadless() {
    (this.isHeadlessPermanent = !1), this.checkAllWindows().catch(l);
  }
  onChanged(e) {
    return this.emitter.on("headless-mode-changed", (...t) => ee(e(...t)));
  }
  lockWindow(e) {
    this.lockedWindowIds.add(e);
  }
  unlockWindow(e) {
    this.lockedWindowIds.delete(e);
  }
  enableHeadlessMode(e, t = "DESCRIBE_PLUS_BUTTON") {
    return (
      this.lockWindow(e),
      (this.isHeadlessEnabledByWindowId[e] = !0),
      this.browserService.enableWindowHeadlessMode(e, t)
    );
  }
  recalculateHeadlessMode(e, t = !1) {
    return this.unlockWindow(e), this.handleUpdate(e, t);
  }
  async checkAllWindows() {
    let e = this.tabStripObserver.getTabInfoByWindowId();
    await Promise.all(
      Object.keys(e).map((t) => this.handleUpdate(Number(t)).catch(l))
    );
  }
  async handleTabRemovedUpdate(e) {
    let t = await this.browserService.getWindowById(e);
    if (!t) return;
    let r = this.extraDataService.getWindowExtraData(t);
    if (r?.hasBlankTabAfterCreating) {
      g(r.sessionId, "Must have a sessionId to create window data", {
        extraData: r,
      });
      let { extraData: i } = this.extraDataService.createWindowData(
        r.sessionId,
        r.createdProgrammatically
      );
      await this.browserService.updateWindow(e, { extraData: i });
      return;
    }
    await this.handleUpdate(e);
  }
  async handleUpdate(e, t = !1) {
    let r = this.tabStripObserver.getTabInfoForWindow(e);
    if (!r || this.lockedWindowIds.has(e)) return;
    let a =
        (r.every((u) => u.isHidden) &&
          this.userSettingsRepository.getSettings().isHeadlessModeEnabled) ||
        this.isHeadlessPermanent,
      p = this.isHeadlessEnabledByWindowId[e] !== a;
    if (p || t || this.isHeadlessPermanent) {
      p &&
        ((this.isHeadlessEnabledByWindowId[e] = a),
        this.emitter.emit("headless-mode-changed", e, a));
      try {
        a
          ? await this.browserService.enableWindowHeadlessMode(e)
          : await this.browserService.disableWindowHeadlessMode(e),
          this.logger.info(
            `Headless mode changed to ${a.toString()} for window ${e}`
          );
      } catch (u) {
        if (
          (this.removeIsHeadlessEnabled(e),
          u instanceof Error && u.message.startsWith("No window with id"))
        )
          return;
        l(u);
      }
    }
  }
  removeIsHeadlessEnabled(e) {
    delete this.isHeadlessEnabledByWindowId[e];
  }
};
c();
var po = class {
  constructor(e, t, r) {
    this.browserService = e;
    t.subscribeToTabAttached((i, s) => {
      this.map.set(i, s.newWindowId), this.emitter.emit(i, s.newWindowId);
    }),
      t.subscribeToTabCreated((i) => i.id && this.map.set(i.id, i.windowId)),
      t.subscribeToTabRemoved((i) => this.map.delete(i)),
      this.addInitialTabs(r);
  }
  emitter = new A();
  map = new Map();
  static async build(e, t) {
    let r = await e.getAllTabs();
    return new po(e, t, r);
  }
  getWindowIdByTabId(e) {
    let t = this.map.get(e);
    return (
      t || this.throwTabErrorWithInfo(e).catch(l),
      g(t, "windowId not found for tabId"),
      t
    );
  }
  subscribeWindowIdByTabId(e, t) {
    let r = this.map.get(e);
    return r !== void 0 && t(r), this.emitter.on(e, t);
  }
  addInitialTabs(e) {
    e.forEach((t) => {
      t.id &&
        (this.map.set(t.id, t.windowId),
        this.emitter.emit(t.id, t.windowId),
        this.browserService.processTabAfterExtReload(t));
    });
  }
  async throwTabErrorWithInfo(e) {
    let t = await this.browserService.getTabById(e);
    throw new L("WindowTabObserver. Cannot get windowId by tabId", {
      tags: { windowId: t?.windowId.toString() ?? "", exist: String(!!t) },
    });
  }
};
c();
c();
var lo = class {
  static parseEvent(e) {
    return {
      id: e.id,
      attendees: this.parseAttendees(e.attendees) ?? [],
      title: e.summary,
      callLink: this.parseCallLink(e),
      eventLink: e.htmlLink,
      start: this.parseDate(e.start),
      end: this.parseDate(e.end),
    };
  }
  static parseAttendees(e) {
    return e?.map((t) => ({
      email: t.email,
      organizer: t.organizer,
      self: t.self,
      responseStatus: t.responseStatus,
    }));
  }
  static parseDate(e) {
    return { dateTime: new Date(e.dateTime), timeZone: e.timeZone };
  }
  static parseCallLink(e) {
    let { location: t, description: r, hangoutLink: i, eventType: s } = e;
    if (s !== "default") return "";
    if (i) return i;
    if (t) {
      let a = t.match(this.zoomRegExp);
      if (a?.[0]) return a[0];
      let n = t.match(this.googleMeetRegExp);
      if (n?.[0]) return n[0];
    }
    if (r) {
      let a = r.match(this.zoomRegExp);
      if (a?.[0]) return a[0];
      let n = r.match(this.googleMeetRegExp);
      if (n?.[0]) return n[0];
    }
    return "";
  }
};
lr(lo, "zoomRegExp", /(https:\/\/.*\.?zoom.us\/j\/.[^\s]+)/gm),
  lr(lo, "googleMeetRegExp", /(https:\/\/meet.google.com\/.[^\s]+)/gm);
var qE = 4,
  _h = 5,
  Fh = 2,
  Mh = "calendars-interval-alarm",
  xh = "calendars-closest-alarm",
  zE = "declined";
var pw = "iii, MMM d p",
  Np = class {
    constructor(e, t, r, i, s, a, n, p, d, u) {
      this.featureFlagsRepository = e;
      this.externalAuthService = t;
      this.googleApiService = r;
      this.userSettingsRepository = i;
      this.browserStorage = s;
      this.modalService = a;
      this.notificationsManager = n;
      this.browserService = p;
      this.browserEventsService = d;
      this.onboardingDataService = u;
      W.onSeveral(Ce, () => {
        this.init().catch(l);
      }),
        this.featureFlagsRepository.onFeatureFlagsLoaded((m, y) => {
          y || (this.init().catch(l), this.trySetupCalendars().catch(l));
        }),
        this.browserEventsService.subscribeToAlarm((m) => {
          switch (m.name) {
            case Mh: {
              this.loadAllCalendarEvents(Object.keys(this.events))
                .then(() => this.checkNotifications())
                .catch(l);
              break;
            }
            case xh: {
              this.checkNotifications(!0), this.tryUpdateClosestEvent();
              break;
            }
            default:
          }
        }),
        this.browserEventsService.subscribeToIdleStateChanged((m) => {
          m === "active" &&
            ((this.closestEventDate = void 0),
            this.scheduleReloadListAlarm(Object.keys(this.events)).catch(l));
        }),
        this.trySetupCalendars().catch(l);
    }
    events = {};
    permissionsByCalendar = {};
    emitter = new A();
    isActive = !1;
    closestEventDate;
    logger = x.createInstance("calendar_integrations");
    alreadyShownEvents = [];
    async init() {
      if (!this.isEnabled()) {
        await this.browserService.clearAlarmByName(Mh),
          await this.browserService.clearAlarmByName(xh),
          (this.isActive = !1),
          (this.closestEventDate = void 0),
          this.emitter.emit("changed");
        return;
      }
      if (this.isActive) return;
      this.isActive = !0;
      let e = this.loadDataForStoredCredentials();
      await this.loadPermissionsFromLS(),
        await this.scheduleReloadListAlarm(e),
        this.emitter.emit("changed");
    }
    onCalendarsChanged(e) {
      return this.emitter.on("changed", e);
    }
    getUserCalendars() {
      return Object.entries(this.permissionsByCalendar).map(([e, t]) => ({
        name: e,
        allowReferralLink: t,
        type: "google",
      }));
    }
    async addNewGoogleCalendar(e, t) {
      try {
        let r = this.externalAuthService.getGoogleCredentials("CALENDAR")[e];
        g(r, "No credentials"),
          this.modalService.closeAllModalsById("calendar"),
          this.externalAuthService.updateGoogleCredentialsKey("CALENDAR", e, t),
          this.updateCalendar(t, !1),
          await this.loadCalendarEvents(t, r.accessToken),
          this.tryUpdateClosestEvent();
      } catch (r) {
        r instanceof L && r.context.extra?.isExpired
          ? this.notificationsManager.showCalendarsSystemTokenExpiredNotification(
              t
            )
          : this.notificationsManager.showCalendarsSystemErrorNotification();
        return;
      }
      this.notificationsManager.showCalendarsSystemAddedNotification(),
        this.emitter.emit("changed");
    }
    deleteCalendarInfo(e) {
      delete this.permissionsByCalendar[e], delete this.events[e];
    }
    updateCalendar(e, t, r) {
      r &&
        (this.externalAuthService.updateGoogleCalendarName(e, r),
        (this.events[e] = this.events[r] ?? []),
        this.deleteCalendarInfo(r)),
        (this.permissionsByCalendar[e] = t),
        this.savePermissionsToLS(),
        this.emitter.emit("changed");
    }
    removeCalendar(e) {
      this.deleteCalendarInfo(e),
        this.externalAuthService.removeOauthData("google", "CALENDAR", e),
        this.tryUpdateClosestEvent(),
        this.savePermissionsToLS(),
        this.externalAuthService.removeGoogleCalendar(e),
        this.emitter.emit("changed");
    }
    markCalendarsSetupAsShown() {
      return this.browserStorage.setItem("calendars-setup-shown", !0);
    }
    async scheduleReloadListAlarm(e) {
      this.browserService.createAlarm(Mh, {
        when: this.getIntervalFirstTick(),
        periodInMinutes: _h,
      }),
        await this.loadAllCalendarEvents(e),
        this.checkNotifications();
    }
    getIntervalFirstTick() {
      let e = new Date(),
        t = _h - (this.getCurrentMinutesWithOffset() % _h);
      return fb(Sb(e), t).getTime();
    }
    getCurrentMinutesWithOffset() {
      let t = new Date().getMinutes() - qE;
      return t < 0 ? 60 - t : t;
    }
    checkNotifications(e = !1) {
      Object.entries(this.events).forEach(([t, r]) => {
        let i = this.matchEvents(t, r, { byDateTime: e });
        this.isEnabled() &&
          i.forEach((s) => {
            if (!s.callLink || this.alreadyShownEvents.includes(s.id)) return;
            this.alreadyShownEvents.push(s.id);
            let a = Uo(s.start.dateTime, pw),
              n = Uo(s.end.dateTime, pw),
              p = s.attendees.length > 6,
              d = p ? s.attendees.slice(0, 6) : s.attendees,
              u = p ? s.attendees.length - d.length : void 0;
            this.notificationsManager.showCalendarNotification({
              title: s.title,
              eventId: s.id,
              email: t,
              attendees: d,
              exceedingAttendeesCount: u,
              startDateMs: s.start.dateTime.getTime(),
              startDate: a,
              endDate: n,
              meetingLink: s.eventLink,
              callLink: s.callLink,
            });
          });
      });
    }
    matchEvents(e, t, { byDateTime: r }) {
      let i = (n) => n.start.dateTime === this.closestEventDate,
        s = (n) => {
          let p = new Date(),
            d = ea(n.start.dateTime, p, { roundingMethod: "ceil" });
          return d > 0 && d <= Fh;
        },
        a = (n) =>
          n.attendees.find((d) => d.email === e)?.responseStatus !== zE;
      return t.filter(r ? i : s).filter(a);
    }
    loadDataForStoredCredentials() {
      let e = this.externalAuthService.getGoogleCredentials("CALENDAR");
      return Object.keys(e);
    }
    async loadAllCalendarEvents(e) {
      await Promise.all(
        e
          .filter((t) => t in this.permissionsByCalendar)
          .map((t) => {
            let r = this.externalAuthService.getAccessTokenForGoogleEmail(
              "CALENDAR",
              t
            );
            return r
              ? this.loadCalendarEvents(t, r)
              : (this.notificationsManager.showCalendarsSystemTokenExpiredNotification(
                  t
                ),
                Promise.resolve());
          })
      ),
        this.tryUpdateClosestEvent();
    }
    async loadCalendarEvents(e, t, r = !1, i) {
      try {
        let s = await this.googleApiService.getCalendarsInfo(t, i);
        this.events[e] = s.items?.map((a) => lo.parseEvent(a)) ?? [];
      } catch (s) {
        if (r)
          throw (
            (this.logger.warn("Entering loop while requesting tokens."),
            l(s),
            s)
          );
        let a = await this.externalAuthService.tryRefreshGoogleAccessToken(
          "CALENDAR",
          e
        );
        if (!a) {
          this.notificationsManager.showCalendarsSystemTokenExpiredNotification(
            e
          );
          return;
        }
        await this.loadCalendarEvents(e, a, !0, t);
      }
    }
    tryUpdateClosestEvent() {
      let e = this.findClosestEventDate();
      !e ||
        e === this.closestEventDate ||
        (this.browserService.createAlarm(xh, { when: e.getTime() - ye(Fh) }),
        (this.closestEventDate = e));
    }
    findClosestEventDate() {
      let e,
        t = new Date();
      return (
        Object.values(this.events).forEach((r) => {
          let i = r.find(
            (s) =>
              Tb(s.start.dateTime, Fh) >= t &&
              !this.alreadyShownEvents.includes(s.id)
          );
          i && (!e || i.start.dateTime < e) && (e = i.start.dateTime);
        }),
        e
      );
    }
    isEnabled() {
      return (
        this.userSettingsRepository.getSettings().enableCalendarsIntegration &&
        this.featureFlagsRepository.getFeatureFlag(
          "calendarsIntegrationEnabled"
        )
      );
    }
    savePermissionsToLS() {
      this.browserStorage
        .setItem("calendars-permissions", this.permissionsByCalendar)
        .catch(l);
    }
    async loadPermissionsFromLS() {
      this.permissionsByCalendar =
        (await this.browserStorage.getItem("calendars-permissions")) ?? {};
    }
    async trySetupCalendars() {
      let e = this.featureFlagsRepository.getFeatureFlag(
        "calendarsIntegrationEnabled"
      );
      this.onboardingDataService.getIsAfterOnboarding() ||
        !e ||
        (await this.getSetupShown()) ||
        this.isEnabled() ||
        this.notificationsManager.showCalendarsSetupNotification();
    }
    getSetupShown() {
      return this.browserStorage.getItem("calendars-setup-shown");
    }
  };
c();
var Lp = class {
  constructor(e, t, r, i, s, a, n, p) {
    this.shortcutService = e;
    this.modalService = t;
    this.popupService = r;
    this.splitViewService = i;
    this.browserService = s;
    this.sidecarService = a;
    this.userApi = n;
    this.featureFlagsRepository = p;
  }
  getCommands() {
    let { calendarsIntegrationEnabled: e } =
      this.featureFlagsRepository.getFeatureFlags();
    return [
      e
        ? {
            id: "set-up-calendars",
            name: P("background_commands__set_up_calendars"),
          }
        : null,
      {
        id: "manage-workspaces",
        name: P("background_commands__manage_workspaces"),
      },
      {
        id: "customize-appearance",
        name: P("background_commands__customize_appearance"),
      },
      {
        id: "share-with-friends",
        name: P("background_commands__share_with_friends"),
      },
      { id: "send-feedback", name: P("background_commands__send_feedback") },
      { id: "open-discord", name: P("background_commands__open_discord") },
      {
        id: "import-bookmarks-and-history",
        name: P("background_commands__import_bookmarks"),
      },
      {
        id: "configure-shortcuts",
        name: P("background_commands__configure_shortcuts"),
      },
    ].filter(de);
  }
  getShortcutCommands() {
    let {
        switchFocusMode: e,
        toggleLastSplitPanel: t,
        switchTab: r,
        manageSession: i,
        appAsTab: s,
        openSplitMenu: a,
        toggleCollectionsSidecar: n,
        browserCloseTab: p,
        openInSplitView: d,
      } = this.shortcutService.getShortcuts(),
      { focusModeShortcutEnabled: u, collectionsEnabled: m } =
        this.featureFlagsRepository.getFeatureFlags();
    return [
      u
        ? {
            id: "enter-focus-mode",
            name: P("background_commands__enter_focus_mode"),
            shortcutKeys: e.keys,
          }
        : null,
      {
        id: "open-current-in-split-view",
        name: P("background_commands__open_split_view_menu"),
        shortcutKeys: a.keys,
      },
      {
        id: "open-app-or-tab-in-split-view",
        name: P("background_commands__open_app_split_view"),
        shortcutKeys: d.keys,
      },
      {
        id: "open-last-split-panel",
        name: P("background_commands__open_last_split_view"),
        shortcutKeys: t.keys,
      },
      {
        id: "close-app-or-tab",
        name: P("background_commands__close_app_tab"),
        shortcutKeys: p.keys,
      },
      m
        ? {
            id: "open-collections-or-tasks",
            name: P("background_commands__open_collection"),
            shortcutKeys: n.keys,
          }
        : null,
      {
        id: "open-tab-switcher",
        name: P("background_commands__open_tab_switcher"),
        shortcutKeys: r.keys,
      },
      {
        id: "open-sessions",
        name: P("background_commands__open_sessions"),
        shortcutKeys: i.keys,
      },
      {
        id: "open-current-app-as-tab",
        name: P("background_commands__open_current_app"),
        shortcutKeys: s.keys,
      },
    ].filter(de);
  }
  activateCommand(e, t) {
    switch (e) {
      case "open-current-in-split-view":
        this.splitViewService.openSplitViewMenu();
        break;
      case "configure-shortcuts":
        this.browserService.createActiveTab(mr.shortcuts);
        break;
      case "set-up-calendars":
        this.modalService.showCalendarModal({ source: "command" }).catch(l);
        break;
      case "import-bookmarks-and-history":
        this.browserService.createActiveTab(mr.importData);
        break;
      case "open-collections-or-tasks":
        this.sidecarService
          .toggleCollectionsOrTasks(t, { source: "command" })
          .catch(l);
        break;
      case "send-feedback":
        this.browserService.createActiveTab(this.userApi.generateFeedbackUrl());
        break;
      case "open-discord":
        this.browserService.createActiveTab(
          this.featureFlagsRepository.getFeatureFlag("helpLinks")
            .discordCommunity
        );
        break;
      case "share-with-friends":
        this.popupService.showLaunchpadPopup("billing-invitations").catch(l);
        break;
      case "manage-workspaces":
        this.modalService
          .showWorkspacesManagementModal({ source: "command" }, t)
          .catch(l);
        break;
      case "customize-appearance":
        this.modalService
          .showGlobalSettingsModal({ source: "command" }, t)
          .catch(l);
        break;
      case "enter-focus-mode":
      case "open-last-split-panel":
      case "open-tab-switcher":
      case "open-sessions":
      case "open-current-app-as-tab":
      case "open-app-or-tab-in-split-view":
      case "close-app-or-tab":
        this.shortcutService.activateShortcutCommand(e);
        break;
      default:
    }
  }
};
c();
var Gp = class {
  constructor(e) {
    this.retryApi = e;
    (this.isReconnecting = !1),
      (this.reconnectionCounter = null),
      (this.isOnline = !0),
      e.subscribeToStartReconnect(() => this.updateConnection(!0, null)),
      e.subscribeToConnectSuccess(() => this.updateConnection(!1, null)),
      e.subscribeToConnectFailed((r) => {
        Number.isNaN(r) || this.updateConnection(!1, Number(r));
      });
    let t = () => {
      (this.isOnline = navigator.onLine),
        this.emitter.emit("is-online-changed");
    };
    t(),
      window.addEventListener("online", t),
      window.addEventListener("offline", t),
      navigator.connection.addEventListener("change", t);
  }
  isReconnecting;
  reconnectionCounter;
  isOnline;
  emitter = new A();
  logger = x.createInstance("connection");
  onConnectionChanged(e) {
    return this.emitter.on("connection-changed", e);
  }
  onIsOnlineChanged(e) {
    return this.emitter.on("is-online-changed", e);
  }
  getIsReconnecting() {
    return this.isReconnecting;
  }
  getReconnectionCounter() {
    return this.reconnectionCounter;
  }
  getIsOnline() {
    return this.isOnline;
  }
  getSaveData() {
    return navigator.connection.saveData;
  }
  retryAll() {
    return this.retryApi.retryQueuedRequests();
  }
  updateConnection(e, t) {
    (this.isReconnecting = e),
      (this.reconnectionCounter = t),
      this.logger.info(
        `Connection changed. Is reconnecting - ${this.isReconnecting.toString()}, counter - ${
          this.reconnectionCounter ?? "unset"
        }`
      ),
      this.emitter.emit("connection-changed");
  }
};
c();
var di = class {
  constructor(e, t, r, i) {
    this.modalService = e;
    this.googleApiService = t;
    this.slackApiService = r;
    this.externalAuthService = i;
  }
  async showGoogleContactsPicker(e, t) {
    let r = await this.getContactsFromGoogle(e);
    return this.modalService.showContactsPickerForTeam({
      ...t,
      type: "google",
      contacts: r,
    });
  }
  async showSlackContactsPicker(e) {
    let t = await this.getContactsFromSlack();
    return this.modalService.showContactsPickerForTeam({
      ...e,
      type: "slack",
      contacts: t,
    });
  }
  async getContactsFromSlack() {
    let e = this.externalAuthService.getLastCredentialsByScope(
        "slack",
        "CONTACTS"
      ),
      t = e?.[1].accessToken;
    if (!t)
      throw (
        (e?.[0] &&
          this.externalAuthService.removeOauthData("slack", "CONTACTS", e[0]),
        new Co("Not auth"))
      );
    if (!t) return [];
    try {
      return (await this.slackApiService.getContacts(t)).members.reduce(
        (i, s) => {
          if (!s.profile.email || s.deleted) return i;
          let a = {
            email: s.profile.email,
            avatarUrl: s.profile.image_32,
            name: s.profile.real_name,
          };
          return [...i, a];
        },
        []
      );
    } catch (r) {
      throw (
        (this.externalAuthService.removeOauthData("slack", "CONTACTS", e[0]), r)
      );
    }
  }
  async getContactsFromGoogle(e, t = !1) {
    let i =
      this.externalAuthService.getGoogleCredentials("CONTACTS")[e]?.accessToken;
    if (!i)
      throw (
        (this.externalAuthService.removeOauthData("google", "CONTACTS", e),
        new Co("Not auth"))
      );
    let s = !1;
    try {
      let a = this.getGoogleDomainContacts(i),
        n = this.getGooglePersonalContacts(i);
      return (await Promise.allSettled([a, n]))
        .map((u) => {
          if (u.status === "rejected")
            throw new Error("Error fetching contacts");
          return u.value;
        })
        .flat();
    } catch (a) {
      if (t || s)
        throw (
          (this.externalAuthService.removeOauthData("google", "CONTACTS", e), a)
        );
      return (
        (s = !0),
        await this.externalAuthService.tryRefreshGoogleAccessToken(
          "CONTACTS",
          e
        ),
        this.getContactsFromGoogle(e, !0)
      );
    }
  }
  async getGoogleDomainContacts(e) {
    try {
      let r = (await this.googleApiService.getUserInfo(e)).email.split("@")[1];
      if (!r) return [];
      let i = await this.googleApiService.getUserDomainContacts(e, r);
      return i.users
        ? i.users.reduce((s, a) => {
            let n = di.mapGoogleDomainContactToContact(a);
            return [...s, n];
          }, [])
        : [];
    } catch (t) {
      if (t instanceof lt && t.res.status === 404) return [];
      throw t;
    }
  }
  async getGooglePersonalContacts(e) {
    let t = await this.googleApiService.getUserPersonalContacts(e);
    if (t.error) throw new Error(t.error);
    return t.connections
      ? t.connections.reduce((r, i) => {
          let s = di.mapGooglePersonalContactToContacts(i);
          return s.length ? [...r, ...s] : r;
        }, [])
      : [];
  }
  static mapGooglePersonalContactToContacts(e) {
    if (!e.emailAddresses) return [];
    let t = e.photos?.[0]?.url,
      r = e.names?.[0]?.displayName ?? "";
    return e.emailAddresses.map(({ value: i }) => ({
      avatarUrl: t,
      name: r,
      email: i,
    }));
  }
  static mapGoogleDomainContactToContact({
    thumbnailPhotoUrl: e,
    name: { fullName: t },
    primaryEmail: r,
  }) {
    return { avatarUrl: e, name: t, email: r };
  }
};
c();
c();
c();
c();
var Hp = class {
  constructor(e, t, r, i) {
    this.browserService = e;
    this.browserEventsService = t;
    this.tabId = r;
    this.scriptName = i;
  }
  unsubscribe = () => {};
  subscriptions = [];
  dispose() {
    this.unsubscribe(), this.clearSubscriptions();
  }
  clearSubscriptions() {
    this.subscriptions.forEach((e) => e()), (this.subscriptions.length = 0);
  }
  sendMessage(e) {
    this.browserService.sendMessageToTab(this.tabId, e);
  }
  subscribe(e, t) {
    let r = this.browserEventsService.subscribeToMessage((i, s, a) => {
      s.tab?.id === this.tabId &&
        Zg(i) &&
        i.type === e &&
        ev(i, this.scriptName) &&
        t(i, this.browserService.normalizeTab(s.tab)),
        a && a();
    });
    return this.subscriptions.push(r), r;
  }
};
var Vp = class extends Hp {
  constructor(t, r, i, s, a) {
    super(t, r, s, `recipe-${a}`);
    this.localFileResolver = i;
    this.recipeId = a;
  }
  handlersNeedToCall = new Set();
  handlersArgs = new Map();
  onBadgeMessage(t) {
    return this.subscribe("BADGES", (r) => {
      tv(r) && t(r);
    });
  }
  onAccountsMessage(t) {
    return this.subscribe("ACCOUNTS", (r) => {
      rv(r) && t(r);
    });
  }
  onRequestSyncFocusModeMessage(t) {
    return this.subscribe("REQUEST_FOCUS_MODE_STATE", t);
  }
  onSendAnalyticsMessage(t) {
    return this.subscribe("SEND_ANALYTICS", (r) => {
      ov(r) && t(r);
    });
  }
  onSendErrorMessage(t) {
    return this.subscribe("SEND_ERROR", (r) => {
      sv(r) && t(r);
    });
  }
  onPutResourceMessage(t) {
    return this.subscribe("PUT_RESOURCE", (r, i) => {
      iv(r) && t(r, i);
    });
  }
  subscribeInjectFramesRequest() {
    return this.subscribe("INJECT_FRAMES_REQUEST", (t) => {
      av(t) && this.initScript(!0).catch(l);
    });
  }
  subscribeToSetCustomSubscriberMessage() {
    return this.subscribe("SET_CUSTOM_SUBSCRIBER", (t) => {
      nv(t) &&
        this.handlersNeedToCall.has(t.name) &&
        (this.browserService.sendMessageToTab(this.tabId, {
          type: "CALL_CUSTOM_SUBSCRIBER",
          name: t.name,
          args: this.handlersArgs.get(t.name),
          scriptName: this.scriptName,
        }),
        this.handlersNeedToCall.delete(t.name),
        this.handlersArgs.delete(t.name));
    });
  }
  subscribeToCallCustomSubscriberMessage() {
    return this.subscribe("CALL_CUSTOM_SUBSCRIBER", (t) => {
      cv(t) &&
        (this.handlersNeedToCall.add(t.name),
        t.args
          ? this.handlersArgs.set(t.name, t.args)
          : this.handlersArgs.delete(t.name),
        this.browserService.sendMessageToTab(this.tabId, {
          ...t,
          scriptName: this.scriptName,
        }));
    });
  }
  async initScript(t = !1) {
    let r = (i) => this.browserService.getUrl(i);
    (await this.localFileResolver.checkExistence(
      `background/web/recipe-${this.recipeId}.js`
    )) &&
      (await this.browserService.executeScript(this.tabId, {
        code: `import('${r("/background/web/load_recipe_script.js")}')
        .then(module => module.default(
          '${this.recipeId}',
          '${r(`/background/web/recipe-${this.recipeId}.js`)}'
        ))`,
        runAt: "document_idle",
        allFrames: t,
      }));
  }
};
var $p = class {
  constructor(e, t, r) {
    this.browserService = e;
    this.browserEventsService = t;
    this.localFileResolver = r;
  }
  contentScriptInstances = new Map();
  appScriptInstances = new Map();
  getContentScript(e, t) {
    return Ai(this.contentScriptInstances, e, new Map()).get(t);
  }
  setContentScript(e, t) {
    let r = Ai(this.contentScriptInstances, e, new Map()),
      i = r.get(t.scriptName);
    i && i.dispose(), r.set(t.scriptName, t);
  }
  removeScriptsForTabId(e) {
    let t = this.contentScriptInstances.get(e);
    this.contentScriptInstances.delete(e),
      t && (t.forEach((r) => r.dispose()), t.clear());
  }
  getAppScript(e) {
    return this.appScriptInstances.get(e);
  }
  ensureAppScript(e, t) {
    let r = this.getAppScript(e);
    if (r) return r;
    let i = new Vp(
      this.browserService,
      this.browserEventsService,
      this.localFileResolver,
      e,
      t
    );
    return this.appScriptInstances.set(e, i), this.setContentScript(e, i), i;
  }
};
var Kp = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m) {
    this.browserService = e;
    this.applicationRepository = r;
    this.applicationService = i;
    this.accountRepository = s;
    this.extraDataService = a;
    this.accountService = n;
    this.focusModeService = p;
    this.searchService = d;
    this.analytics = u;
    (this.contentScriptRepository = new $p(e, t, m)),
      this.init().catch(l),
      t.subscribeToTabCreated((y) => this.injectScriptsToTab(y)),
      t.subscribeToTabRemoved((y) =>
        this.contentScriptRepository.removeScriptsForTabId(y)
      ),
      t.subscribeToDOMContentLoaded(async (y) => {
        if (y.frameId) return;
        let b = await e.getTabById(y.tabId);
        b && this.injectScriptsToTab(b);
      });
  }
  contentScriptRepository;
  unloadScriptsByTabId(e) {
    return this.browserService.executeScript(e, {
      code: `;(() => {
        const map = globalThis.__sidekick_scripts || new Map();
        map.forEach(script => script.unload());
        map.clear();
      })()`,
      runAt: "document_idle",
      allFrames: !0,
    });
  }
  injectScriptsToTab(e) {
    let t = e?.id;
    if (!t) return;
    this.contentScriptRepository.removeScriptsForTabId(t);
    let i = this.extraDataService.getTabExtraData(e)?.app;
    i && this.injectAppScript(i, t);
  }
  async init() {
    let e = await this.browserService.getAllTabs(),
      t = e.map((r) => r.id).filter(de);
    await Promise.all(t.map((r) => this.unloadScriptsByTabId(r))),
      D.once("apps-loaded", () => e.forEach((r) => this.injectScriptsToTab(r)));
  }
  injectAppScript(e, t) {
    let r = this.applicationRepository.getAppById(e);
    if (!r) return;
    let { recipeId: i } = r,
      s = this.contentScriptRepository.ensureAppScript(t, i);
    s.clearSubscriptions(),
      s.onBadgeMessage((a) =>
        this.applicationService.changeUnreadMessageCount(e, a.value)
      ),
      s.onAccountsMessage((a) =>
        this.accountService.addAccountsFromContentScript(e, a.accounts)
      ),
      s.onRequestSyncFocusModeMessage(() => {
        this.focusModeService.handleTabFocusMode(t).catch(l);
      }),
      s.onPutResourceMessage((a, n) => {
        let p = r ? this.accountRepository.getCurrentAppAccountId(r) : null;
        this.searchService.history.upsertToHistory(n.id, {
          url: a.url,
          partitionId: n.partitionName ?? "",
          accountId: p ?? "",
          contentCrawledAt: Date.now(),
          contentTitle: a.title,
          contentFavIconUrl: a.favIconUrl ?? null,
        });
      }),
      s.subscribeInjectFramesRequest(),
      s.subscribeToSetCustomSubscriberMessage(),
      s.subscribeToCallCustomSubscriberMessage(),
      s.onSendAnalyticsMessage(({ name: a, payload: n }) => {
        this.analytics.sendAnalyticsEvent(a, n);
      }),
      s.onSendErrorMessage(({ error: a }) => {
        let n = new L("");
        Object.assign(n, a), l(n);
      }),
      s.initScript().catch(l);
  }
};
c();
c();
var XE = 100,
  JE = -1,
  qp = class {
    constructor(e, t, r, i, s, a, n, p, d) {
      this.browserService = e;
      this.browserEventsService = t;
      this.collectionsService = r;
      this.collectionsRepository = i;
      this.featureFlagsRepository = s;
      this.teamApi = a;
      this.contextMenuService = n;
      this.uiHintsManager = p;
      this.analytics = d;
      let u = yt(async () => {
          await this.updateContextMenus();
        }, XE),
        m = () => {
          u()?.catch(l);
        };
      this.contextMenuService.subscribeToTabMenuItemClicked(
        ({ scope: y, payload: b }) => {
          y === "collection" &&
            this.addLinkToCollection(b.tabId, b.menuItemId).catch(l);
        }
      ),
        re.on("workspaces-loaded", m),
        we.onSeveral(["collection-created", "collections-loaded"], m),
        this.featureFlagsRepository.onFeatureFlagsLoaded((y) => {
          y.collectionsEnabled !== this.collectionsEnabled &&
            (m(), (this.collectionsEnabled = y.collectionsEnabled));
        }),
        this.browserEventsService.subscribeToNormalWindowFocusChanged((y) => {
          y !== this.lastFocusedWindowId &&
            (m(), (this.lastFocusedWindowId = y));
        }),
        we.on("collections-loaded", m),
        this.contextMenuService.subscribeToContextMenuItemClicked(
          ({ scope: y, payload: b }) => {
            if (y !== "collection") return;
            let v = b.tab?.id;
            v &&
              this.addLinkToCollection(
                v,
                b.onClickData.menuItemId,
                b.onClickData.linkUrl,
                b.onClickData.selectionText
              ).catch(l);
          }
        );
    }
    lastFocusedWindowId = null;
    collectionsEnabled = !1;
    getContextMenuRootFolders(e) {
      let t =
          this.collectionsRepository.getCollectionsForWorkspaceByWindowId(e),
        r = this.teamApi.getTeamForWorkspaceByWindowId(e),
        i = null;
      r &&
        !r.isJustMe &&
        t.team.length &&
        (i = {
          title: P("context_menu_collection__team"),
          children: t.team.map(this.createPropsForCollectionFolder.bind(this)),
        });
      let s = null;
      t.shared.length &&
        (s = {
          title: P("context_menu_collection__shared"),
          children: t.shared.map(
            this.createPropsForCollectionFolder.bind(this)
          ),
        });
      let a = null;
      return (
        t.private.length &&
          (a = {
            title: P("context_menu_collection__personal"),
            children: t.private.map(
              this.createPropsForCollectionFolder.bind(this)
            ),
          }),
        [i, s, a].filter(de)
      );
    }
    async createLink(e, t, r, i) {
      await this.collectionsService.createLink(e, { link: t, name: r }),
        this.analytics.sendAnalyticsEvent(
          "context-menu.create-collection-link",
          void 0
        ),
        this.uiHintsManager.showHint(i, "added_to_collection");
    }
    async createContextMenus() {
      let e = await this.browserService.getNormalLastFocusedWindow(),
        t = e?.id && e?.focused ? e.id : this.lastFocusedWindowId;
      if (!t || t === JE) return;
      let r = this.getContextMenuRootFolders(t);
      if (!r.length) return;
      let i = {
        title: P("context_menu_collection__root"),
        contexts: ["link", "page"],
        children: r,
      };
      await this.contextMenuService.updateNativeContextMenu("collection", i),
        await this.contextMenuService.updateTabContextMenu("collection", i);
    }
    async clearContextMenus() {
      return Promise.all([
        this.contextMenuService.clearNativeContextMenu("collection"),
        this.contextMenuService.clearTabContextMenu("collection"),
      ]);
    }
    createPropsForCollectionFolder(e) {
      let t = e.children.filter((s) => s.type === "folder"),
        r = {
          title: `${P("context_menu_collection__add_prefix")} ${e.name}`,
          id: e.uuid,
        };
      return t.length
        ? {
            title: e.name,
            children: [
              ...t.map(this.createPropsForCollectionFolder.bind(this)),
              r,
            ],
          }
        : { title: e.name, children: [r] };
    }
    async updateContextMenus() {
      return (
        await this.clearContextMenus(),
        this.collectionsRepository.isCollectionsEnabledForWorkspaceByWindowId(
          this.lastFocusedWindowId ?? void 0
        )
          ? this.createContextMenus()
          : Promise.resolve()
      );
    }
    async addLinkToCollection(e, t, r, i) {
      let s = await this.browserService.getTabById(e);
      if (!s) return;
      let a = r || s.url;
      a && (await this.createLink(t, a, i || s.title || "", s.windowId));
    }
  };
c();
var dw = "+",
  zp = class {
    constructor(e, t) {
      this.browserService = e;
      this.browserEventsService = t;
      this.browserService.clearContextMenus().catch(l),
        this.browserEventsService.subscribeToTabMenuItemClicked((r, i) => {
          let { scope: s, id: a } = this.retrieveScopeFromId(i);
          this.emitter.emit("tab-context-menu-item-clicked", {
            scope: s,
            payload: { tabId: r, menuItemId: a },
          });
        }),
        this.browserEventsService.subscribeToContextMenuItemClicked((r, i) => {
          let { scope: s, id: a } = this.retrieveScopeFromId(r.menuItemId);
          this.emitter.emit("native-context-menu-item-clicked", {
            scope: s,
            payload: { onClickData: { ...r, menuItemId: a }, tab: i },
          });
        });
    }
    emitter = new A();
    isUpdateInProgress = !1;
    tabContextMenuItemsByScope = { session: [], collection: [], task: [] };
    nativeContextMenuItemsByScope = { collection: null, task: null };
    subscribeToTabMenuItemClicked(e) {
      return this.emitter.on("tab-context-menu-item-clicked", e);
    }
    subscribeToContextMenuItemClicked(e) {
      return this.emitter.on("native-context-menu-item-clicked", e);
    }
    async updateNativeContextMenu(e, t, r) {
      if (!(!t || this.isUpdateInProgress))
        try {
          this.isUpdateInProgress = !0;
          let i = this.nativeContextMenuItemsByScope[e];
          i &&
            (await this.browserService.removeContextMenu(i.id),
            (this.nativeContextMenuItemsByScope[e] = null));
          let s = this.ensureRootId(e, t);
          (this.nativeContextMenuItemsByScope[e] = s),
            await this.createContextMenu(e, s, r);
        } finally {
          this.isUpdateInProgress = !1;
        }
    }
    ensureRootId(e, t) {
      return { ...t, id: this.addScopeToId(e, t.id || le()) };
    }
    async updateTabContextMenu(e, t) {
      await this.browserService.appendTabMenuItems([]);
      let r = this.convertNativeMenuItemToTabMenuItem(e, t);
      (this.tabContextMenuItemsByScope[e] = [r]),
        await this.browserService.appendTabMenuItems(
          Object.values(this.tabContextMenuItemsByScope).flat()
        );
    }
    async clearNativeContextMenu(e) {
      let t = this.nativeContextMenuItemsByScope[e];
      t &&
        (await this.browserService.removeContextMenu(t.id),
        (this.nativeContextMenuItemsByScope[e] = null));
    }
    async clearTabContextMenu(e) {
      (this.tabContextMenuItemsByScope[e] = []),
        await this.browserService.appendTabMenuItems(
          Object.values(this.tabContextMenuItemsByScope).flat()
        );
    }
    convertNativeMenuItemToTabMenuItem(e, t) {
      return (
        t.type &&
          g(
            t.type && t.type === "normal",
            "Method sidekick.tabMenu.appendMenuItems supports only normal tabs"
          ),
        t.children?.length
          ? {
              itemLabel: t.title || "",
              subMenu: t.children.map(
                this.convertNativeMenuItemToTabMenuItem.bind(this, e)
              ),
            }
          : { id: this.addScopeToId(e, t.id || le()), itemLabel: t.title || "" }
      );
    }
    async createContextMenu(e, t, r = { useRootContexts: !0 }) {
      let i = [t];
      for (; i.length; ) {
        let s = i.shift(),
          { children: a, ...n } = s;
        a && a.length > 0 && typeof n.id > "u" && (n.id = le()),
          n.id && (n.id = this.addScopeToId(e, n.id)),
          a?.forEach((p) =>
            i.push({
              ...p,
              parentId: n.id,
              contexts: r.useRootContexts ? t.contexts : p.contexts,
            })
          );
        try {
          await this.browserService.createContextMenu(n);
        } catch (p) {
          l(p, { extra: n });
        }
      }
    }
    addScopeToId(e, t) {
      return this.retrieveScopeFromId(t).scope === e ? t : `${e}${dw}${t}`;
    }
    retrieveScopeFromId(e) {
      let [t, r] = e.split(dw);
      return { scope: t, id: r || "" };
    }
  };
c();
c();
var Qp = class {
  constructor(e, t, r, i, s, a, n) {
    this.sessionRepository = e;
    this.sessionApi = t;
    this.browserService = r;
    this.workspaceRepository = i;
    this.analyticsTracker = s;
    this.contextMenuService = a;
    a.subscribeToTabMenuItemClicked(({ scope: p, payload: d }) => {
      if (p !== "session") return;
      let { tabId: u, menuItemId: m } = d;
      this.onTabMenuItemClicked(u, m).catch(l);
    }),
      n.subscribeToWindowFocusChanged(() => {
        this.updateTabMenu().catch(l);
      }),
      re.on("workspaces-loaded", () => {
        this.updateTabMenu().catch(l);
      }),
      pe.on("session-changed", () => {
        this.updateTabMenu().catch(l);
      });
  }
  async onTabMenuItemClicked(e, t) {
    let r = await this.browserService.getAllTabs({
      highlighted: !0,
      currentWindow: !0,
    });
    if (r.length === 1 && e !== r.at(0)?.id) {
      this.analyticsTracker.sendAnalyticsEvent(
        "tabstrip.tab-menu.move-to-session",
        { "tabs-count": 1 }
      ),
        this.moveTabToAnotherSession(e, t).catch(l);
      return;
    }
    this.analyticsTracker.sendAnalyticsEvent(
      "tabstrip.tab-menu.move-to-session",
      { "tabs-count": r.length + 1 }
    ),
      await Promise.all([
        this.moveTabToAnotherSession(e, t),
        ...r.map((i) => (i.id ? this.moveTabToAnotherSession(i.id, t) : null)),
      ]);
  }
  async moveTabToAnotherSession(e, t) {
    if (!e) return;
    let r = this.sessionRepository.getTabAndSessionByBrowserId(e);
    r &&
      r.session.id !== t &&
      (await this.sessionApi.moveSessionTabToAnotherSession(
        r.tab.id,
        t,
        r.session.id
      ));
  }
  appendMenuItems(e) {
    this.contextMenuService.updateTabContextMenu("session", e).catch(l);
  }
  async updateTabMenu() {
    let e = await this.browserService.getLastFocusedWindowId();
    if (!e) return;
    let t = this.sessionRepository.getSessionByWindowId(e);
    if (!t) {
      await this.contextMenuService.clearTabContextMenu("session");
      return;
    }
    let r = this.workspaceRepository.getWorkspacesArray(),
      i = new Array();
    r.forEach((s) => {
      let n = this.sessionRepository.getSessionsByWorkspaceId(s.id).map((p) => {
        let d = this.sessionRepository.getOrderedTabs(p.id),
          u = Ob(p, d);
        return {
          id: p.id,
          title: p.id === t?.id ? `${u} - ${P("tab_menu__opened")}` : u,
        };
      });
      n.length > 0 && i.push({ title: s.name, children: n });
    }),
      i.length > 1
        ? this.appendMenuItems({
            title: P("tab_menu__move_to_session"),
            children: i,
          })
        : i.length === 1
        ? this.appendMenuItems({
            title: P("tab_menu__move_to_session"),
            children: i[0]?.children,
          })
        : await this.contextMenuService.clearTabContextMenu("session");
  }
};
c();
var ZE = 100,
  Yp = class {
    constructor(e, t, r, i, s, a, n) {
      this.browserService = e;
      this.browserEventsService = t;
      this.featureFlagsRepository = r;
      this.contextMenuService = i;
      this.taskTrackerService = s;
      this.sidecarService = a;
      this.analytics = n;
      let p = yt(async () => {
          await this.updateContextMenus();
        }, ZE),
        d = () => {
          p()?.catch(l);
        };
      re.on("workspaces-loaded", d),
        this.featureFlagsRepository.onFeatureFlagsLoaded(d),
        this.browserEventsService.subscribeToNormalWindowFocusChanged(d),
        this.contextMenuService.subscribeToTabMenuItemClicked(
          ({ scope: u, payload: m }) => {
            u === "task" && this.handleTabMenuItemClick(m).catch(l);
          }
        ),
        this.contextMenuService.subscribeToContextMenuItemClicked(
          ({ scope: u, payload: m }) => {
            u === "task" && this.handleNativeMenuItemClick(m);
          }
        );
    }
    async createTask(e, t) {
      this.sidecarService.isTasksSidecarOpen(t) ||
        (await this.sidecarService.toggleTasks({ source: "context-menu" }, t)),
        await this.taskTrackerService.handleCreateTask(e),
        this.analytics.sendAnalyticsEvent("context-menu.create-task", void 0);
    }
    async createContextMenus() {
      let e = {
        title: P("context_menu__create_task_item"),
        id: "root",
        contexts: ["link", "selection"],
      };
      await this.contextMenuService.updateNativeContextMenu("task", e),
        await this.contextMenuService.updateTabContextMenu("task", e);
    }
    async updateContextMenus() {
      await this.clearContextMenus(),
        this.featureFlagsRepository.getFeatureFlag("tasksEnabled") &&
          (await this.createContextMenus());
    }
    async clearContextMenus() {
      await this.contextMenuService.clearNativeContextMenu("task"),
        await this.contextMenuService.clearTabContextMenu("task");
    }
    async handleTabMenuItemClick({ tabId: e }) {
      let t = await this.browserService.getTabById(e);
      t?.url && this.createTask({ url: t.url }, t.windowId).catch(l);
    }
    handleNativeMenuItemClick(e) {
      let t = e.tab?.id,
        r = e.tab?.windowId;
      if (!t || !r) return;
      let i;
      e.onClickData.linkUrl
        ? (i = { url: e.onClickData.linkUrl })
        : (i = {
            description: e.onClickData.selectionText,
            url: e.onClickData.pageUrl,
          }),
        this.createTask(i, r).catch(l);
    }
  };
c();
var Xp = class {
  constructor(e, t, r, i, s) {
    this.browserService = e;
    this.analyticsTracker = t;
    this.browserStorage = r;
    (this.isWatchdogEnabled = Boolean(i.getFeatureFlags().extensionWatchdog)),
      this.sendWatchdogAnalytics().catch(l),
      this.isWatchdogEnabled &&
        s.subscribeToExtensionPingPong(() => {
          this.browserService.pongBrowser();
        });
  }
  isWatchdogEnabled;
  async sendWatchdogAnalytics() {
    let e = await this.browserStorage.getGlobalItem(
      "was_restarted_by_watchdog"
    );
    typeof e < "u" &&
      (await this.browserStorage.removeGlobalItem("was_restarted_by_watchdog")),
      e &&
        this.analyticsTracker.sendAnalyticsEvent(
          "system.extension-watchdoged",
          void 0
        );
  }
};
c();
var Jp = class {
  constructor(e, t, r) {
    this.browserStorage = e;
    this.browserService = t;
    this.analyticsTracker = r;
    this.trySetupCrashSender().catch(l);
  }
  timeoutMinutes = 120;
  intervalMinutes = 60;
  async trySetupCrashSender() {
    (await la()) ||
      (this.sendCrashes().catch(l),
      setInterval(() => {
        this.sendCrashes().catch(l);
      }, ye(this.intervalMinutes)));
  }
  async sendCrashes() {
    let e = Date.now();
    if (await this.isEarlyToSend(e)) return;
    let r = await this.browserService.getNotUploadedCrashes();
    r.length &&
      (this.browserService.requestMultipleUpload(),
      await this.browserStorage.setGlobalItem("crashes-last-sent", e),
      r.forEach(({ localId: i }) => {
        this.analyticsTracker.sendAnalyticsEvent(
          "system.crash-uploading-requested",
          { localId: i }
        );
      }));
  }
  async isEarlyToSend(e) {
    let t = (await this.browserStorage.getGlobalItem("crashes-last-sent")) ?? 0,
      r = ye(this.timeoutMinutes);
    return e - t <= r;
  }
};
c();
var uo = "default-browser-popup-alarm",
  Zp = class {
    constructor(e, t, r, i, s, a, n, p) {
      this.browserService = e;
      this.featureFlagsRepository = t;
      this.browserStorage = r;
      this.uiNotificationsManager = i;
      this.browserEventsService = s;
      this.billingRepository = a;
      this.analytics = n;
      this.actualUsageDaysRepository = p;
      let d = !1,
        u = !1;
      this.featureFlagsRepository.onFeatureFlagsLoaded((m, y) => {
        y ||
          ((d = !0),
          this.initDefaultBrowserPopupFeature().catch(l),
          u && ((u = !1), this.tryShowBrowserMakeDefaultPopup().catch(l)));
      }),
        se.on("billing-plan-loaded", () => {
          d && this.trySetupInterval().catch(l);
        }),
        this.browserEventsService.subscribeToAlarm((m) => {
          if (m.name === uo) {
            if (!d) {
              u = !0;
              return;
            }
            this.tryShowBrowserMakeDefaultPopup().catch(l);
          }
        }),
        this.tryShowAfterStart().catch(l);
    }
    getTimeDelayForShowingPopup() {
      let {
        intervalForFirstPeriodInHours: e,
        intervalForOtherPeriodInHours: t,
      } = this.featureFlagsRepository.getFeatureFlag(
        "defaultBrowserNotificationV3"
      );
      return this.isFirstPeriodOfBrowserUsage() ? e : t;
    }
    isFirstPeriodOfBrowserUsage() {
      let e = this.actualUsageDaysRepository.getCount() ?? 0,
        { firstPeriodInDays: t } = this.featureFlagsRepository.getFeatureFlag(
          "defaultBrowserNotificationV3"
        );
      return e <= t;
    }
    async initDefaultBrowserPopupFeature() {
      let e = await this.getCount(),
        t = await this.tryDisableFeature(),
        r = await this.browserService.getAlarmByName(uo);
      if (!(t || r)) {
        if (!e) {
          let { delayFromOnboardingInHours: i } =
              this.featureFlagsRepository.getFeatureFlag(
                "defaultBrowserNotificationV3"
              ),
            s = Bu(i);
          await this.setAlarm({ delayInMinutes: s });
          return;
        }
        await this.trySetupInterval();
      }
    }
    makeBrowserDefault() {
      return this.browserService.startSetAsDefaultBrowser();
    }
    async showBrowserMakeDefaultPopupExternal() {
      if (await this.browserService.isDefaultBrowser()) return;
      let t = (await this.getCount()) + 1;
      this.showNotification(t);
    }
    async trySetupInterval() {
      let e = this.getTimeDelayForShowingPopup(),
        t = Bu(e);
      (await this.browserService.getAlarmByName(uo))?.periodInMinutes !== t &&
        (await this.disableFeature(),
        await this.setAlarm({ periodInMinutes: t }));
    }
    async tryShowBrowserMakeDefaultPopup() {
      if (await this.tryDisableBecauseAlreadyDefault()) return;
      let e = await this.increaseShowingCounter();
      this.showNotification(e),
        !(await this.tryDisableFeature()) &&
          (await this.trySetupInterval(), await this.updateScheduledAt());
    }
    async tryShowAfterStart() {
      let e = await this.browserStorage.getItem(
        "default-browser-notifications-alarm-scheduled-at"
      );
      if (!e) return;
      let t = await this.browserService.getAlarmByName(uo);
      if (!t) {
        await this.tryShowBrowserMakeDefaultPopup();
        return;
      }
      if (!t.periodInMinutes) return;
      let r = ye(t.periodInMinutes);
      Math.floor(t.scheduledTime) - e > r &&
        (await this.tryShowBrowserMakeDefaultPopup());
    }
    async tryDisableFeature() {
      return this.featureFlagsRepository.getFeatureFlag(
        "defaultBrowserNotificationV3Enabled"
      )
        ? this.tryDisableBecauseAlreadyDefault()
        : (await this.disableFeature(), !0);
    }
    async tryDisableBecauseAlreadyDefault() {
      return (await this.browserService.isDefaultBrowser())
        ? (await this.disableFeature(), !0)
        : !1;
    }
    async disableFeature() {
      return (
        await this.browserStorage.removeItem(
          "default-browser-notifications-alarm-scheduled-at"
        ),
        this.browserService.clearAlarmByName(uo)
      );
    }
    showNotification(e) {
      let { useDefaultBrowserUI: t } =
        this.featureFlagsRepository.getFeatureFlag(
          "defaultBrowserNotificationV3"
        );
      return t
        ? (this.analytics.sendAnalyticsEvent(
            "default-browser.setup-reminder-popup.auto-opened",
            { "count-showed": e, "is-default-ui": !0 }
          ),
          this.browserService.showDefaultBrowserPrompt())
        : this.uiNotificationsManager.showDefaultBrowserSetupNotification(e);
    }
    setAlarm(e) {
      return this.browserService.createAlarm(uo, e), this.updateScheduledAt();
    }
    updateScheduledAt() {
      return this.browserStorage.setItem(
        "default-browser-notifications-alarm-scheduled-at",
        Date.now()
      );
    }
    async increaseShowingCounter() {
      let t = (await this.getCount()) + 1;
      return (
        await this.browserStorage.setItem(
          "default-browser-notificaitons-count",
          t
        ),
        t
      );
    }
    async getCount() {
      return (
        (await this.browserStorage.getItem(
          "default-browser-notificaitons-count"
        )) ?? 0
      );
    }
  };
c();
var el = "distraction-blocker-delay-alarm",
  tl = class {
    constructor(e, t, r, i, s, a, n) {
      this.modalService = e;
      this.browserService = t;
      this.browserEventsService = r;
      this.featureFlagsRepository = i;
      this.onboardingDataService = s;
      this.userSettingsService = a;
      this.userSettingsRepository = n;
      this.restartRedirectingObserver(),
        W.onSeveral(Ce, (p) => {
          (oe(p, "distractionBlockerRules") ||
            oe(p, "distractionBlockerSchedule") ||
            oe(p, "isDistractionBlockerEnabled")) &&
            this.restartRedirectingObserver();
        }),
        this.browserEventsService.subscribeToAlarm((p) => {
          p.name === el && this.showIntro().catch(l);
        }),
        this.featureFlagsRepository.onFeatureFlagsLoaded((p) => {
          p.distractionBlocker &&
            (this.tryShowIntro().catch(l), this.restartRedirectingObserver());
        });
    }
    unsubscribeBeforeRequest = null;
    unsubscribeBeforeRedirect = null;
    async tryShowIntro() {
      let { isDistractionBlockerIntroShowed: e } =
        this.userSettingsRepository.getSettings();
      if (e) {
        await this.browserService.clearAlarmByName(el);
        return;
      }
      if (await this.browserService.getAlarmByName(el)) return;
      if (this.onboardingDataService.getIsInitialOnboarding()) {
        let { introPopupDelayHours: i } =
          this.featureFlagsRepository.getFeatureFlag("distractionBlocker");
        this.browserService.createAlarm(el, { when: Date.now() + xe(i) });
        return;
      }
      await this.showIntro();
    }
    async showIntro() {
      let { isDistractionBlockerIntroShowed: e } =
        this.userSettingsRepository.getSettings();
      if (e) return;
      let t = this.featureFlagsRepository.getFeatureFlag(
          "isDistractionBlockerEnabled"
        ),
        { isIntroPopupEnabled: r } =
          this.featureFlagsRepository.getFeatureFlag("distractionBlocker");
      t &&
        r &&
        (this.userSettingsService.markDistractionBlockerIntroShowed(),
        await this.modalService.showDistractionBlockerIntroModal({
          source: "auto",
        }));
    }
    restartRedirectingObserver() {
      if (
        (this.unsubscribeBeforeRequest &&
          (this.unsubscribeBeforeRequest(),
          (this.unsubscribeBeforeRequest = null)),
        this.unsubscribeBeforeRedirect &&
          (this.unsubscribeBeforeRedirect(),
          (this.unsubscribeBeforeRedirect = null)),
        !this.getEnabled())
      )
        return;
      let e =
        this.getRules()
          .map(({ from: t }) => ib(t))
          .flat() ?? [];
      (this.unsubscribeBeforeRedirect =
        this.browserEventsService.subscribeToBeforeRedirect(
          async ({ redirectUrl: t, tabId: r }) => {
            let i = await this.browserService.getAllTabs({
              lastFocusedWindow: !0,
              url: `${t}*`,
              hidden: !1,
            });
            i?.[0]?.id &&
              (await this.browserService.activateTab(i[0].id),
              await this.browserService.closeTab(r));
          },
          { urls: e, types: ["main_frame"] }
        )),
        (this.unsubscribeBeforeRequest =
          this.browserEventsService.subscribeToBeforeRequest(
            (t) => {
              if (!this.isNowInSchedule(this.getSchedule())) return {};
              let r = this.getRules().find(({ from: i }) => t.url.includes(i));
              return r ? { redirectUrl: Ht(r.to) } : {};
            },
            { urls: e, types: ["main_frame"] },
            ["blocking"]
          ));
    }
    isNowInSchedule(e) {
      let t = new Date();
      return e.weekdays.includes(t.getDay())
        ? e.allDay || Zy(e.from, e.to, t)
        : !1;
    }
    getEnabled() {
      return (
        this.featureFlagsRepository.getFeatureFlag(
          "isDistractionBlockerEnabled"
        ) &&
        this.userSettingsRepository.getSettings().isDistractionBlockerEnabled
      );
    }
    getRules() {
      return (
        this.userSettingsRepository.getSettings().distractionBlockerRules ??
        this.getDefaultRules()
      );
    }
    getSchedule() {
      return (
        this.userSettingsRepository.getSettings().distractionBlockerSchedule ??
        this.getDefaultSchedule()
      );
    }
    getDefaultRules() {
      let { rules: e } =
        this.featureFlagsRepository.getFeatureFlag("distractionBlocker");
      return e.map(({ from: t, to: r }) => ({ id: le(), from: t, to: r }));
    }
    getDefaultSchedule() {
      let { schedule: e } =
          this.featureFlagsRepository.getFeatureFlag("distractionBlocker"),
        t = Cu(e?.from),
        r = Cu(e?.to);
      (!t || !r) &&
        l(
          new L('Invalid from/to on "distractionBlocker" feature flag', {
            tags: { from: e.from, to: e.to },
          })
        );
      let i = e?.weekdays?.reduce((s, a) => {
        let n = Jy(a);
        return (
          n
            ? s.push(n)
            : l(
                new L('Invalid weekday on "distractionBlocker" feature flag', {
                  tags: { weekday: a },
                })
              ),
          s
        );
      }, []);
      return {
        allDay: e?.allDay ?? !0,
        from: t ?? { hours: 9, minutes: 0 },
        to: r ?? { hours: 18, minutes: 0 },
        weekdays: i ?? [],
      };
    }
  };
c();
var rl = class {
  constructor(e) {
    this.browserStorage = e;
    this.loadFromStorage().catch(l);
  }
  exploredFeatures = null;
  emitter = new A();
  onExploredLoaded(e) {
    return this.emitter.on("data-loaded", e);
  }
  onExploredUpdated(e) {
    return this.emitter.on("data-updated", e);
  }
  explore(e) {
    this.markAsExplored(e).catch(l);
  }
  async markAsExplored(e) {
    this.exploredFeatures === null &&
      (await new Promise((r) => {
        this.emitter.once("data-loaded", () => r(void 0));
      })),
      g(
        this.exploredFeatures,
        "Failed to mark feature as explored: no explored features"
      );
    let t = this.exploredFeatures.has(e);
    return (
      this.exploredFeatures.add(e),
      this.emitter.emit("data-updated", e, t),
      this.writeIntoStorage()
    );
  }
  getIsFeatureExplored(e) {
    return this.exploredFeatures?.has(e);
  }
  getIsFeatureUnexplored(e) {
    let t = this.getIsFeatureExplored(e);
    return t !== void 0 ? !t : void 0;
  }
  async loadFromStorage() {
    let e = (await this.browserStorage.getItem("explored")) ?? [];
    (this.exploredFeatures = new Set(e)), this.emitter.emit("data-loaded");
  }
  async writeIntoStorage() {
    this.exploredFeatures &&
      (await this.browserStorage.setItem(
        "explored",
        Array.from(this.exploredFeatures)
      ));
  }
};
c();
var il = class {
  constructor(e, t, r, i, s) {
    this.browserService = e;
    this.browserStorage = t;
    this.analyticsTracker = r;
    this.featureFlagsRepository = i;
    s.subscribeToIdleStateChanged((a) => {
      (a !== "idle" && a !== "locked") || this.tryRestartExtension().catch(l);
    }),
      ee(this.sendAnalyticsEvent());
  }
  initializedAt = Date.now();
  async tryRestartExtension() {
    await this.sendAnalyticsEvent();
    let { current: e, all: t } = await this.getExtensionProcesses();
    if (!e || !this.isOverLimits(e)) return;
    let r = await this.createSnapshotBeforeKick(e, t);
    if (!this.canBeKickedNow(r.at)) {
      let i = new L("Early kick", { level: "warning", extra: { snapshot: r } });
      l(i);
      return;
    }
    await this.browserStorage.setGlobalItem("extension-kicked", r),
      this.browserService.restartExtension();
  }
  async sendAnalyticsEvent() {
    let e = await this.browserStorage.getGlobalItem("extension-kicked");
    if (!e) return;
    let { current: t, all: r } = await this.getExtensionProcesses();
    if (!t) {
      setTimeout(() => ee(this.sendAnalyticsEvent()), ye(1));
      return;
    }
    await this.browserStorage.removeGlobalItem("extension-kicked");
    let i = await this.browserService.getWindowsById({ populate: !0 }),
      s = Object.values(i).flatMap((p) => p.tabs ?? []),
      a = this.createSnapshotAfterKick(t, r, s, i),
      n = this.createKickerEvent(e, a);
    this.analyticsTracker.sendAnalyticsEvent("system.extension-kicked", n);
  }
  async createSnapshotBeforeKick(e, t) {
    let { jsMemoryUsed: r = -1, privateMemory: i = -1 } = e ?? {},
      { maxUsedJSHeap: s, maxPrivateMemory: a } =
        this.featureFlagsRepository.getFeatureFlags().extensionKicker,
      n = await this.browserService.getWindowsById({ populate: !0 }),
      p = Object.values(n).flatMap((u) => u.tabs ?? []),
      d = Date.now();
    return {
      ...this.extractCommonInfo(t),
      at: d,
      uptime: d - this.initializedAt,
      jsMemoryUsed: r,
      jsMemoryUsedLimit: s,
      privateMemory: i,
      privateMemoryLimit: a,
      ...this.createTabsSnapshot(p),
      ...this.createWindowsSnapshot(n),
    };
  }
  createSnapshotAfterKick(e, t, r, i) {
    let { jsMemoryUsed: s = -1, privateMemory: a = -1 } = e,
      {
        totalJSHeapSize: n,
        usedJSHeapSize: p,
        jsHeapSizeLimit: d,
      } = window.performance.memory;
    return {
      ...this.extractCommonInfo(t),
      totalJSHeapSize: n,
      usedJSHeapSize: p,
      jsHeapSizeLimit: d,
      jsMemoryUsed: s,
      privateMemory: a,
      ...this.createTabsSnapshot(r),
      ...this.createWindowsSnapshot(i),
    };
  }
  extractCommonInfo(e) {
    return {
      extensionsCount: e.length,
      extensionsContexts: e
        .map((t) => t.tasks.map((r) => r.title).join(","))
        .join(" --- "),
      extensionsTabIds: e
        .map((t) =>
          t.tasks
            .map((r) => r.tabId)
            .filter(Boolean)
            .join(",")
        )
        .join(" --- "),
    };
  }
  createTabsSnapshot(e) {
    let t = e.filter((r) => r.discarded);
    return { tabsCount: e.length, discardedTabsCount: t.length };
  }
  createWindowsSnapshot(e) {
    return {
      openSidebars: Object.values(e).filter((r) => r.type === "normal").length,
      openWindows: Object.values(e).length,
    };
  }
  createKickerEvent(e, t) {
    return {
      ...t,
      uptime: e.uptime,
      prevUsedJSHeapSize: e.jsMemoryUsed,
      prevMaxUsedJSHeapSize: e.jsMemoryUsedLimit,
      prevPrivateMemory: e.privateMemory,
      prevMaxPrivateMemory: e.privateMemoryLimit,
      restartDelay: this.initializedAt - (Number(e.at) || 0),
      prevTabsCount: e.tabsCount,
      prevDiscardedTabsCount: e.discardedTabsCount,
      prevExtensionsCount: e.extensionsCount,
      prevExtensionsContexts: e.extensionsContexts,
      prevExtensionsTabIds: e.extensionsTabIds,
      everOpenSidebars: e.openSidebars,
      everOpenWindows: e.openWindows,
    };
  }
  isOverLimits(e) {
    let { jsMemoryUsed: t = 0, privateMemory: r = 0 } = e,
      { maxUsedJSHeap: i, maxPrivateMemory: s } =
        this.featureFlagsRepository.getFeatureFlags().extensionKicker;
    return t > i || r > s;
  }
  canBeKickedNow(e) {
    let { earlyKickTimeout: t } =
      this.featureFlagsRepository.getFeatureFlags().extensionKicker;
    return e - this.initializedAt >= ce(t);
  }
  async getExtensionProcesses() {
    let [e, t] = await Promise.all([
        this.browserService.getAllProcesses(),
        this.browserService.getProfileName(),
      ]),
      r = e.filter((s) => cw(s));
    return { current: r.find((s) => s.profile === t), all: r };
  }
};
c();
c();
var uw = (o, e) => Math.floor(Math.random() * (e - o + 1) + o);
var eB = "reload-features",
  ol = class {
    constructor(e, t, r, i) {
      this.featureFlagsRepository = e;
      this.backendService = t;
      this.loadFeatureFlags().catch(l),
        r.task(eB, () => this.loadFeatureFlags().catch(l)).everySixHours(),
        i.subscribe("features.update", () => {
          setTimeout(() => {
            this.loadFeatureFlags().catch(l);
          }, this.getDelayForReloadingAfterPush());
        });
    }
    getDelayForReloadingAfterPush() {
      let e =
        this.featureFlagsRepository.getFeatureFlag("featuresUpdater")
          .maxDelay ?? 6e4;
      return uw(0, e);
    }
    async loadFeatureFlags() {
      let e = await this.backendService.desktop.getFeatures(),
        t = Object.fromEntries(
          e.map((r) => {
            let i = r.name,
              s = { params: r.data, works: r.works || !1 };
            return [i, s];
          })
        );
      this.featureFlagsRepository.setStateFromNetwork(t);
    }
  };
c();
c();
var tB = [Ib.id, Ab.id],
  sl = class {
    constructor(e, t, r, i, s, a, n, p, d, u, m, y) {
      this.externalAuthService = e;
      this.googleApiService = t;
      this.notificationsManager = r;
      this.invitationsRepository = i;
      this.featureFlagsRepository = s;
      this.applicationRepository = a;
      this.accountRepository = n;
      this.userSettingsRepository = p;
      this.browserStorage = d;
      this.userApi = u;
      this.billingRepository = m;
      this.analyticsTracker = y;
      this.userApi.setGmailSignatureDisabled();
      let b = () => {
        let v = this.featureFlagsRepository.getFeatureFlag(
            "gmailSignatureEnabled"
          ),
          { wasGmailSignatureSet: S } =
            this.userSettingsRepository.getSettings(),
          w =
            this.billingRepository.getIsPaid() ||
            this.billingRepository.getIsPro() ||
            this.billingRepository.getIsTrial();
        if (S) {
          this.reportIfSignatureChanged().catch(l);
          return;
        }
        return !v || w ? this.disable() : this.initListening();
      };
      this.featureFlagsRepository.onFeatureFlagsLoaded(b),
        se.on("billing-plan-loaded", b),
        W.on("user-settings-loaded", b),
        this.initSignatureCheckInterval(),
        b();
    }
    unsubscribeFn;
    subscriptions = [];
    checkSignatureInterval = null;
    initListening() {
      this.unsubscribeFn ||
        (this.unsubscribeFn = D.on("apps-activated", (e) => {
          let { wasGmailSignatureSet: t } =
            this.userSettingsRepository.getSettings();
          if (t) {
            this.reportIfSignatureChanged().catch(l), this.disable();
            return;
          }
          let r = this.applicationRepository.getAppById(e);
          !r ||
            !tB.includes(r.recipeId) ||
            !this.accountRepository.getAccountsByApp(r).length ||
            this.tryShow().catch(l);
        }));
    }
    initSignatureCheckInterval() {
      this.checkSignatureInterval = setInterval(() => {
        this.reportIfSignatureChanged().catch(l);
      }, xe(1));
    }
    disable() {
      this.unsubscribeFn?.();
    }
    async reportIfSignatureChanged(e = !1) {
      let { wasGmailSignatureSet: t } =
        this.userSettingsRepository.getSettings();
      if (!t) return;
      let r = this.getCredentials(),
        i = Object.entries(r)[0]?.[1];
      if (i)
        try {
          let s = await this.googleApiService.getSignatures(i.accessToken),
            a = !1;
          if (
            (s.sendAs.forEach((n) => {
              !n.isDefault ||
                !n.isPrimary ||
                (a = n.signature.includes("Sidekick Browser"));
            }),
            a)
          )
            return;
          this.analyticsTracker.sendAnalyticsEvent(
            "gmail-signature.is-default",
            { isStillDefault: a }
          ),
            clearInterval(this.checkSignatureInterval ?? void 0);
        } catch {
          if (e) return;
          await this.googleApiService.tryRefreshToken(i.refreshToken),
            await this.reportIfSignatureChanged(!0);
        }
    }
    async tryShow() {
      let { intervalBetweenShowingDays: e } =
          this.featureFlagsRepository.getFeatureFlag("gmailSignature"),
        t = await this.browserStorage.getItem(
          "gmail-signature-auth-request-showed-at"
        );
      (t && pt(e) > Date.now() - t) ||
        (this.notificationsManager.showGmailSignatureNotification(),
        this.analyticsTracker.sendAnalyticsEvent(
          "gmail-signature.showed",
          void 0
        ),
        await this.browserStorage.setItem(
          "gmail-signature-auth-request-showed-at",
          Date.now()
        ));
    }
    async makeGmailSignature(e, t) {
      if (
        !this.featureFlagsRepository.getFeatureFlag("gmailSignatureEnabled")
      ) {
        this.removeOauthData(e);
        return;
      }
      let s = this.getCredentials()[e];
      g(s, "No credentials provided"),
        this.externalAuthService.setOauthData("google", "EMAIL_SIGNATURES", s);
      let a = this.invitationsRepository.getInviteLink(),
        n = Gt(a),
        p = n?.pathname.slice(1);
      n?.pathname && p && (n.pathname = `/_${p}`);
      let d = P("gmail_signature__text", [n?.href ?? a]);
      await this.googleApiService.makeGmailSignature(s.accessToken, d),
        this.analyticsTracker.sendAnalyticsEvent("gmail-signature.created", {
          source: t,
        }),
        this.removeOauthData(e),
        this.userApi.setGmailSignature(),
        this.disable(),
        await this.browserStorage.removeItem(
          "gmail-signature-auth-request-showed-at"
        );
    }
    removeOauthData(e) {
      this.externalAuthService.removeOauthData("google", "EMAIL_SIGNATURES", e);
    }
    getCredentials() {
      let e = this.externalAuthService.getGoogleCredentials("EMAIL_SIGNATURES");
      return g(e, "No credentials for gmail"), e;
    }
  };
c();
c();
var al = class {
  constructor(e, t, r) {
    this.featureFlagsRepository = e;
    this.helpService = t;
    this.helpServiceV2 = r;
    this.featureFlagsRepository.onFeatureFlagsLoaded(() => {
      this.setUseExploreSidekickV2();
    }),
      this.setUseExploreSidekickV2();
  }
  useExploreSidekickV2 = !1;
  onHelpStateChanged(e) {
    return [
      this.helpServiceV2.onHelpStateChanged(e),
      this.helpService.onHelpStateChanged(e),
    ];
  }
  getProgress() {
    return this.useExploreSidekickV2
      ? this.helpServiceV2.getTotalProgress()
      : this.helpService.getProgress();
  }
  getIsNtpMode() {
    return this.useExploreSidekickV2 ? this.helpServiceV2.getIsNtpMode() : !1;
  }
  setUseExploreSidekickV2() {
    this.useExploreSidekickV2 = this.featureFlagsRepository.getFeatureFlag(
      "enableExploreSidekickV2"
    );
  }
};
c();
var nl = class {
  constructor(e, t, r, i) {
    this.browserStorage = e;
    this.modalService = t;
    this.analytics = r;
    this.invitationsRepository = i;
    (this.completedList = []),
      (this.progress = 0.12),
      this.loadCompletedList().catch(l);
  }
  completedList;
  progress;
  emitter = new A();
  logger = x.createInstance("help");
  onHelpStateChanged(e) {
    return this.emitter.on("complete-list-changed", e);
  }
  addItemCompleteList(e) {
    this.completedList.push(e),
      this.calculateProgress(),
      this.emitter.emit("complete-list-changed"),
      this.browserStorage
        .setItem("checklist-completed", this.completedList)
        .catch(l),
      this.analytics.sendAnalyticsEvent(
        "help.explore-item.marked-as-completed",
        {
          "help.checklist.id": void 0,
          "explore-item.id": e,
          "explore-item.is-secret": Cb.includes(e),
          "explore.completed-count": this.completedList.length,
          "explore.total-count": Nu.length,
        }
      ),
      this.progress === 1 &&
        (this.analytics.sendAnalyticsEvent("help.auto-completed", {
          "help.checklist.id": void 0,
        }),
        this.modalService
          .showChecklistSuccessModal({
            source: "help.explore-item.marked-as-completed",
            inviteLink: this.invitationsRepository.getInviteLink(),
          })
          .catch(l));
  }
  getCompletedList() {
    return this.completedList;
  }
  getProgress() {
    return this.progress;
  }
  async loadCompletedList() {
    let e = await this.browserStorage.getItem("checklist-completed");
    e &&
      ((this.completedList = e.slice()),
      this.calculateProgress(),
      this.logger.info("Help data loaded", this.completedList, this.progress),
      this.emitter.emit("complete-list-changed"));
  }
  calculateProgress() {
    let e = this.completedList.length,
      t = Nu.length;
    this.progress = (e / t) * 0.88 + 0.12;
  }
};
c();
c();
var mo = (o) => !!o;
var hs = {
    ["productivity"]: Object.values(Lu),
    ["focus-and-discipline"]: Object.values(_b),
    ["getting-things-done"]: Object.values(Fb),
    ["superhero-mode"]: Object.values(Mb),
  },
  iB = {
    ["productivity"]: {
      completed: [],
      available: hs["productivity"],
      progress: 0,
    },
    ["focus-and-discipline"]: {
      completed: [],
      available: hs["focus-and-discipline"],
      progress: 0,
    },
    ["getting-things-done"]: {
      completed: [],
      available: hs["getting-things-done"],
      progress: 0,
    },
    ["superhero-mode"]: {
      completed: [],
      available: hs["superhero-mode"],
      progress: 0,
    },
  },
  cl = class {
    constructor(e, t, r, i, s) {
      this.browserStorage = e;
      this.analytics = t;
      this.featureFlagsRepository = r;
      this.popupService = i;
      this.collectionsRepository = s;
      (this.checklists = { ...iB }),
        this.featureFlagsRepository.onFeatureFlagsLoaded(() => {
          this.initChecklists().catch(l);
        }),
        this.initChecklists().catch(l);
    }
    checklists;
    emitter = new A();
    logger = x.createInstance("help");
    isNtpMode = !1;
    isSuperheroModeUnlocked = !1;
    onHelpStateChanged(e) {
      return this.emitter.on("state-changed", e);
    }
    getProductivityChecklist() {
      return this.checklists["productivity"];
    }
    getFocusAndDisciplineChecklist() {
      return this.checklists["focus-and-discipline"];
    }
    getGettingThingsDoneChecklist() {
      return this.checklists["getting-things-done"];
    }
    getSuperheroModeChecklist() {
      return this.checklists["superhero-mode"];
    }
    getTasksAndCollectionsButtonText(e) {
      let t =
          this.collectionsRepository.isCollectionsEnabledForWorkspaceByWindowId(
            e
          ),
        r = this.featureFlagsRepository.getFeatureFlag("tasksEnabled");
      return [
        t && P("sidecar_collections__title"),
        r && P("sidecar_tasks__title"),
      ]
        .filter(mo)
        .join(" & ");
    }
    getTotalProgress() {
      let e = Object.values(jo).reduce(
        (r, i) => r + this.checklists[i].available.length,
        0
      );
      return (
        Object.values(jo).reduce(
          (r, i) => r + this.checklists[i].completed.length,
          0
        ) / e
      );
    }
    setItemCompleted(e, t) {
      let r = this.addCompletedItemToChecklist(e, t);
      (this.isSuperheroModeUnlocked = this.checkIsSuperheroModeUnlocked()),
        this.emitter.emit("state-changed"),
        this.browserStorage.setItem("help-checklists", r).catch(l),
        this.analytics.sendAnalyticsEvent(
          "help.explore-item.marked-as-completed",
          {
            "help.checklist.id": e,
            "explore-item.id": t,
            "explore-item.is-secret": !1,
            "explore.completed-count": r[e].completed.length,
            "explore.total-count": r[e].available.length,
          }
        ),
        this.isChecklistCompleted(e) && this.handleChecklistCompleted(e);
    }
    getIsSuperheroModeUnlocked() {
      return this.isSuperheroModeUnlocked;
    }
    getIsNtpMode() {
      return this.isNtpMode;
    }
    async toggleExploreSidekickPopup(e) {
      await this.popupService.showLaunchpadPopup(e ? "explore-sidekick" : null);
    }
    async initChecklists() {
      await this.loadChecklists(),
        (this.isNtpMode =
          this.featureFlagsRepository.getFeatureFlag(
            "enableExploreSidekickV2"
          ) &&
          this.featureFlagsRepository.getFeatureFlag("exploreSidekickV2")
            .isNtpMode),
        this.emitter.emit("state-changed");
    }
    async loadChecklists() {
      let e = await this.browserStorage.getItem("help-checklists");
      if (!e) {
        (this.checklists = this.filterEachChecklistByFeatureFlags(
          this.checklists
        )),
          (this.isSuperheroModeUnlocked = this.checkIsSuperheroModeUnlocked());
        return;
      }
      (this.checklists = this.filterEachChecklistByFeatureFlags(e)),
        (this.isSuperheroModeUnlocked = this.checkIsSuperheroModeUnlocked()),
        this.logger.info("Help data loaded", this.checklists);
    }
    addCompletedItemToChecklist(e, t) {
      let r = this.checklists[e];
      this.assertItemCompletable(r, t);
      let i = [...r.completed, t],
        s = { ...r, completed: i, progress: i.length / r.available.length };
      return (
        (this.checklists = { ...this.checklists, [e]: s }), this.checklists
      );
    }
    isChecklistCompleted(e) {
      if (e === "superhero-mode") {
        let {
            completed: r,
            available: i,
            progress: s,
          } = this.checklists["superhero-mode"],
          a = i.length - r.length === 1 && !r.includes("invite-friends");
        return s === Gu || a;
      }
      let { progress: t } = this.checklists[e];
      return t === Gu;
    }
    checkIsSuperheroModeUnlocked() {
      return (
        this.isChecklistCompleted("productivity") &&
        this.isChecklistCompleted("focus-and-discipline") &&
        this.isChecklistCompleted("getting-things-done")
      );
    }
    handleChecklistCompleted(e) {
      let t = {
        ["productivity"]: "help.auto-opened.productivity-done",
        ["getting-things-done"]: "help.auto-opened.things-done",
        ["focus-and-discipline"]: "help.auto-opened.focus-and-discipline-done",
        ["superhero-mode"]: "help.auto-opened.superhero-mode-done",
      };
      t[e] && this.analytics.sendAnalyticsEvent(t[e], void 0);
    }
    filterEachChecklistByFeatureFlags(e) {
      let t = { ...e };
      return (
        Object.values(jo).forEach((r) => {
          t = { ...t, [r]: this.filterChecklistByFeatureFlags(r, e[r]) };
        }),
        t
      );
    }
    assertItemCompletable(e, t) {
      g(e.available.includes(t), `${t} is not available to complete`),
        g(
          !this.retrieveCompletedList(e).includes(t),
          `${t} is already completed`
        );
    }
    retrieveCompletedList(e) {
      let { completed: t } = e;
      return t;
    }
    filterChecklistByFeatureFlags(e, t) {
      let r = this.retrieveCompletedList(t),
        s = hs[e].filter(this.isChecklistItemEnabled.bind(this)),
        a = r.filter(this.isChecklistItemEnabled.bind(this)),
        n = a.length / s.length;
      return { available: s, completed: a, progress: n };
    }
    isChecklistItemEnabled(e) {
      let t = this.featureFlagsRepository.getFeatureFlags();
      return e === "finish-walkthrough"
        ? t.enableExploreSidekickV2 && t.exploreSidekickV2.isNtpMode
        : e === "fullscreen-focus-mode"
        ? t.focusModeShortcutEnabled
        : e === "mute-notifications"
        ? t.isMuteNotificationsPopupEnabled
        : e === "distraction-blocker"
        ? t.isDistractionBlockerEnabled
        : e === "task-pin" || e === "task-manager"
        ? t.tasksEnabled
        : e === "calendar"
        ? t.calendarsIntegrationEnabled
        : e === "sync"
        ? t.sync
        : !0;
    }
  };
var mw = ({
  browserStorage: o,
  popupService: e,
  featureFlagsRepository: t,
  analytics: r,
  modalService: i,
  invitationsRepository: s,
  collectionsRepository: a,
}) => {
  let n = new nl(o, i, r, s),
    p = new cl(o, r, t, e, a);
  return [n, p, new al(t, n, p)];
};
c();
c();
var pl = class {
  constructor(e, t) {
    this.hintsService = e;
    this.hintsShortcutsService = t;
  }
  closeAndMarkHintAsShowed(e) {
    this.hintsService.closeAndMarkHintAsShowed(e);
  }
  getShortcutByHintMap() {
    return this.hintsShortcutsService.getShortcutByHintMap();
  }
};
c();
var ll = class {
  constructor(e) {
    this.browserStorage = e;
  }
  hintsShowedMetaById = this.loadDefaultData();
  async loadHintsData() {
    let e = await this.browserStorage.getItem("hints-showed-data");
    if (!e) return;
    let t = { ...this.hintsShowedMetaById, ...e };
    this.hintsShowedMetaById = t;
  }
  getWasHintShortcutUsed(e, t, r) {
    let i = this.getHintData(e);
    if (!i.latestShortcutsUsedDates) return !1;
    let s = new Date();
    s.setHours(s.getHours() - t);
    let a = s.getTime();
    return i.latestShortcutsUsedDates.filter((p) => p >= a).length >= r;
  }
  getWasHintShowed(e, t) {
    let r = this.getHintData(e);
    if (!r.lastShowedDate) return !1;
    let i = new Date();
    return i.setHours(i.getHours() - t), i.getTime() < r.lastShowedDate;
  }
  getHintData(e) {
    return this.hintsShowedMetaById[e];
  }
  updateHintLastShowedDate(e) {
    (this.hintsShowedMetaById[e] = {
      ...this.hintsShowedMetaById[e],
      lastShowedDate: Date.now(),
    }),
      this.saveHintsData().catch(l);
  }
  filterShortcutUsageByTime(e, t) {
    let r = this.getHintShortcutUsedDates(e),
      i = new Date();
    i.setHours(i.getHours() - t);
    let s = i.getTime();
    (this.hintsShowedMetaById[e] = {
      ...this.hintsShowedMetaById[e],
      latestShortcutsUsedDates: r.filter((a) => a >= s),
    }),
      this.saveHintsData().catch(l);
  }
  recordShortcutUsed(e) {
    let t = this.getHintShortcutUsedDates(e);
    (this.hintsShowedMetaById[e] = {
      ...this.hintsShowedMetaById[e],
      latestShortcutsUsedDates: [...t, Date.now()],
    }),
      this.saveHintsData().catch(l);
  }
  getHintShortcutUsedDates(e) {
    return this.hintsShowedMetaById[e].latestShortcutsUsedDates ?? [];
  }
  saveHintsData() {
    return this.browserStorage.setItem(
      "hints-showed-data",
      this.hintsShowedMetaById
    );
  }
  loadDefaultData() {
    return {
      ["settings_app_menu"]: {},
      ["close_tab_app"]: {},
      ["global_mute_toggle"]: {},
      ["focus_mode"]: {},
      ["open_split_view"]: {},
      ["split_view_last_content"]: {},
      ["switch_sessions"]: {},
      ["sessions_open"]: {},
      ["split_view_close"]: {},
      ["tab_switcher"]: {},
      ["added_to_collection"]: {},
      ["sidebar_app_click"]: {},
    };
  }
};
c();
c();
c();
var oB = "activate-service-",
  Wh = Object.freeze(
    Array(9)
      .fill(null)
      .map((o, e) => `${oB}${e + 1}`)
  ),
  sB = Object.fromEntries(Wh.map((o, e) => [`ActivateService${e + 1}`, o])),
  Y = {
    ...sB,
    GlobalSearch: "global-search",
    SwitchTab: "toggle-active-tabs",
    SwitchTabCtrlTab: "toggle-active-tabs-ctrl-tab",
    SwitchTabCtrlShiftTab: "toggle-active-tabs-ctrl-shift-tab",
    KeyUpSwitchTab: "close_tab_switcher",
    ShowSessions: "show-sessions",
    KeyUpShowSessions: "show-sessions-modifier-released",
    ToggleSessionsSidecar: "toggle-sessions-sidecar",
    ToggleHelpSidecar: "toggle-help-sidecar",
    OpenSplitMenu: "open-split-menu",
    OpenLastSplitPanel: "open-last-split-panel",
    OpenCollectionsSidecar: "open-collections-sidecar",
    ToggleWindowFocusMode: "toggle-window-focus-mode",
    ToggleSidebar: "toggle-sidebar",
    PinVerticalTabsSidecar: "pin-vertical-tabs-sidecar",
  },
  Yee = new Set([Y.KeyUpSwitchTab, Y.KeyUpShowSessions]);
c();
var Fe = class {
  constructor(e) {
    this.api = e;
  }
  unsubscribeFn;
  dispose() {
    this.unsubscribeFn && (this.unsubscribeFn(), (this.unsubscribeFn = void 0));
  }
  start() {
    return (
      this.unsubscribeFn && this.unsubscribeFn(),
      (this.unsubscribeFn = this.startObserve()),
      this.unsubscribeFn
    );
  }
  getIsHintShowed() {
    return this.api.getIsHintShowed(this.getHintId());
  }
  markHintAsShowed() {
    return this.dispose(), this.api.markHintAsShowed(this.getHintId());
  }
  getIsHintShowedById(e) {
    return this.api.getIsHintShowed(e);
  }
  getIsHintVisibleInWindow(e, t) {
    return this.api.getIsHintVisibleInWindow(e, t);
  }
  tryShowHint(e, t) {
    this.api.tryShowHint(this.getHintId(), e, t).catch(l);
  }
};
var dl = class extends Fe {
  constructor(t, r, i, s) {
    super(t);
    this.shortcutService = r;
    this.browserStorage = i;
    this.actualUsageDaysRepository = s;
  }
  getHintId() {
    return "settings_app_menu";
  }
  startObserve() {
    return D.on("apps-activated", () => {
      this.checkDaysAndShow().catch(l);
    });
  }
  async checkDaysAndShow() {
    let t = await this.getDayShowed(),
      r = await this.actualUsageDaysRepository.getCountEnsured();
    if (r <= t) return;
    let i = this.shortcutService.getLastCommand(),
      s = this.shortcutService.getLastCommandUsage(),
      n = Date.now() - Number(s) <= ce(2);
    (i && Wh.includes(i) && n) ||
      (this.tryShowHint(), await this.setDayShowed(r));
  }
  setDayShowed(t) {
    return this.browserStorage.setItem("application-menu-hint", t);
  }
  async getDayShowed() {
    return (await this.browserStorage.getItem("application-menu-hint")) ?? -1;
  }
};
c();
var ul = class extends Fe {
  constructor(t, r, i) {
    super(t);
    this.browserEventsService = r;
    this.featureFlagsRepository = i;
  }
  closedAppsOrTabs = 0;
  getHintId() {
    return "close_tab_app";
  }
  startObserve() {
    let t = [
      D.on("apps-closed", () => {
        this.increaseCounterAndTryToShow();
      }),
      this.browserEventsService.subscribeOnTabClosedByGesture((r, i) => {
        this.increaseCounterAndTryToShow(i);
      }),
    ];
    return F(t);
  }
  increaseCounterAndTryToShow(t) {
    this.closedAppsOrTabs += 1;
    let { hintAfterTabsClosingCount: r } =
      this.featureFlagsRepository.getFeatureFlag("hintsV2");
    this.closedAppsOrTabs === r &&
      (this.tryShowHint(t), (this.closedAppsOrTabs = 0));
  }
};
c();
var ml = class extends Fe {
  constructor(t, r, i, s) {
    super(t);
    this.featureFlagsRepository = r;
    this.browserStorage = i;
    this.actualUsageDaysRepository = s;
    this.init().catch(l);
  }
  data;
  async init() {
    this.data = await this.readDataFromLS();
  }
  getHintId() {
    return "global_mute_toggle";
  }
  startObserve() {
    let t = [
      W.on("user-settings-changed", (r) => {
        this.data?.initedAtDay === void 0 ||
          r.globalMute === void 0 ||
          this.trigger();
      }),
      W.on("actual-usage-days-updated", (r) => {
        if (this.data?.initedAtDay === void 0) return;
        let { countDaysToAutoShow: i, shouldEnableAfterFinish: s } =
          this.featureFlagsRepository.getFeatureFlags().focusModeHint;
        if (this.data.showedAtDay !== void 0 && r === this.data.showedAtDay)
          return;
        let a = r - this.data.initedAtDay;
        if (i !== null && a >= i) {
          if (!s) return;
          this.trigger();
          return;
        }
        this.trigger();
      }),
    ];
    return F(t);
  }
  trigger() {
    this.tryShowHint();
    let t = this.actualUsageDaysRepository.getCount();
    g(
      t !== void 0,
      "actualUsageDays must be type of number to save into local storage"
    ),
      this.saveDataToLS(t).catch(l);
  }
  async getDefaultData() {
    return {
      initedAtDay: await this.actualUsageDaysRepository.getCountEnsured(),
    };
  }
  async readDataFromLS() {
    return (
      (await this.browserStorage.getItem("focus-mode-hint")) ??
      (await this.getDefaultData())
    );
  }
  async saveDataToLS(t) {
    return (
      g(
        this.data,
        "Global mute observer: data to save into local storage can not be undefined"
      ),
      this.browserStorage.setItem("focus-mode-hint", {
        ...this.data,
        showedAtDay: t,
      })
    );
  }
};
c();
var hl = class extends Fe {
  constructor(t, r, i) {
    super(t);
    this.windowHeadlessService = r;
    this.focusModeService = i;
  }
  getHintId() {
    return "focus_mode";
  }
  startObserve() {
    let t = [
      this.windowHeadlessService.onChanged((r, i) => {
        i && this.tryShowHint(r);
      }),
      this.focusModeService.subscribeToFocusModeChanged((r, i) => {
        i && this.tryShowHint(r);
      }),
    ];
    return F(t);
  }
};
c();
var yl = class extends Fe {
  constructor(t, r, i, s, a) {
    super(t);
    this.browserEventsService = r;
    this.shortcutService = i;
    this.applicationRepository = s;
    this.featureFlagsRepository = a;
  }
  lastState = null;
  getHintId() {
    return "split_view_last_content";
  }
  startObserve() {
    return this.browserEventsService.subscribeToSplitViewChange(
      async ({ globals: t }) => {
        if (!t.length) return;
        let r = this.shortcutService.getLastCommand(),
          i = this.shortcutService.getLastCommandUsage();
        (Date.now() - Number(i) <= ce(2) && r === Y.OpenLastSplitPanel) ||
          (await this.compareAndTryShow(t), (this.lastState = t));
      }
    );
  }
  async compareAndTryShow(t) {
    let r = t[0]?.tabId;
    if (!r) return;
    let i = await this.applicationRepository.getAppByTabId(r),
      s = this.featureFlagsRepository.getFeatureFlag("splitViewAppsEnabled"),
      a =
        i?.recipeMetaData.shouldOpenInSplitView &&
        s &&
        i.showAsSidecarPanelSetting;
    if (!this.lastState || a) return;
    let n = JSON.stringify(this.lastState),
      p = JSON.stringify(t);
    n === p && this.tryShowHint();
  }
};
c();
var bl = class extends Fe {
  constructor(t, r) {
    super(t);
    this.shortcutService = r;
  }
  getHintId() {
    return "switch_sessions";
  }
  startObserve() {
    return pe.on("session-open", (t, r) => {
      if (r) return;
      let i = this.shortcutService.getLastCommand(),
        s = this.shortcutService.getLastCommandUsage(),
        n = Date.now() - Number(s) <= ce(2),
        p = i === Y.ShowSessions || i === Y.KeyUpShowSessions;
      (n && p) || this.tryShowHint(t);
    });
  }
};
c();
var gl = class extends Fe {
  constructor(t, r, i) {
    super(t);
    this.applicationRepository = r;
    this.featureFlagsRepository = i;
  }
  getHintId() {
    return "sidebar_app_click";
  }
  startObserve() {
    return D.on("apps-activated", (t) => {
      this.checkConditionsAndShowHint(t);
    });
  }
  checkConditionsAndShowHint(t) {
    let r = this.applicationRepository.getAppById(t),
      i = this.featureFlagsRepository.getFeatureFlag("splitViewAppsEnabled");
    r?.recipeMetaData.shouldOpenInSplitView &&
      i &&
      r.showAsSidecarPanelSetting &&
      this.tryShowHint(void 0, t);
  }
};
c();
var vl = class extends Fe {
  constructor(t, r) {
    super(t);
    this.browserEventsService = r;
  }
  getHintId() {
    return "sessions_open";
  }
  startObserve() {
    return this.browserEventsService.subscribeToSidebarButtonMouseEvents(
      (r, i, s, a) => {
        r !== "session" || s.type !== "click" || this.tryShowHint(a);
      }
    );
  }
};
c();
var fl = class extends Fe {
  constructor(t, r) {
    super(t);
    this.browserEventsService = r;
  }
  getHintId() {
    return "split_view_close";
  }
  startObserve() {
    return this.browserEventsService.subscribeToSplitViewChange(
      ({ locals: t, globals: r }) => {
        t.length || r.length || this.tryShowHint();
      }
    );
  }
};
c();
var Sl = class extends Fe {
  constructor(t, r, i, s) {
    super(t);
    this.browserEventsService = r;
    this.splitViewService = i;
    this.runningApplicationsObserver = s;
  }
  getHintId() {
    return "open_split_view";
  }
  startObserve() {
    let t = [],
      r = async (i, s) => {
        Boolean(this.runningApplicationsObserver.getAppIdByTabId(i)) ||
          i === t[0] ||
          ((t = [i, ...t].slice(0, 4)), !this.hasTwoSwitches(t)) ||
          (await this.splitViewService.getIsInAnySplit(i)) ||
          this.getIsHintVisibleInWindow("tab_switcher", s) ||
          (this.tryShowHint(s), (t.length = 0));
      };
    return this.browserEventsService.subscribeToTabActivated(
      ({ tabId: i, windowId: s }) => {
        r(i, s).catch(l);
      }
    );
  }
  hasTwoSwitches(t) {
    return t[0] === t[2] && t[1] === t[3];
  }
};
c();
var wl = class extends Fe {
  constructor(t, r, i, s) {
    super(t);
    this.browserEventsService = r;
    this.splitViewService = i;
    this.runningApplicationsObserver = s;
  }
  getHintId() {
    return "tab_switcher";
  }
  startObserve() {
    let t,
      r,
      i = async (s, a) => {
        if (Boolean(this.runningApplicationsObserver.getAppIdByTabId(s)))
          return;
        !(await this.splitViewService.getIsInAnySplit(s)) &&
          s === r &&
          this.getFiftyFifty() &&
          (this.tryShowHint(a), (t = void 0), (r = void 0)),
          (r = t),
          (t = s);
      };
    return this.browserEventsService.subscribeToTabActivated(
      ({ tabId: s, windowId: a }) => {
        i(s, a).catch(l);
      }
    );
  }
  getFiftyFifty() {
    return this.getIsHintShowedById("open_split_view")
      ? !0
      : Math.random() >= 0.5;
  }
};
var kl = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m, y, b, v, S) {
    this.userSettingsRepository = e;
    this.userApi = t;
    this.uiHintsManager = r;
    this.browserService = i;
    this.shortcutService = s;
    this.browserEventsService = a;
    this.browserStorage = n;
    this.actualUsageDaysRepository = p;
    this.windowHeadlessService = d;
    this.featureFlagsRepository = u;
    this.splitViewService = m;
    this.runningApplicationsObserver = y;
    this.focusModeService = b;
    this.hintsRepository = v;
    this.applicationRepository = S;
    u.onFeatureFlagsLoaded(() => this.tryInit()),
      W.once("user-activated", () => this.tryInit());
  }
  observers = new Set();
  isWorking = !1;
  unsubscribeSettings = null;
  tryInit() {
    let e = this.featureFlagsRepository.getFeatureFlag("showHintsConditions"),
      t = this.featureFlagsRepository.getFeatureFlag(
        "showHintsConditionsIsEnabled"
      ),
      { userWasActivated: r, daysBeforeShowingFirstHints: i } = e,
      s = this.userSettingsRepository.getSettings().wasActivated,
      a = this.actualUsageDaysRepository.getCount() ?? 0,
      n = r !== s || a <= i;
    if (!t || n) {
      this.isWorking && this.disposeAll();
      return;
    }
    this.isWorking || this.init();
  }
  init() {
    this.isWorking = !0;
    let e = {
      tryShowHint: this.tryShowHint.bind(this),
      getIsHintShowed: this.getIsHintShowed.bind(this),
      markHintAsShowed: this.closeAndMarkHintAsShowed.bind(this),
      getIsHintVisibleInWindow: this.getIsHintVisibleInWindow.bind(this),
    };
    this.observers.add(new fl(e, this.browserEventsService)),
      this.observers.add(new vl(e, this.browserEventsService)),
      this.observers.add(
        new wl(
          e,
          this.browserEventsService,
          this.splitViewService,
          this.runningApplicationsObserver
        )
      ),
      this.observers.add(
        new ul(e, this.browserEventsService, this.featureFlagsRepository)
      ),
      this.observers.add(new bl(e, this.shortcutService)),
      this.observers.add(
        new Sl(
          e,
          this.browserEventsService,
          this.splitViewService,
          this.runningApplicationsObserver
        )
      ),
      this.observers.add(
        new dl(
          e,
          this.shortcutService,
          this.browserStorage,
          this.actualUsageDaysRepository
        )
      ),
      this.observers.add(
        new yl(
          e,
          this.browserEventsService,
          this.shortcutService,
          this.applicationRepository,
          this.featureFlagsRepository
        )
      ),
      this.observers.add(
        new hl(e, this.windowHeadlessService, this.focusModeService)
      ),
      this.observers.add(
        new ml(
          e,
          this.featureFlagsRepository,
          this.browserStorage,
          this.actualUsageDaysRepository
        )
      ),
      this.featureFlagsRepository.getFeatureFlag("splitViewAppsEnabled") &&
        this.observers.add(
          new gl(e, this.applicationRepository, this.featureFlagsRepository)
        ),
      (this.unsubscribeSettings = W.on("user-settings-changed", (r) => {
        r.showedHintsV2 && this.disposeUselessObservers();
      })),
      this.disposeUselessObservers(),
      this.observers.forEach((r) => r.start());
  }
  closeAndMarkHintAsShowed(e) {
    this.isWorking &&
      (this.uiHintsManager.hideAllHintsById(e), this.tryMarkHintAsShowed(e));
  }
  getIsHintShowed(e) {
    let { showedHintsV2: t } = this.userSettingsRepository.getSettings();
    return t.includes(e);
  }
  tryMarkHintAsShowed(e) {
    this.getIsHintShowed(e) || this.userApi.addHintToShowed(e);
  }
  async tryShowHint(e, t, r) {
    if (
      !this.isWorking ||
      this.getIsHintShowed(e) ||
      !this.shouldShowHintByDayUsage(e)
    )
      return;
    let i = t ?? (await this.browserService.getLastFocusedWindowId());
    !i ||
      Boolean(this.uiHintsManager.getPopupInfo(i, "walkthrough")) ||
      (this.uiHintsManager.showHint(i, e, r),
      this.hintsRepository.updateHintLastShowedDate(e));
  }
  shouldShowHintByDayUsage(e) {
    let t = this.actualUsageDaysRepository.getCount() ?? 0,
      {
        firstPeriodDays: r,
        firstPeriodShowingPeriodHours: i,
        otherTimeShowingPeriodHours: s,
      } = this.featureFlagsRepository.getFeatureFlag("hintsV2");
    return r >= t
      ? !this.hintsRepository.getWasHintShowed(e, i)
      : !this.hintsRepository.getWasHintShowed(e, s);
  }
  getIsHintVisibleInWindow(e, t) {
    return Boolean(this.uiHintsManager.getHintsForWindow(t)?.has(e));
  }
  disposeAll() {
    this.unsubscribeSettings?.(),
      this.observers.forEach((e) => {
        e.dispose(), this.observers.delete(e);
      }),
      (this.isWorking = !1);
  }
  disposeUselessObservers() {
    this.observers.forEach((e) => {
      e.getIsHintShowed() && (e.dispose(), this.observers.delete(e));
    });
  }
};
c();
var Tl = class {
  constructor(e, t, r, i, s, a) {
    this.hintsService = e;
    this.hintsRepository = t;
    this.shortcutService = r;
    this.featureFlagsRepository = i;
    this.analytics = s;
    this.actualUsageDaysRepository = a;
    this.shortcutService.onShortcutUsed((n) => {
      if (!n.name) return;
      let p = this.tryFindHintsByCommand(n.name);
      p.length &&
        p.forEach((d) => {
          this.hintsService.getIsHintShowed(d) ||
            (this.hintsRepository.recordShortcutUsed(d),
            this.tryMarkHintAsShowed(d));
        });
    });
  }
  getShortcutByHintMap() {
    let e = this.shortcutService.getShortcuts();
    return {
      ["split_view_close"]: e.openSplitMenu,
      ["focus_mode"]: e.switchFocusMode,
      ["split_view_last_content"]: e.toggleLastSplitPanel,
      ["sessions_open"]: e.manageSession,
      ["switch_sessions"]: e.switchSession,
      ["close_tab_app"]: e.browserCloseTab,
      ["settings_app_menu"]: e.appContextPopup,
      ["tab_switcher"]: e.switchTab,
      ["open_split_view"]: e.openSplitMenu,
      ["global_mute_toggle"]: void 0,
      ["added_to_collection"]: void 0,
      ["sidebar_app_click"]: e.toggleLastSplitPanel,
    };
  }
  tryFindHintsByCommand(e) {
    let t = this.shortcutService.getShortcutByCommand(e);
    if (!t) return [];
    let r = this.getShortcutByHintMap();
    return Object.entries(r).reduce(
      (i, [s, a]) => (a?.title === t?.title && i.push(s), i),
      []
    );
  }
  tryMarkHintAsShowed(e) {
    if (!this.featureFlagsRepository.getFeatureFlag("hintsV2Enabled")) return;
    let { shortcutsDaysPeriodForHintPass: r, shortcutsNumberForHintPass: i } =
        this.featureFlagsRepository.getFeatureFlag("hintsV2"),
      s = r * 24;
    this.hintsRepository.filterShortcutUsageByTime(e, s),
      this.hintsRepository.getWasHintShortcutUsed(e, s, i) &&
        (this.hintsService.closeAndMarkHintAsShowed(e),
        this.sendAnalytics(e).catch(l));
  }
  async sendAnalytics(e) {
    let t = await this.actualUsageDaysRepository.getCountEnsured();
    return this.analytics.sendAnalyticsEventWithOptions(
      "system.hint.disposed-by-shortcut",
      { hint: e, "user-usage-days": t }
    );
  }
};
var hw = ({
  userSettingsRepository: o,
  userApi: e,
  uiHintsManager: t,
  browserService: r,
  shortcutService: i,
  browserEventsService: s,
  browserStorage: a,
  actualUsageDaysRepository: n,
  windowHeadlessService: p,
  featureFlagsRepository: d,
  splitViewService: u,
  runningApplicationsObserver: m,
  focusModeService: y,
  analytics: b,
  applicationRepository: v,
}) => {
  let S = new ll(a);
  S.loadHintsData().catch(l);
  let w = new kl(o, e, t, r, i, s, a, n, p, d, u, m, y, S, v),
    T = new Tl(w, S, i, d, b, n);
  return new pl(w, T);
};
c();
var Il = class {
  constructor(e, t, r, i) {
    this.browserService = e;
    this.overlayService = t;
    this.cpuPopupService = r;
    (this.modalsByWindowId = {}),
      i.subscribeToTabActivated(({ windowId: s }) => {
        let a = this.getModalForWindow(s);
        !a || a?.isProgrammaticallyClosable || this.closeModal(s);
      });
  }
  modalsByWindowId;
  emitter = new A();
  subscribeToModalChanged(e) {
    return this.emitter.on("modal-changed", e);
  }
  getModalForWindow(e) {
    return this.modalsByWindowId[e];
  }
  async getCurrentModal() {
    let e = await this.browserService.getNormalLastFocusedWindow();
    if (!(e?.id === void 0 || e.id === -1)) return this.getModalForWindow(e.id);
  }
  showDistractionBlockerIntroModal(e, t) {
    return this.showModal({ id: "distraction-blocker-intro", payload: e }, t);
  }
  showBillingLastChanceModal(e, t) {
    return this.showModal({ id: "billing-last-chance", payload: e }, t);
  }
  showBillingDiscountModal(e, t) {
    return this.showModal({ id: "billing-discount-offer", payload: e }, t);
  }
  showCancelDiscountOfferModal(e, t) {
    return this.showModal({ id: "cancel-discount-offer-modal", payload: e }, t);
  }
  async showTeamCreateModal(e, t) {
    return this.showModal({ id: "team-create", payload: e }, t);
  }
  showContactsPickerForTeam(e, t) {
    return this.showModal({ id: "contacts-picker-for-team", payload: e }, t);
  }
  showInviteTeammatesModal(e, t) {
    return this.showModal({ id: "invite-teammates", payload: e }, t);
  }
  showInviteTeammatesSuccessModal(e, t) {
    return this.showModal({ id: "invite-teammates-success", payload: e }, t);
  }
  showInviteTeammatesFailModal(e, t) {
    return this.showModal({ id: "invite-teammates-fail", payload: e }, t);
  }
  showB2bIntroModal(e, t) {
    return this.showModal({ id: "b2b-intro", payload: e }, t);
  }
  showAddApplicationModal(e, t) {
    return this.showModal({ id: "add-application", payload: e }, t);
  }
  showShareApplicationModal(e, t) {
    return this.showModal({ id: "share-application", payload: e }, t);
  }
  showGlobalSettingsModal(e, t) {
    return this.showModal({ id: "global-settings", payload: { ...e } }, t);
  }
  showCpuMonitorSettingPopup(e, t) {
    let r = "cpu-monitor";
    return this.showModal(
      { id: "global-settings", payload: { ...e, tabId: r } },
      t
    );
  }
  showIntegrationsSettingsPopup(e, t) {
    let r = "integrations";
    return this.showModal(
      { id: "global-settings", payload: { ...e, tabId: r } },
      t
    );
  }
  showAccountSettingsPopup(e, t) {
    let r = "account";
    return this.showModal(
      { id: "global-settings", payload: { ...e, tabId: r } },
      t
    );
  }
  showTabSwitcherModal(e, t) {
    return this.showModal({ id: "tabs-switcher", payload: e }, t);
  }
  toggleGlobalSearchModal(e, t) {
    return this.toggleModal({ id: "global-search", payload: e }, t);
  }
  showGlobalSearchModal(e, t) {
    return this.showModal({ id: "global-search", payload: e }, t);
  }
  showMarketplaceModal(e, t) {
    return this.showModal({ id: "marketplace", payload: e }, t);
  }
  showCollectionShareModal(e) {
    return this.showModal({ id: "share-collection", payload: e });
  }
  showVideoModal(e, t) {
    return this.showModal({ id: "video", payload: e }, t);
  }
  showChecklistSuccessModal(e, t) {
    return this.showModal({ id: "checklist-success", payload: e }, t);
  }
  showUpgradePlanModal(e, t) {
    return this.showModal({ id: "upgrade-plan", payload: e }, t);
  }
  showTeamUpgradePlanModal(e, t) {
    return this.showModal({ id: "team-upgrade-plan", payload: e }, t);
  }
  showSignUpModal(e, t, r = !1) {
    return this.showModal(
      { id: "signup", payload: e, isProgrammaticallyClosable: r },
      t
    );
  }
  showCalendarModal(e, t) {
    return this.showModal({ id: "calendar", payload: e }, t);
  }
  showWorkspaceCreationModal(e, t) {
    return this.showModal({ id: "workspace-creation", payload: e }, t);
  }
  showWorkspacesManagementModal(e, t) {
    return this.showModal({ id: "workspaces-management", payload: e }, t);
  }
  showWorkspaceEditingModal(e, t) {
    return this.showModal({ id: "workspace-editing", payload: e }, t);
  }
  showBillingNotReadyModal(e, t) {
    return this.showModal({ id: "billing-not-ready", payload: e }, t);
  }
  showBillingPlanExpireSoonModal(e, t) {
    return this.showModal({ id: "billing-plan-expire-soon", payload: e }, t);
  }
  showBillingPlanHasExpiredModal(e, t) {
    return this.showModal({ id: "billing-plan-has-expired", payload: e }, t);
  }
  showBillingLimitsReachedModal(e, t) {
    return this.showModal({ id: "billing-limits-reached", payload: e }, t);
  }
  showCollectionIntroModal(e, t) {
    return this.showModal({ id: "collection-intro-modal", payload: e }, t);
  }
  showVerticalTabsModal(e, t) {
    return this.showModal({ id: "vertical-tabs-modal", payload: e }, t);
  }
  showPaidTrialModal(e, t) {
    return this.showModal(
      { id: "paid-trial-modal", payload: e, isProgrammaticallyClosable: !0 },
      t
    );
  }
  closeModal(e) {
    (this.modalsByWindowId = Ie(this.modalsByWindowId, e)),
      this.emitter.emit("modal-changed", void 0, e),
      this.cpuPopupService.getPopupForWindow(e) ||
        this.overlayService.toggleOverlayForModal(e, !1);
  }
  closeAllModalsById(e) {
    let t = Object.entries(this.modalsByWindowId)
      .filter(([, r]) => r.id === e)
      .map(([r]) => Number(r));
    (this.modalsByWindowId = Ie(this.modalsByWindowId, ...t)),
      this.emitter.emit("modal-changed", void 0, void 0),
      this.overlayService.closeOverlayForRegularModals(t);
  }
  async showModal(e, t) {
    let r = t ?? (await this.browserService.getLastFocusedWindowId());
    if (r === void 0) return;
    let i = this.modalsByWindowId[r];
    i?.isProgrammaticallyClosable ||
      (i !== void 0 && this.isSameModal(i, e)) ||
      ((this.modalsByWindowId[r] = e),
      this.emitter.emit("modal-changed", e.id, r),
      this.cpuPopupService.getPopupForWindow(r) ||
        this.overlayService.toggleOverlayForModal(r, !0));
  }
  async toggleModal(e, t) {
    let r = t ?? (await this.browserService.getLastFocusedWindowId());
    if (r === void 0) return;
    let i = this.getModalForWindow(r);
    i !== void 0 && this.isSameModal(i, e)
      ? this.closeModal(r)
      : await this.showModal(e, r);
  }
  isSameModal(e, t) {
    return Boolean(e.id === t.id && Ri(e, t));
  }
};
c();
var aB = "navigation-scripts.json",
  yw = [];
var Al = class {
  navigationScripts = yw;
  emitter = new A();
  constructor() {
    this.loadFromBundle().catch(l);
  }
  onNavigationScriptsLoaded(e) {
    return this.emitter.on("loaded", e);
  }
  getNavigationScripts() {
    return this.navigationScripts;
  }
  async loadFromBundle() {
    let e = new Request(`/${aB}`),
      t = await fetch(e);
    g(t.ok, "Couldn't load navigation scripts");
    let r = await je(t, e);
    this.navigationScripts === yw && this.setNavigationScripts(r);
  }
  setNavigationScripts(e) {
    (this.navigationScripts = e), this.emitter.emit("loaded");
  }
};
c();
c();
var Pl = class {
  constructor(e) {
    this.eventSource = e;
  }
  isRunning = !1;
  startCount = 0;
  async start() {
    !this.isManagable(this.eventSource) ||
      this.isRunning ||
      (await this.eventSource.start(),
      (this.isRunning = !0),
      (this.startCount += 1));
  }
  stop() {
    !this.isManagable(this.eventSource) ||
      !this.isRunning ||
      (this.eventSource.stop(), (this.isRunning = !1));
  }
  isConnected() {
    return this.isRunning;
  }
  isFirstRun() {
    return this.isRunning && this.startCount === 1;
  }
  isManagable(e) {
    return typeof e == "object" && e !== null && "stop" in e && "start" in e;
  }
};
c();
var gw = Ii(sm(), 1);
var bw = (o, e) => new gw.default(o).match(e) !== !1,
  ys = class {
    constructor(e, t) {
      this.eventSource = e;
      this.channelIds = t;
      Hy(this.channelIds, (r) => {
        this.channelIds = r;
      });
    }
    filterHandlersByType = new Map();
    finalizersByType = new Map();
    dispose() {
      this.filterHandlersByType.clear(),
        this.finalizersByType.forEach((e) => e()),
        this.finalizersByType.clear();
    }
    subscribe(e, t, r) {
      let i = this.filterHandlersByType.get(e);
      i ||
        ((i = new Array()),
        this.filterHandlersByType.set(e, i),
        this.startListenFor(e).catch(l));
      let s = { filter: t, handler: r };
      return i.push(s), () => this.unsubscribe(e, s);
    }
    unsubscribe(e, t) {
      let r = this.filterHandlersByType.get(e);
      if (!r?.length) return;
      let i = r.filter((s) => s.filter !== t.filter || s.handler !== t.handler);
      if (r.length !== i.length) {
        if (i.length) {
          this.filterHandlersByType.set(e, i);
          return;
        }
        this.filterHandlersByType.delete(e),
          this.finalizersByType.get(e)?.(),
          this.finalizersByType.delete(e);
      }
    }
    async startListenFor(e) {
      let t = Gy(this.channelIds) ? await this.channelIds : this.channelIds,
        r = (i) => {
          this.filterHandlersByType
            .get(e)
            ?.forEach(({ filter: a, handler: n }) => {
              !bw(a.uri, i.uri) ||
                !(
                  !a.parentUri ||
                  (a.parentUri && i.parentUri && bw(a.parentUri, i.parentUri))
                ) ||
                ee(n(i));
            });
        };
      t.forEach((i) => {
        this.eventSource.subscribe(i, e, r).catch(l);
      }),
        this.finalizersByType.set(e, () => {
          t.forEach((i) => {
            this.eventSource.unsubscribe(i, e, r).catch(l);
          });
        });
    }
  };
c();
c();
var vw = () =>
  new Worker("/background/workers/notifications_worker/index.js", {
    type: "module",
  });
c();
var Rl = ({ worker: o }) => {
  let e = new jb({
    clientInfo: { type: "worker" },
    postMessage: (t) => {
      o.postMessage(t);
    },
  });
  return (
    o.addEventListener("message", (t) => {
      Vs(t.data) && e.processMessage(t.data);
    }),
    e
  );
};
var El = class {
  constructor(e) {
    this.authService = e;
  }
  worker = vw();
  gateway = Rl({ worker: this.worker });
  proxiedListeners = new Map();
  start() {
    let e = this.authService.getToken();
    return this.gateway.queries.start(e);
  }
  subscribe(e, t, r) {
    let i = r,
      s = Hs(i);
    return (
      this.proxiedListeners.set(i, s), this.gateway.queries.subscribe(e, t, s)
    );
  }
  async unsubscribe(e, t, r) {
    let i = r,
      s = this.proxiedListeners.get(i);
    g(
      s,
      `You tried to unsubscribe channelId: "${e}", eventName: "${t}", but no listener is found`
    ),
      await this.gateway.queries.unsubscribe(e, t, s),
      s.dispose(),
      this.proxiedListeners.delete(i);
  }
  stop() {
    return this.gateway.queries.pause();
  }
  terminate() {
    this.worker.terminate();
  }
};
var nB = async () => {
    let o = await new Promise((e) => {
      _e.once("teams-loaded", e);
    });
    return Object.values(o).map(({ uuid: e }) => `presence-team-${e}`);
  },
  fw = (o) => {
    let e = new El(o),
      t = `private-app-${o.getUserId()}`,
      r = new ys(e, nB()),
      i = new ys(e, [t]),
      s = new Pl(e);
    return {
      teamNotificationsService: r,
      userNotificationsService: i,
      eventSourceManager: s,
    };
  };
c();
c();
var Bl = class {
  constructor(e, t) {
    this.popupService = e;
    this.notificationsSettingsService = t;
  }
  handleGlobalMuteClick(e, t) {
    if (t || !this.isMuteNotificationsPopupEnabled()) {
      this.notificationsSettingsService.toggleGlobalMute();
      return;
    }
    this.toggleSettingsPopup(e);
  }
  toggleSettingsPopup(e) {
    Boolean(this.popupService.getPopupInfo(e, "notifications-settings"))
      ? this.hideSettingsPopup(e)
      : this.showSettingsPopup(e);
  }
  isMuteNotificationsPopupEnabled() {
    return this.notificationsSettingsService.isMuteNotificationsPopupEnabled();
  }
  showSettingsPopup(e) {
    this.popupService.showUserNotificationsSettingsPopup(e);
  }
  hideSettingsPopup(e) {
    this.popupService.hideUserNotificationsSettingsPopup(e);
  }
  muteForHour() {
    let e = new Date();
    e.setHours(e.getHours() + 1),
      this.notificationsSettingsService.enableMuteAndScheduleUnmuteIn(
        e,
        "hour"
      );
  }
  muteUntilEvening() {
    let e = new Date();
    e.setHours(18, 0, 0, 0),
      this.notificationsSettingsService.enableMuteAndScheduleUnmuteIn(
        e,
        "evening"
      );
  }
  muteUntilNight() {
    let e = new Date();
    e.setDate(e.getDate() + 1),
      e.setHours(0, 0, 0, 0),
      this.notificationsSettingsService.enableMuteAndScheduleUnmuteIn(
        e,
        "night"
      );
  }
  muteUntilThisMorning() {
    let e = new Date();
    e.setHours(6, 0, 0, 0),
      this.notificationsSettingsService.enableMuteAndScheduleUnmuteIn(
        e,
        "morning"
      );
  }
  muteUntilTomorrowMorning() {
    let e = new Date();
    e.setDate(e.getDate() + 1),
      e.setHours(6, 0, 0, 0),
      this.notificationsSettingsService.enableMuteAndScheduleUnmuteIn(
        e,
        "morning"
      );
  }
  toggleGlobalMute() {
    return this.notificationsSettingsService.toggleGlobalMute();
  }
  enableFocusMode() {
    return this.notificationsSettingsService.enableFocusMode();
  }
};
c();
var Cl = class {
  constructor(e) {
    this.browserStorage = e;
  }
  currentMuteMode = void 0;
  emitter = new A();
  getCurrentMuteMode() {
    return this.currentMuteMode;
  }
  onMuteModeChange(e) {
    return this.emitter.on("mute-mode-change", e);
  }
  async loadMuteMode() {
    let e = await this.getMuteModeFromStorage();
    return (this.currentMuteMode = e), this.currentMuteMode;
  }
  setCurrentMuteMode(e) {
    return e === this.currentMuteMode
      ? Promise.resolve()
      : ((this.currentMuteMode = e),
        this.emitter.emit("mute-mode-change"),
        this.browserStorage.setItem(
          "unmute-notifications-mode",
          this.currentMuteMode
        ));
  }
  clearCurrentMuteMode() {
    return this.currentMuteMode
      ? ((this.currentMuteMode = void 0),
        this.emitter.emit("mute-mode-change"),
        this.browserStorage.removeItem("unmute-notifications-mode"))
      : Promise.resolve();
  }
  async getMuteModeFromStorage() {
    return this.browserStorage.getItem("unmute-notifications-mode");
  }
};
c();
c();
var _l = "notifications-unmute-alarm",
  Fl = class {
    constructor(e, t, r, i, s, a, n, p) {
      this.notificationsSettingsRepository = e;
      this.userSettingsRepository = t;
      this.analyticsTracker = r;
      this.userApi = i;
      this.featureFlagsRepository = s;
      this.focusModeService = a;
      this.browserService = n;
      p.subscribeToAlarm((d) => {
        d.name === _l && this.tryUnmuteByAlarm();
      }),
        this.featureFlagsRepository.onFeatureFlagsLoaded((d, u) => {
          u || this.tryUnmuteAfterInit().catch(l);
        }),
        this.focusModeService.subscribeToFocusModeChanged((d, u) => {
          this.toggleGlobalMuteFocusMode(u);
        });
    }
    muteStatusBeforeFocusMode = !1;
    enableFocusMode() {
      this.focusModeService.toggleWindowFocusMode().catch(fe);
    }
    enableMuteAndScheduleUnmuteIn(e, t) {
      if (e.getTime() - Date.now() <= 0)
        throw new Error("Date should be more than now");
      this.userApi.changeGlobalMute(!0),
        this.browserService.createAlarm(_l, { when: e.getTime() }),
        this.notificationsSettingsRepository.setCurrentMuteMode(t).catch(l);
    }
    toggleGlobalMute() {
      this.clearPlannedUnmute().catch(l);
      let { globalMute: e } = this.userSettingsRepository.getSettings(),
        t = !e;
      this.analyticsTracker.sendAnalyticsEvent("sidebar.mute-button-clicked", {
        "new-value": t,
      }),
        this.userApi.changeGlobalMute(t);
    }
    isMuteNotificationsPopupEnabled() {
      return this.featureFlagsRepository.getFeatureFlag(
        "isMuteNotificationsPopupEnabled"
      );
    }
    enableGlobalMute(e) {
      this.clearPlannedUnmute().catch(l), this.userApi.changeGlobalMute(e);
    }
    toggleGlobalMuteFocusMode(e) {
      let { globalMute: t } = this.userSettingsRepository.getSettings();
      if (e && !t) {
        this.enableGlobalMute(!0), (this.muteStatusBeforeFocusMode = !0);
        return;
      }
      t &&
        this.muteStatusBeforeFocusMode &&
        (this.enableGlobalMute(!1), (this.muteStatusBeforeFocusMode = !1));
    }
    async tryUnmuteAfterInit() {
      !(await this.notificationsSettingsRepository.loadMuteMode()) ||
        Boolean(await this.browserService.getAlarmByName(_l)) ||
        this.tryUnmuteByAlarm();
    }
    tryUnmuteByAlarm() {
      this.isMuteNotificationsPopupEnabled() &&
        (this.userApi.changeGlobalMute(!1),
        this.notificationsSettingsRepository.clearCurrentMuteMode().catch(l));
    }
    async clearPlannedUnmute() {
      return (
        await this.notificationsSettingsRepository.clearCurrentMuteMode(),
        this.browserService.clearAlarmByName(_l)
      );
    }
  };
var Sw = (o) => {
  let e = new Cl(o.browserStorage),
    t = new Fl(
      e,
      o.userSettingsRepository,
      o.analyticsTracker,
      o.userApi,
      o.featureFlagsRepository,
      o.focusModeService,
      o.browserService,
      o.browserEventsService
    );
  return { api: new Bl(o.popupService, t), repository: e };
};
c();
c();
c();
c();
c();
var kw = function (o) {
    let e = [],
      t = 0;
    for (let r = 0; r < o.length; r++) {
      let i = o.charCodeAt(r);
      i < 128
        ? (e[t++] = i)
        : i < 2048
        ? ((e[t++] = (i >> 6) | 192), (e[t++] = (i & 63) | 128))
        : (i & 64512) === 55296 &&
          r + 1 < o.length &&
          (o.charCodeAt(r + 1) & 64512) === 56320
        ? ((i = 65536 + ((i & 1023) << 10) + (o.charCodeAt(++r) & 1023)),
          (e[t++] = (i >> 18) | 240),
          (e[t++] = ((i >> 12) & 63) | 128),
          (e[t++] = ((i >> 6) & 63) | 128),
          (e[t++] = (i & 63) | 128))
        : ((e[t++] = (i >> 12) | 224),
          (e[t++] = ((i >> 6) & 63) | 128),
          (e[t++] = (i & 63) | 128));
    }
    return e;
  },
  cB = function (o) {
    let e = [],
      t = 0,
      r = 0;
    for (; t < o.length; ) {
      let i = o[t++];
      if (i < 128) e[r++] = String.fromCharCode(i);
      else if (i > 191 && i < 224) {
        let s = o[t++];
        e[r++] = String.fromCharCode(((i & 31) << 6) | (s & 63));
      } else if (i > 239 && i < 365) {
        let s = o[t++],
          a = o[t++],
          n = o[t++],
          p =
            (((i & 7) << 18) | ((s & 63) << 12) | ((a & 63) << 6) | (n & 63)) -
            65536;
        (e[r++] = String.fromCharCode(55296 + (p >> 10))),
          (e[r++] = String.fromCharCode(56320 + (p & 1023)));
      } else {
        let s = o[t++],
          a = o[t++];
        e[r++] = String.fromCharCode(
          ((i & 15) << 12) | ((s & 63) << 6) | (a & 63)
        );
      }
    }
    return e.join("");
  },
  Tw = {
    byteToCharMap_: null,
    charToByteMap_: null,
    byteToCharMapWebSafe_: null,
    charToByteMapWebSafe_: null,
    ENCODED_VALS_BASE:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
    get ENCODED_VALS() {
      return this.ENCODED_VALS_BASE + "+/=";
    },
    get ENCODED_VALS_WEBSAFE() {
      return this.ENCODED_VALS_BASE + "-_.";
    },
    HAS_NATIVE_SUPPORT: typeof atob == "function",
    encodeByteArray(o, e) {
      if (!Array.isArray(o))
        throw Error("encodeByteArray takes an array as a parameter");
      this.init_();
      let t = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
        r = [];
      for (let i = 0; i < o.length; i += 3) {
        let s = o[i],
          a = i + 1 < o.length,
          n = a ? o[i + 1] : 0,
          p = i + 2 < o.length,
          d = p ? o[i + 2] : 0,
          u = s >> 2,
          m = ((s & 3) << 4) | (n >> 4),
          y = ((n & 15) << 2) | (d >> 6),
          b = d & 63;
        p || ((b = 64), a || (y = 64)), r.push(t[u], t[m], t[y], t[b]);
      }
      return r.join("");
    },
    encodeString(o, e) {
      return this.HAS_NATIVE_SUPPORT && !e
        ? btoa(o)
        : this.encodeByteArray(kw(o), e);
    },
    decodeString(o, e) {
      return this.HAS_NATIVE_SUPPORT && !e
        ? atob(o)
        : cB(this.decodeStringToByteArray(o, e));
    },
    decodeStringToByteArray(o, e) {
      this.init_();
      let t = e ? this.charToByteMapWebSafe_ : this.charToByteMap_,
        r = [];
      for (let i = 0; i < o.length; ) {
        let s = t[o.charAt(i++)],
          n = i < o.length ? t[o.charAt(i)] : 0;
        ++i;
        let d = i < o.length ? t[o.charAt(i)] : 64;
        ++i;
        let m = i < o.length ? t[o.charAt(i)] : 64;
        if ((++i, s == null || n == null || d == null || m == null))
          throw new Dh();
        let y = (s << 2) | (n >> 4);
        if ((r.push(y), d !== 64)) {
          let b = ((n << 4) & 240) | (d >> 2);
          if ((r.push(b), m !== 64)) {
            let v = ((d << 6) & 192) | m;
            r.push(v);
          }
        }
      }
      return r;
    },
    init_() {
      if (!this.byteToCharMap_) {
        (this.byteToCharMap_ = {}),
          (this.charToByteMap_ = {}),
          (this.byteToCharMapWebSafe_ = {}),
          (this.charToByteMapWebSafe_ = {});
        for (let o = 0; o < this.ENCODED_VALS.length; o++)
          (this.byteToCharMap_[o] = this.ENCODED_VALS.charAt(o)),
            (this.charToByteMap_[this.byteToCharMap_[o]] = o),
            (this.byteToCharMapWebSafe_[o] =
              this.ENCODED_VALS_WEBSAFE.charAt(o)),
            (this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[o]] = o),
            o >= this.ENCODED_VALS_BASE.length &&
              ((this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(o)] = o),
              (this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(o)] = o));
      }
    },
  },
  Dh = class extends Error {
    constructor() {
      super(...arguments), (this.name = "DecodeBase64StringError");
    }
  },
  pB = function (o) {
    let e = kw(o);
    return Tw.encodeByteArray(e, !0);
  },
  Uh = function (o) {
    return pB(o).replace(/\./g, "");
  },
  lB = function (o) {
    try {
      return Tw.decodeString(o, !0);
    } catch (e) {
      console.error("base64Decode failed: ", e);
    }
    return null;
  };
function dB() {
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw new Error("Unable to locate global object.");
}
var uB = () => dB().__FIREBASE_DEFAULTS__,
  mB = () => {
    if (typeof process > "u" || typeof process.env > "u") return;
    let o = process.env.__FIREBASE_DEFAULTS__;
    if (o) return JSON.parse(o);
  },
  hB = () => {
    if (typeof document > "u") return;
    let o;
    try {
      o = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
    } catch {
      return;
    }
    let e = o && lB(o[1]);
    return e && JSON.parse(e);
  },
  yB = () => {
    try {
      return uB() || mB() || hB();
    } catch (o) {
      console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${o}`);
      return;
    }
  };
var Oh = () => {
  var o;
  return (o = yB()) === null || o === void 0 ? void 0 : o.config;
};
var Ml = class {
  constructor() {
    (this.reject = () => {}),
      (this.resolve = () => {}),
      (this.promise = new Promise((e, t) => {
        (this.resolve = e), (this.reject = t);
      }));
  }
  wrapCallback(e) {
    return (t, r) => {
      t ? this.reject(t) : this.resolve(r),
        typeof e == "function" &&
          (this.promise.catch(() => {}), e.length === 1 ? e(t) : e(t, r));
    };
  }
};
function xl() {
  try {
    return typeof indexedDB == "object";
  } catch {
    return !1;
  }
}
function Wl() {
  return new Promise((o, e) => {
    try {
      let t = !0,
        r = "validate-browser-context-for-indexeddb-analytics-module",
        i = self.indexedDB.open(r);
      (i.onsuccess = () => {
        i.result.close(), t || self.indexedDB.deleteDatabase(r), o(!0);
      }),
        (i.onupgradeneeded = () => {
          t = !1;
        }),
        (i.onerror = () => {
          var s;
          e(
            ((s = i.error) === null || s === void 0 ? void 0 : s.message) || ""
          );
        });
    } catch (t) {
      e(t);
    }
  });
}
function Iw() {
  return !(typeof navigator > "u" || !navigator.cookieEnabled);
}
var bB = "FirebaseError",
  Bt = class extends Error {
    constructor(e, t, r) {
      super(t),
        (this.code = e),
        (this.customData = r),
        (this.name = bB),
        Object.setPrototypeOf(this, Bt.prototype),
        Error.captureStackTrace &&
          Error.captureStackTrace(this, wr.prototype.create);
    }
  },
  wr = class {
    constructor(e, t, r) {
      (this.service = e), (this.serviceName = t), (this.errors = r);
    }
    create(e, ...t) {
      let r = t[0] || {},
        i = `${this.service}/${e}`,
        s = this.errors[e],
        a = s ? gB(s, r) : "Error",
        n = `${this.serviceName}: ${a} (${i}).`;
      return new Bt(i, n, r);
    }
  };
function gB(o, e) {
  return o.replace(vB, (t, r) => {
    let i = e[r];
    return i != null ? String(i) : `<${r}?>`;
  });
}
var vB = /\{\$([^}]+)}/g;
function Dl(o, e) {
  if (o === e) return !0;
  let t = Object.keys(o),
    r = Object.keys(e);
  for (let i of t) {
    if (!r.includes(i)) return !1;
    let s = o[i],
      a = e[i];
    if (ww(s) && ww(a)) {
      if (!Dl(s, a)) return !1;
    } else if (s !== a) return !1;
  }
  for (let i of r) if (!t.includes(i)) return !1;
  return !0;
}
function ww(o) {
  return o !== null && typeof o == "object";
}
var $ie = 4 * 60 * 60 * 1e3;
function Ul(o) {
  return o && o._delegate ? o._delegate : o;
}
var Ct = class {
  constructor(e, t, r) {
    (this.name = e),
      (this.instanceFactory = t),
      (this.type = r),
      (this.multipleInstances = !1),
      (this.serviceProps = {}),
      (this.instantiationMode = "LAZY"),
      (this.onInstanceCreated = null);
  }
  setInstantiationMode(e) {
    return (this.instantiationMode = e), this;
  }
  setMultipleInstances(e) {
    return (this.multipleInstances = e), this;
  }
  setServiceProps(e) {
    return (this.serviceProps = e), this;
  }
  setInstanceCreatedCallback(e) {
    return (this.onInstanceCreated = e), this;
  }
};
var mi = "[DEFAULT]";
var jh = class {
  constructor(e, t) {
    (this.name = e),
      (this.container = t),
      (this.component = null),
      (this.instances = new Map()),
      (this.instancesDeferred = new Map()),
      (this.instancesOptions = new Map()),
      (this.onInitCallbacks = new Map());
  }
  get(e) {
    let t = this.normalizeInstanceIdentifier(e);
    if (!this.instancesDeferred.has(t)) {
      let r = new Ml();
      if (
        (this.instancesDeferred.set(t, r),
        this.isInitialized(t) || this.shouldAutoInitialize())
      )
        try {
          let i = this.getOrInitializeService({ instanceIdentifier: t });
          i && r.resolve(i);
        } catch {}
    }
    return this.instancesDeferred.get(t).promise;
  }
  getImmediate(e) {
    var t;
    let r = this.normalizeInstanceIdentifier(e?.identifier),
      i = (t = e?.optional) !== null && t !== void 0 ? t : !1;
    if (this.isInitialized(r) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({ instanceIdentifier: r });
      } catch (s) {
        if (i) return null;
        throw s;
      }
    else {
      if (i) return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(e) {
    if (e.name !== this.name)
      throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (((this.component = e), !!this.shouldAutoInitialize())) {
      if (SB(e))
        try {
          this.getOrInitializeService({ instanceIdentifier: mi });
        } catch {}
      for (let [t, r] of this.instancesDeferred.entries()) {
        let i = this.normalizeInstanceIdentifier(t);
        try {
          let s = this.getOrInitializeService({ instanceIdentifier: i });
          r.resolve(s);
        } catch {}
      }
    }
  }
  clearInstance(e = mi) {
    this.instancesDeferred.delete(e),
      this.instancesOptions.delete(e),
      this.instances.delete(e);
  }
  async delete() {
    let e = Array.from(this.instances.values());
    await Promise.all([
      ...e.filter((t) => "INTERNAL" in t).map((t) => t.INTERNAL.delete()),
      ...e.filter((t) => "_delete" in t).map((t) => t._delete()),
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(e = mi) {
    return this.instances.has(e);
  }
  getOptions(e = mi) {
    return this.instancesOptions.get(e) || {};
  }
  initialize(e = {}) {
    let { options: t = {} } = e,
      r = this.normalizeInstanceIdentifier(e.instanceIdentifier);
    if (this.isInitialized(r))
      throw Error(`${this.name}(${r}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    let i = this.getOrInitializeService({ instanceIdentifier: r, options: t });
    for (let [s, a] of this.instancesDeferred.entries()) {
      let n = this.normalizeInstanceIdentifier(s);
      r === n && a.resolve(i);
    }
    return i;
  }
  onInit(e, t) {
    var r;
    let i = this.normalizeInstanceIdentifier(t),
      s =
        (r = this.onInitCallbacks.get(i)) !== null && r !== void 0
          ? r
          : new Set();
    s.add(e), this.onInitCallbacks.set(i, s);
    let a = this.instances.get(i);
    return (
      a && e(a, i),
      () => {
        s.delete(e);
      }
    );
  }
  invokeOnInitCallbacks(e, t) {
    let r = this.onInitCallbacks.get(t);
    if (r)
      for (let i of r)
        try {
          i(e, t);
        } catch {}
  }
  getOrInitializeService({ instanceIdentifier: e, options: t = {} }) {
    let r = this.instances.get(e);
    if (
      !r &&
      this.component &&
      ((r = this.component.instanceFactory(this.container, {
        instanceIdentifier: fB(e),
        options: t,
      })),
      this.instances.set(e, r),
      this.instancesOptions.set(e, t),
      this.invokeOnInitCallbacks(r, e),
      this.component.onInstanceCreated)
    )
      try {
        this.component.onInstanceCreated(this.container, e, r);
      } catch {}
    return r || null;
  }
  normalizeInstanceIdentifier(e = mi) {
    return this.component ? (this.component.multipleInstances ? e : mi) : e;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
};
function fB(o) {
  return o === mi ? void 0 : o;
}
function SB(o) {
  return o.instantiationMode === "EAGER";
}
var Ol = class {
  constructor(e) {
    (this.name = e), (this.providers = new Map());
  }
  addComponent(e) {
    let t = this.getProvider(e.name);
    if (t.isComponentSet())
      throw new Error(
        `Component ${e.name} has already been registered with ${this.name}`
      );
    t.setComponent(e);
  }
  addOrOverwriteComponent(e) {
    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name),
      this.addComponent(e);
  }
  getProvider(e) {
    if (this.providers.has(e)) return this.providers.get(e);
    let t = new jh(e, this);
    return this.providers.set(e, t), t;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
};
c();
var wB = [],
  Re;
(function (o) {
  (o[(o.DEBUG = 0)] = "DEBUG"),
    (o[(o.VERBOSE = 1)] = "VERBOSE"),
    (o[(o.INFO = 2)] = "INFO"),
    (o[(o.WARN = 3)] = "WARN"),
    (o[(o.ERROR = 4)] = "ERROR"),
    (o[(o.SILENT = 5)] = "SILENT");
})(Re || (Re = {}));
var kB = {
    debug: Re.DEBUG,
    verbose: Re.VERBOSE,
    info: Re.INFO,
    warn: Re.WARN,
    error: Re.ERROR,
    silent: Re.SILENT,
  },
  TB = Re.INFO,
  IB = {
    [Re.DEBUG]: "log",
    [Re.VERBOSE]: "log",
    [Re.INFO]: "info",
    [Re.WARN]: "warn",
    [Re.ERROR]: "error",
  },
  AB = (o, e, ...t) => {
    if (e < o.logLevel) return;
    let r = new Date().toISOString(),
      i = IB[e];
    if (i) console[i](`[${r}]  ${o.name}:`, ...t);
    else
      throw new Error(
        `Attempted to log a message with an invalid logType (value: ${e})`
      );
  },
  jl = class {
    constructor(e) {
      (this.name = e),
        (this._logLevel = TB),
        (this._logHandler = AB),
        (this._userLogHandler = null),
        wB.push(this);
    }
    get logLevel() {
      return this._logLevel;
    }
    set logLevel(e) {
      if (!(e in Re))
        throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
      this._logLevel = e;
    }
    setLogLevel(e) {
      this._logLevel = typeof e == "string" ? kB[e] : e;
    }
    get logHandler() {
      return this._logHandler;
    }
    set logHandler(e) {
      if (typeof e != "function")
        throw new TypeError(
          "Value assigned to `logHandler` must be a function"
        );
      this._logHandler = e;
    }
    get userLogHandler() {
      return this._userLogHandler;
    }
    set userLogHandler(e) {
      this._userLogHandler = e;
    }
    debug(...e) {
      this._userLogHandler && this._userLogHandler(this, Re.DEBUG, ...e),
        this._logHandler(this, Re.DEBUG, ...e);
    }
    log(...e) {
      this._userLogHandler && this._userLogHandler(this, Re.VERBOSE, ...e),
        this._logHandler(this, Re.VERBOSE, ...e);
    }
    info(...e) {
      this._userLogHandler && this._userLogHandler(this, Re.INFO, ...e),
        this._logHandler(this, Re.INFO, ...e);
    }
    warn(...e) {
      this._userLogHandler && this._userLogHandler(this, Re.WARN, ...e),
        this._logHandler(this, Re.WARN, ...e);
    }
    error(...e) {
      this._userLogHandler && this._userLogHandler(this, Re.ERROR, ...e),
        this._logHandler(this, Re.ERROR, ...e);
    }
  };
var Lh = class {
  constructor(e) {
    this.container = e;
  }
  getPlatformInfoString() {
    return this.container
      .getProviders()
      .map((t) => {
        if (PB(t)) {
          let r = t.getImmediate();
          return `${r.library}/${r.version}`;
        } else return null;
      })
      .filter((t) => t)
      .join(" ");
  }
};
function PB(o) {
  let e = o.getComponent();
  return e?.type === "VERSION";
}
var Gh = "@firebase/app",
  Aw = "0.9.13";
var hi = new jl("@firebase/app"),
  RB = "@firebase/app-compat",
  EB = "@firebase/analytics-compat",
  BB = "@firebase/analytics",
  CB = "@firebase/app-check-compat",
  _B = "@firebase/app-check",
  FB = "@firebase/auth",
  MB = "@firebase/auth-compat",
  xB = "@firebase/database",
  WB = "@firebase/database-compat",
  DB = "@firebase/functions",
  UB = "@firebase/functions-compat",
  OB = "@firebase/installations",
  jB = "@firebase/installations-compat",
  NB = "@firebase/messaging",
  LB = "@firebase/messaging-compat",
  GB = "@firebase/performance",
  HB = "@firebase/performance-compat",
  VB = "@firebase/remote-config",
  $B = "@firebase/remote-config-compat",
  KB = "@firebase/storage",
  qB = "@firebase/storage-compat",
  zB = "@firebase/firestore",
  QB = "@firebase/firestore-compat",
  YB = "firebase";
var Hh = "[DEFAULT]",
  XB = {
    [Gh]: "fire-core",
    [RB]: "fire-core-compat",
    [BB]: "fire-analytics",
    [EB]: "fire-analytics-compat",
    [_B]: "fire-app-check",
    [CB]: "fire-app-check-compat",
    [FB]: "fire-auth",
    [MB]: "fire-auth-compat",
    [xB]: "fire-rtdb",
    [WB]: "fire-rtdb-compat",
    [DB]: "fire-fn",
    [UB]: "fire-fn-compat",
    [OB]: "fire-iid",
    [jB]: "fire-iid-compat",
    [NB]: "fire-fcm",
    [LB]: "fire-fcm-compat",
    [GB]: "fire-perf",
    [HB]: "fire-perf-compat",
    [VB]: "fire-rc",
    [$B]: "fire-rc-compat",
    [KB]: "fire-gcs",
    [qB]: "fire-gcs-compat",
    [zB]: "fire-fst",
    [QB]: "fire-fst-compat",
    "fire-js": "fire-js",
    [YB]: "fire-js-all",
  };
var Nl = new Map(),
  Vh = new Map();
function JB(o, e) {
  try {
    o.container.addComponent(e);
  } catch (t) {
    hi.debug(
      `Component ${e.name} failed to register with FirebaseApp ${o.name}`,
      t
    );
  }
}
function kr(o) {
  let e = o.name;
  if (Vh.has(e))
    return (
      hi.debug(`There were multiple attempts to register component ${e}.`), !1
    );
  Vh.set(e, o);
  for (let t of Nl.values()) JB(t, o);
  return !0;
}
function gs(o, e) {
  let t = o.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return t && t.triggerHeartbeat(), o.container.getProvider(e);
}
var ZB = {
    ["no-app"]:
      "No Firebase App '{$appName}' has been created - call initializeApp() first",
    ["bad-app-name"]: "Illegal App name: '{$appName}",
    ["duplicate-app"]:
      "Firebase App named '{$appName}' already exists with different options or config",
    ["app-deleted"]: "Firebase App named '{$appName}' already deleted",
    ["no-options"]:
      "Need to provide options, when not being deployed to hosting via source.",
    ["invalid-app-argument"]:
      "firebase.{$appName}() takes either no argument or a Firebase App instance.",
    ["invalid-log-argument"]:
      "First argument to `onLog` must be null or a function.",
    ["idb-open"]:
      "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
    ["idb-get"]:
      "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
    ["idb-set"]:
      "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
    ["idb-delete"]:
      "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
  },
  Ur = new wr("app", "Firebase", ZB);
var $h = class {
  constructor(e, t, r) {
    (this._isDeleted = !1),
      (this._options = Object.assign({}, e)),
      (this._config = Object.assign({}, t)),
      (this._name = t.name),
      (this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled),
      (this._container = r),
      this.container.addComponent(new Ct("app", () => this, "PUBLIC"));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(e) {
    this.checkDestroyed(), (this._automaticDataCollectionEnabled = e);
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(e) {
    this._isDeleted = e;
  }
  checkDestroyed() {
    if (this.isDeleted) throw Ur.create("app-deleted", { appName: this._name });
  }
};
function zh(o, e = {}) {
  let t = o;
  typeof e != "object" && (e = { name: e });
  let r = Object.assign({ name: Hh, automaticDataCollectionEnabled: !1 }, e),
    i = r.name;
  if (typeof i != "string" || !i)
    throw Ur.create("bad-app-name", { appName: String(i) });
  if ((t || (t = Oh()), !t)) throw Ur.create("no-options");
  let s = Nl.get(i);
  if (s) {
    if (Dl(t, s.options) && Dl(r, s.config)) return s;
    throw Ur.create("duplicate-app", { appName: i });
  }
  let a = new Ol(i);
  for (let p of Vh.values()) a.addComponent(p);
  let n = new $h(t, r, a);
  return Nl.set(i, n), n;
}
function Qh(o = Hh) {
  let e = Nl.get(o);
  if (!e && o === Hh && Oh()) return zh();
  if (!e) throw Ur.create("no-app", { appName: o });
  return e;
}
function Yt(o, e, t) {
  var r;
  let i = (r = XB[o]) !== null && r !== void 0 ? r : o;
  t && (i += `-${t}`);
  let s = i.match(/\s|\//),
    a = e.match(/\s|\//);
  if (s || a) {
    let n = [`Unable to register library "${i}" with version "${e}":`];
    s &&
      n.push(
        `library name "${i}" contains illegal characters (whitespace or "/")`
      ),
      s && a && n.push("and"),
      a &&
        n.push(
          `version name "${e}" contains illegal characters (whitespace or "/")`
        ),
      hi.warn(n.join(" "));
    return;
  }
  kr(new Ct(`${i}-version`, () => ({ library: i, version: e }), "VERSION"));
}
var eC = "firebase-heartbeat-database",
  tC = 1,
  bs = "firebase-heartbeat-store",
  Nh = null;
function Bw() {
  return (
    Nh ||
      (Nh = Ky(eC, tC, {
        upgrade: (o, e) => {
          switch (e) {
            case 0:
              o.createObjectStore(bs);
          }
        },
      }).catch((o) => {
        throw Ur.create("idb-open", { originalErrorMessage: o.message });
      })),
    Nh
  );
}
async function rC(o) {
  try {
    return await (await Bw()).transaction(bs).objectStore(bs).get(Cw(o));
  } catch (e) {
    if (e instanceof Bt) hi.warn(e.message);
    else {
      let t = Ur.create("idb-get", { originalErrorMessage: e?.message });
      hi.warn(t.message);
    }
  }
}
async function Pw(o, e) {
  try {
    let r = (await Bw()).transaction(bs, "readwrite");
    await r.objectStore(bs).put(e, Cw(o)), await r.done;
  } catch (t) {
    if (t instanceof Bt) hi.warn(t.message);
    else {
      let r = Ur.create("idb-set", { originalErrorMessage: t?.message });
      hi.warn(r.message);
    }
  }
}
function Cw(o) {
  return `${o.name}!${o.options.appId}`;
}
var iC = 1024,
  oC = 30 * 24 * 60 * 60 * 1e3,
  Kh = class {
    constructor(e) {
      (this.container = e), (this._heartbeatsCache = null);
      let t = this.container.getProvider("app").getImmediate();
      (this._storage = new qh(t)),
        (this._heartbeatsCachePromise = this._storage
          .read()
          .then((r) => ((this._heartbeatsCache = r), r)));
    }
    async triggerHeartbeat() {
      let t = this.container
          .getProvider("platform-logger")
          .getImmediate()
          .getPlatformInfoString(),
        r = Rw();
      if (
        (this._heartbeatsCache === null &&
          (this._heartbeatsCache = await this._heartbeatsCachePromise),
        !(
          this._heartbeatsCache.lastSentHeartbeatDate === r ||
          this._heartbeatsCache.heartbeats.some((i) => i.date === r)
        ))
      )
        return (
          this._heartbeatsCache.heartbeats.push({ date: r, agent: t }),
          (this._heartbeatsCache.heartbeats =
            this._heartbeatsCache.heartbeats.filter((i) => {
              let s = new Date(i.date).valueOf();
              return Date.now() - s <= oC;
            })),
          this._storage.overwrite(this._heartbeatsCache)
        );
    }
    async getHeartbeatsHeader() {
      if (
        (this._heartbeatsCache === null && (await this._heartbeatsCachePromise),
        this._heartbeatsCache === null ||
          this._heartbeatsCache.heartbeats.length === 0)
      )
        return "";
      let e = Rw(),
        { heartbeatsToSend: t, unsentEntries: r } = sC(
          this._heartbeatsCache.heartbeats
        ),
        i = Uh(JSON.stringify({ version: 2, heartbeats: t }));
      return (
        (this._heartbeatsCache.lastSentHeartbeatDate = e),
        r.length > 0
          ? ((this._heartbeatsCache.heartbeats = r),
            await this._storage.overwrite(this._heartbeatsCache))
          : ((this._heartbeatsCache.heartbeats = []),
            this._storage.overwrite(this._heartbeatsCache)),
        i
      );
    }
  };
function Rw() {
  return new Date().toISOString().substring(0, 10);
}
function sC(o, e = iC) {
  let t = [],
    r = o.slice();
  for (let i of o) {
    let s = t.find((a) => a.agent === i.agent);
    if (s) {
      if ((s.dates.push(i.date), Ew(t) > e)) {
        s.dates.pop();
        break;
      }
    } else if ((t.push({ agent: i.agent, dates: [i.date] }), Ew(t) > e)) {
      t.pop();
      break;
    }
    r = r.slice(1);
  }
  return { heartbeatsToSend: t, unsentEntries: r };
}
var qh = class {
  constructor(e) {
    (this.app = e),
      (this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck());
  }
  async runIndexedDBEnvironmentCheck() {
    return xl()
      ? Wl()
          .then(() => !0)
          .catch(() => !1)
      : !1;
  }
  async read() {
    return (await this._canUseIndexedDBPromise)
      ? (await rC(this.app)) || { heartbeats: [] }
      : { heartbeats: [] };
  }
  async overwrite(e) {
    var t;
    if (await this._canUseIndexedDBPromise) {
      let i = await this.read();
      return Pw(this.app, {
        lastSentHeartbeatDate:
          (t = e.lastSentHeartbeatDate) !== null && t !== void 0
            ? t
            : i.lastSentHeartbeatDate,
        heartbeats: e.heartbeats,
      });
    } else return;
  }
  async add(e) {
    var t;
    if (await this._canUseIndexedDBPromise) {
      let i = await this.read();
      return Pw(this.app, {
        lastSentHeartbeatDate:
          (t = e.lastSentHeartbeatDate) !== null && t !== void 0
            ? t
            : i.lastSentHeartbeatDate,
        heartbeats: [...i.heartbeats, ...e.heartbeats],
      });
    } else return;
  }
};
function Ew(o) {
  return Uh(JSON.stringify({ version: 2, heartbeats: o })).length;
}
function aC(o) {
  kr(new Ct("platform-logger", (e) => new Lh(e), "PRIVATE")),
    kr(new Ct("heartbeat", (e) => new Kh(e), "PRIVATE")),
    Yt(Gh, Aw, o),
    Yt(Gh, Aw, "esm2017"),
    Yt("fire-js", "");
}
aC("");
var nC = "firebase",
  cC = "9.23.0";
Yt(nC, cC, "app");
c();
c();
c();
c();
c();
var pC = (o, e) => e.some((t) => o instanceof t),
  _w,
  Fw;
function lC() {
  return (
    _w ||
    (_w = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
  );
}
function dC() {
  return (
    Fw ||
    (Fw = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey,
    ])
  );
}
var Mw = new WeakMap(),
  Xh = new WeakMap(),
  xw = new WeakMap(),
  Yh = new WeakMap(),
  Zh = new WeakMap();
function uC(o) {
  let e = new Promise((t, r) => {
    let i = () => {
        o.removeEventListener("success", s), o.removeEventListener("error", a);
      },
      s = () => {
        t(sr(o.result)), i();
      },
      a = () => {
        r(o.error), i();
      };
    o.addEventListener("success", s), o.addEventListener("error", a);
  });
  return (
    e
      .then((t) => {
        t instanceof IDBCursor && Mw.set(t, o);
      })
      .catch(() => {}),
    Zh.set(e, o),
    e
  );
}
function mC(o) {
  if (Xh.has(o)) return;
  let e = new Promise((t, r) => {
    let i = () => {
        o.removeEventListener("complete", s),
          o.removeEventListener("error", a),
          o.removeEventListener("abort", a);
      },
      s = () => {
        t(), i();
      },
      a = () => {
        r(o.error || new DOMException("AbortError", "AbortError")), i();
      };
    o.addEventListener("complete", s),
      o.addEventListener("error", a),
      o.addEventListener("abort", a);
  });
  Xh.set(o, e);
}
var Jh = {
  get(o, e, t) {
    if (o instanceof IDBTransaction) {
      if (e === "done") return Xh.get(o);
      if (e === "objectStoreNames") return o.objectStoreNames || xw.get(o);
      if (e === "store")
        return t.objectStoreNames[1]
          ? void 0
          : t.objectStore(t.objectStoreNames[0]);
    }
    return sr(o[e]);
  },
  set(o, e, t) {
    return (o[e] = t), !0;
  },
  has(o, e) {
    return o instanceof IDBTransaction && (e === "done" || e === "store")
      ? !0
      : e in o;
  },
};
function Ww(o) {
  Jh = o(Jh);
}
function hC(o) {
  return o === IDBDatabase.prototype.transaction &&
    !("objectStoreNames" in IDBTransaction.prototype)
    ? function (e, ...t) {
        let r = o.call(Ll(this), e, ...t);
        return xw.set(r, e.sort ? e.sort() : [e]), sr(r);
      }
    : dC().includes(o)
    ? function (...e) {
        return o.apply(Ll(this), e), sr(Mw.get(this));
      }
    : function (...e) {
        return sr(o.apply(Ll(this), e));
      };
}
function yC(o) {
  return typeof o == "function"
    ? hC(o)
    : (o instanceof IDBTransaction && mC(o),
      pC(o, lC()) ? new Proxy(o, Jh) : o);
}
function sr(o) {
  if (o instanceof IDBRequest) return uC(o);
  if (Yh.has(o)) return Yh.get(o);
  let e = yC(o);
  return e !== o && (Yh.set(o, e), Zh.set(e, o)), e;
}
var Ll = (o) => Zh.get(o);
function Uw(o, e, { blocked: t, upgrade: r, blocking: i, terminated: s } = {}) {
  let a = indexedDB.open(o, e),
    n = sr(a);
  return (
    r &&
      a.addEventListener("upgradeneeded", (p) => {
        r(sr(a.result), p.oldVersion, p.newVersion, sr(a.transaction));
      }),
    t && a.addEventListener("blocked", () => t()),
    n
      .then((p) => {
        s && p.addEventListener("close", () => s()),
          i && p.addEventListener("versionchange", () => i());
      })
      .catch(() => {}),
    n
  );
}
var bC = ["get", "getKey", "getAll", "getAllKeys", "count"],
  gC = ["put", "add", "delete", "clear"],
  ey = new Map();
function Dw(o, e) {
  if (!(o instanceof IDBDatabase && !(e in o) && typeof e == "string")) return;
  if (ey.get(e)) return ey.get(e);
  let t = e.replace(/FromIndex$/, ""),
    r = e !== t,
    i = gC.includes(t);
  if (
    !(t in (r ? IDBIndex : IDBObjectStore).prototype) ||
    !(i || bC.includes(t))
  )
    return;
  let s = async function (a, ...n) {
    let p = this.transaction(a, i ? "readwrite" : "readonly"),
      d = p.store;
    return (
      r && (d = d.index(n.shift())),
      (await Promise.all([d[t](...n), i && p.done]))[0]
    );
  };
  return ey.set(e, s), s;
}
Ww((o) => ({
  ...o,
  get: (e, t, r) => Dw(e, t) || o.get(e, t, r),
  has: (e, t) => !!Dw(e, t) || o.has(e, t),
}));
var Nw = "@firebase/installations",
  oy = "0.6.4";
var Lw = 1e4,
  Gw = `w:${oy}`,
  Hw = "FIS_v2",
  vC = "https://firebaseinstallations.googleapis.com/v1",
  fC = 60 * 60 * 1e3,
  SC = "installations",
  wC = "Installations";
var kC = {
    ["missing-app-config-values"]:
      'Missing App configuration value: "{$valueName}"',
    ["not-registered"]: "Firebase Installation is not registered.",
    ["installation-not-found"]: "Firebase Installation not found.",
    ["request-failed"]:
      '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
    ["app-offline"]: "Could not process request. Application offline.",
    ["delete-pending-registration"]:
      "Can't delete installation while there is a pending registration request.",
  },
  bi = new wr(SC, wC, kC);
function Vw(o) {
  return o instanceof Bt && o.code.includes("request-failed");
}
function $w({ projectId: o }) {
  return `${vC}/projects/${o}/installations`;
}
function Kw(o) {
  return {
    token: o.token,
    requestStatus: 2,
    expiresIn: IC(o.expiresIn),
    creationTime: Date.now(),
  };
}
async function qw(o, e) {
  let r = (await e.json()).error;
  return bi.create("request-failed", {
    requestName: o,
    serverCode: r.code,
    serverMessage: r.message,
    serverStatus: r.status,
  });
}
function zw({ apiKey: o }) {
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": o,
  });
}
function TC(o, { refreshToken: e }) {
  let t = zw(o);
  return t.append("Authorization", AC(e)), t;
}
async function Qw(o) {
  let e = await o();
  return e.status >= 500 && e.status < 600 ? o() : e;
}
function IC(o) {
  return Number(o.replace("s", "000"));
}
function AC(o) {
  return `${Hw} ${o}`;
}
async function PC({ appConfig: o, heartbeatServiceProvider: e }, { fid: t }) {
  let r = $w(o),
    i = zw(o),
    s = e.getImmediate({ optional: !0 });
  if (s) {
    let d = await s.getHeartbeatsHeader();
    d && i.append("x-firebase-client", d);
  }
  let a = { fid: t, authVersion: Hw, appId: o.appId, sdkVersion: Gw },
    n = { method: "POST", headers: i, body: JSON.stringify(a) },
    p = await Qw(() => fetch(r, n));
  if (p.ok) {
    let d = await p.json();
    return {
      fid: d.fid || t,
      registrationStatus: 2,
      refreshToken: d.refreshToken,
      authToken: Kw(d.authToken),
    };
  } else throw await qw("Create Installation", p);
}
function Yw(o) {
  return new Promise((e) => {
    setTimeout(e, o);
  });
}
function RC(o) {
  return btoa(String.fromCharCode(...o))
    .replace(/\+/g, "-")
    .replace(/\//g, "_");
}
var EC = /^[cdef][\w-]{21}$/,
  iy = "";
function BC() {
  try {
    let o = new Uint8Array(17);
    (self.crypto || self.msCrypto).getRandomValues(o),
      (o[0] = 112 + (o[0] % 16));
    let t = CC(o);
    return EC.test(t) ? t : iy;
  } catch {
    return iy;
  }
}
function CC(o) {
  return RC(o).substr(0, 22);
}
function Hl(o) {
  return `${o.appName}!${o.appId}`;
}
var Xw = new Map();
function Jw(o, e) {
  let t = Hl(o);
  Zw(t, e), _C(t, e);
}
function Zw(o, e) {
  let t = Xw.get(o);
  if (t) for (let r of t) r(e);
}
function _C(o, e) {
  let t = FC();
  t && t.postMessage({ key: o, fid: e }), MC();
}
var yi = null;
function FC() {
  return (
    !yi &&
      "BroadcastChannel" in self &&
      ((yi = new BroadcastChannel("[Firebase] FID Change")),
      (yi.onmessage = (o) => {
        Zw(o.data.key, o.data.fid);
      })),
    yi
  );
}
function MC() {
  Xw.size === 0 && yi && (yi.close(), (yi = null));
}
var xC = "firebase-installations-database",
  WC = 1,
  gi = "firebase-installations-store",
  ty = null;
function sy() {
  return (
    ty ||
      (ty = Uw(xC, WC, {
        upgrade: (o, e) => {
          switch (e) {
            case 0:
              o.createObjectStore(gi);
          }
        },
      })),
    ty
  );
}
async function Gl(o, e) {
  let t = Hl(o),
    i = (await sy()).transaction(gi, "readwrite"),
    s = i.objectStore(gi),
    a = await s.get(t);
  return (
    await s.put(e, t), await i.done, (!a || a.fid !== e.fid) && Jw(o, e.fid), e
  );
}
async function ek(o) {
  let e = Hl(o),
    r = (await sy()).transaction(gi, "readwrite");
  await r.objectStore(gi).delete(e), await r.done;
}
async function Vl(o, e) {
  let t = Hl(o),
    i = (await sy()).transaction(gi, "readwrite"),
    s = i.objectStore(gi),
    a = await s.get(t),
    n = e(a);
  return (
    n === void 0 ? await s.delete(t) : await s.put(n, t),
    await i.done,
    n && (!a || a.fid !== n.fid) && Jw(o, n.fid),
    n
  );
}
async function ay(o) {
  let e,
    t = await Vl(o.appConfig, (r) => {
      let i = DC(r),
        s = UC(o, i);
      return (e = s.registrationPromise), s.installationEntry;
    });
  return t.fid === iy
    ? { installationEntry: await e }
    : { installationEntry: t, registrationPromise: e };
}
function DC(o) {
  let e = o || { fid: BC(), registrationStatus: 0 };
  return tk(e);
}
function UC(o, e) {
  if (e.registrationStatus === 0) {
    if (!navigator.onLine) {
      let i = Promise.reject(bi.create("app-offline"));
      return { installationEntry: e, registrationPromise: i };
    }
    let t = { fid: e.fid, registrationStatus: 1, registrationTime: Date.now() },
      r = OC(o, t);
    return { installationEntry: t, registrationPromise: r };
  } else
    return e.registrationStatus === 1
      ? { installationEntry: e, registrationPromise: jC(o) }
      : { installationEntry: e };
}
async function OC(o, e) {
  try {
    let t = await PC(o, e);
    return Gl(o.appConfig, t);
  } catch (t) {
    throw (
      (Vw(t) && t.customData.serverCode === 409
        ? await ek(o.appConfig)
        : await Gl(o.appConfig, { fid: e.fid, registrationStatus: 0 }),
      t)
    );
  }
}
async function jC(o) {
  let e = await Ow(o.appConfig);
  for (; e.registrationStatus === 1; )
    await Yw(100), (e = await Ow(o.appConfig));
  if (e.registrationStatus === 0) {
    let { installationEntry: t, registrationPromise: r } = await ay(o);
    return r || t;
  }
  return e;
}
function Ow(o) {
  return Vl(o, (e) => {
    if (!e) throw bi.create("installation-not-found");
    return tk(e);
  });
}
function tk(o) {
  return NC(o) ? { fid: o.fid, registrationStatus: 0 } : o;
}
function NC(o) {
  return o.registrationStatus === 1 && o.registrationTime + Lw < Date.now();
}
async function LC({ appConfig: o, heartbeatServiceProvider: e }, t) {
  let r = GC(o, t),
    i = TC(o, t),
    s = e.getImmediate({ optional: !0 });
  if (s) {
    let d = await s.getHeartbeatsHeader();
    d && i.append("x-firebase-client", d);
  }
  let a = { installation: { sdkVersion: Gw, appId: o.appId } },
    n = { method: "POST", headers: i, body: JSON.stringify(a) },
    p = await Qw(() => fetch(r, n));
  if (p.ok) {
    let d = await p.json();
    return Kw(d);
  } else throw await qw("Generate Auth Token", p);
}
function GC(o, { fid: e }) {
  return `${$w(o)}/${e}/authTokens:generate`;
}
async function ny(o, e = !1) {
  let t,
    r = await Vl(o.appConfig, (s) => {
      if (!rk(s)) throw bi.create("not-registered");
      let a = s.authToken;
      if (!e && $C(a)) return s;
      if (a.requestStatus === 1) return (t = HC(o, e)), s;
      {
        if (!navigator.onLine) throw bi.create("app-offline");
        let n = qC(s);
        return (t = VC(o, n)), n;
      }
    });
  return t ? await t : r.authToken;
}
async function HC(o, e) {
  let t = await jw(o.appConfig);
  for (; t.authToken.requestStatus === 1; )
    await Yw(100), (t = await jw(o.appConfig));
  let r = t.authToken;
  return r.requestStatus === 0 ? ny(o, e) : r;
}
function jw(o) {
  return Vl(o, (e) => {
    if (!rk(e)) throw bi.create("not-registered");
    let t = e.authToken;
    return zC(t)
      ? Object.assign(Object.assign({}, e), { authToken: { requestStatus: 0 } })
      : e;
  });
}
async function VC(o, e) {
  try {
    let t = await LC(o, e),
      r = Object.assign(Object.assign({}, e), { authToken: t });
    return await Gl(o.appConfig, r), t;
  } catch (t) {
    if (
      Vw(t) &&
      (t.customData.serverCode === 401 || t.customData.serverCode === 404)
    )
      await ek(o.appConfig);
    else {
      let r = Object.assign(Object.assign({}, e), {
        authToken: { requestStatus: 0 },
      });
      await Gl(o.appConfig, r);
    }
    throw t;
  }
}
function rk(o) {
  return o !== void 0 && o.registrationStatus === 2;
}
function $C(o) {
  return o.requestStatus === 2 && !KC(o);
}
function KC(o) {
  let e = Date.now();
  return e < o.creationTime || o.creationTime + o.expiresIn < e + fC;
}
function qC(o) {
  let e = { requestStatus: 1, requestTime: Date.now() };
  return Object.assign(Object.assign({}, o), { authToken: e });
}
function zC(o) {
  return o.requestStatus === 1 && o.requestTime + Lw < Date.now();
}
async function QC(o) {
  let e = o,
    { installationEntry: t, registrationPromise: r } = await ay(e);
  return r ? r.catch(console.error) : ny(e).catch(console.error), t.fid;
}
async function YC(o, e = !1) {
  let t = o;
  return await XC(t), (await ny(t, e)).token;
}
async function XC(o) {
  let { registrationPromise: e } = await ay(o);
  e && (await e);
}
function JC(o) {
  if (!o || !o.options) throw ry("App Configuration");
  if (!o.name) throw ry("App Name");
  let e = ["projectId", "apiKey", "appId"];
  for (let t of e) if (!o.options[t]) throw ry(t);
  return {
    appName: o.name,
    projectId: o.options.projectId,
    apiKey: o.options.apiKey,
    appId: o.options.appId,
  };
}
function ry(o) {
  return bi.create("missing-app-config-values", { valueName: o });
}
var ik = "installations",
  ZC = "installations-internal",
  e_ = (o) => {
    let e = o.getProvider("app").getImmediate(),
      t = JC(e),
      r = gs(e, "heartbeat");
    return {
      app: e,
      appConfig: t,
      heartbeatServiceProvider: r,
      _delete: () => Promise.resolve(),
    };
  },
  t_ = (o) => {
    let e = o.getProvider("app").getImmediate(),
      t = gs(e, ik).getImmediate();
    return { getId: () => QC(t), getToken: (i) => YC(t, i) };
  };
function r_() {
  kr(new Ct(ik, e_, "PUBLIC")), kr(new Ct(ZC, t_, "PRIVATE"));
}
r_();
Yt(Nw, oy);
Yt(Nw, oy, "esm2017");
c();
c();
var i_ = (o, e) => e.some((t) => o instanceof t),
  ok,
  sk;
function o_() {
  return (
    ok ||
    (ok = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
  );
}
function s_() {
  return (
    sk ||
    (sk = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey,
    ])
  );
}
var ak = new WeakMap(),
  py = new WeakMap(),
  nk = new WeakMap(),
  cy = new WeakMap(),
  dy = new WeakMap();
function a_(o) {
  let e = new Promise((t, r) => {
    let i = () => {
        o.removeEventListener("success", s), o.removeEventListener("error", a);
      },
      s = () => {
        t(Xt(o.result)), i();
      },
      a = () => {
        r(o.error), i();
      };
    o.addEventListener("success", s), o.addEventListener("error", a);
  });
  return (
    e
      .then((t) => {
        t instanceof IDBCursor && ak.set(t, o);
      })
      .catch(() => {}),
    dy.set(e, o),
    e
  );
}
function n_(o) {
  if (py.has(o)) return;
  let e = new Promise((t, r) => {
    let i = () => {
        o.removeEventListener("complete", s),
          o.removeEventListener("error", a),
          o.removeEventListener("abort", a);
      },
      s = () => {
        t(), i();
      },
      a = () => {
        r(o.error || new DOMException("AbortError", "AbortError")), i();
      };
    o.addEventListener("complete", s),
      o.addEventListener("error", a),
      o.addEventListener("abort", a);
  });
  py.set(o, e);
}
var ly = {
  get(o, e, t) {
    if (o instanceof IDBTransaction) {
      if (e === "done") return py.get(o);
      if (e === "objectStoreNames") return o.objectStoreNames || nk.get(o);
      if (e === "store")
        return t.objectStoreNames[1]
          ? void 0
          : t.objectStore(t.objectStoreNames[0]);
    }
    return Xt(o[e]);
  },
  set(o, e, t) {
    return (o[e] = t), !0;
  },
  has(o, e) {
    return o instanceof IDBTransaction && (e === "done" || e === "store")
      ? !0
      : e in o;
  },
};
function ck(o) {
  ly = o(ly);
}
function c_(o) {
  return o === IDBDatabase.prototype.transaction &&
    !("objectStoreNames" in IDBTransaction.prototype)
    ? function (e, ...t) {
        let r = o.call($l(this), e, ...t);
        return nk.set(r, e.sort ? e.sort() : [e]), Xt(r);
      }
    : s_().includes(o)
    ? function (...e) {
        return o.apply($l(this), e), Xt(ak.get(this));
      }
    : function (...e) {
        return Xt(o.apply($l(this), e));
      };
}
function p_(o) {
  return typeof o == "function"
    ? c_(o)
    : (o instanceof IDBTransaction && n_(o),
      i_(o, o_()) ? new Proxy(o, ly) : o);
}
function Xt(o) {
  if (o instanceof IDBRequest) return a_(o);
  if (cy.has(o)) return cy.get(o);
  let e = p_(o);
  return e !== o && (cy.set(o, e), dy.set(e, o)), e;
}
var $l = (o) => dy.get(o);
function my(o, e, { blocked: t, upgrade: r, blocking: i, terminated: s } = {}) {
  let a = indexedDB.open(o, e),
    n = Xt(a);
  return (
    r &&
      a.addEventListener("upgradeneeded", (p) => {
        r(Xt(a.result), p.oldVersion, p.newVersion, Xt(a.transaction));
      }),
    t && a.addEventListener("blocked", () => t()),
    n
      .then((p) => {
        s && p.addEventListener("close", () => s()),
          i && p.addEventListener("versionchange", () => i());
      })
      .catch(() => {}),
    n
  );
}
function Kl(o, { blocked: e } = {}) {
  let t = indexedDB.deleteDatabase(o);
  return e && t.addEventListener("blocked", () => e()), Xt(t).then(() => {});
}
var l_ = ["get", "getKey", "getAll", "getAllKeys", "count"],
  d_ = ["put", "add", "delete", "clear"],
  uy = new Map();
function pk(o, e) {
  if (!(o instanceof IDBDatabase && !(e in o) && typeof e == "string")) return;
  if (uy.get(e)) return uy.get(e);
  let t = e.replace(/FromIndex$/, ""),
    r = e !== t,
    i = d_.includes(t);
  if (
    !(t in (r ? IDBIndex : IDBObjectStore).prototype) ||
    !(i || l_.includes(t))
  )
    return;
  let s = async function (a, ...n) {
    let p = this.transaction(a, i ? "readwrite" : "readonly"),
      d = p.store;
    return (
      r && (d = d.index(n.shift())),
      (await Promise.all([d[t](...n), i && p.done]))[0]
    );
  };
  return uy.set(e, s), s;
}
ck((o) => ({
  ...o,
  get: (e, t, r) => pk(e, t) || o.get(e, t, r),
  has: (e, t) => !!pk(e, t) || o.has(e, t),
}));
var u_ = "/firebase-messaging-sw.js",
  m_ = "/firebase-cloud-messaging-push-scope",
  bk =
    "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4",
  h_ = "https://fcmregistrations.googleapis.com/v1",
  gk = "google.c.a.c_id",
  y_ = "google.c.a.c_l",
  b_ = "google.c.a.ts",
  g_ = "google.c.a.e",
  lk;
(function (o) {
  (o[(o.DATA_MESSAGE = 1)] = "DATA_MESSAGE"),
    (o[(o.DISPLAY_NOTIFICATION = 3)] = "DISPLAY_NOTIFICATION");
})(lk || (lk = {}));
var vs;
(function (o) {
  (o.PUSH_RECEIVED = "push-received"),
    (o.NOTIFICATION_CLICKED = "notification-clicked");
})(vs || (vs = {}));
function Tr(o) {
  let e = new Uint8Array(o);
  return btoa(String.fromCharCode(...e))
    .replace(/=/g, "")
    .replace(/\+/g, "-")
    .replace(/\//g, "_");
}
function v_(o) {
  let e = "=".repeat((4 - (o.length % 4)) % 4),
    t = (o + e).replace(/\-/g, "+").replace(/_/g, "/"),
    r = atob(t),
    i = new Uint8Array(r.length);
  for (let s = 0; s < r.length; ++s) i[s] = r.charCodeAt(s);
  return i;
}
var hy = "fcm_token_details_db",
  f_ = 5,
  dk = "fcm_token_object_Store";
async function S_(o) {
  if (
    "databases" in indexedDB &&
    !(await indexedDB.databases()).map((s) => s.name).includes(hy)
  )
    return null;
  let e = null;
  return (
    (
      await my(hy, f_, {
        upgrade: async (r, i, s, a) => {
          var n;
          if (i < 2 || !r.objectStoreNames.contains(dk)) return;
          let p = a.objectStore(dk),
            d = await p.index("fcmSenderId").get(o);
          if ((await p.clear(), !!d)) {
            if (i === 2) {
              let u = d;
              if (!u.auth || !u.p256dh || !u.endpoint) return;
              e = {
                token: u.fcmToken,
                createTime:
                  (n = u.createTime) !== null && n !== void 0 ? n : Date.now(),
                subscriptionOptions: {
                  auth: u.auth,
                  p256dh: u.p256dh,
                  endpoint: u.endpoint,
                  swScope: u.swScope,
                  vapidKey:
                    typeof u.vapidKey == "string" ? u.vapidKey : Tr(u.vapidKey),
                },
              };
            } else if (i === 3) {
              let u = d;
              e = {
                token: u.fcmToken,
                createTime: u.createTime,
                subscriptionOptions: {
                  auth: Tr(u.auth),
                  p256dh: Tr(u.p256dh),
                  endpoint: u.endpoint,
                  swScope: u.swScope,
                  vapidKey: Tr(u.vapidKey),
                },
              };
            } else if (i === 4) {
              let u = d;
              e = {
                token: u.fcmToken,
                createTime: u.createTime,
                subscriptionOptions: {
                  auth: Tr(u.auth),
                  p256dh: Tr(u.p256dh),
                  endpoint: u.endpoint,
                  swScope: u.swScope,
                  vapidKey: Tr(u.vapidKey),
                },
              };
            }
          }
        },
      })
    ).close(),
    await Kl(hy),
    await Kl("fcm_vapid_details_db"),
    await Kl("undefined"),
    w_(e) ? e : null
  );
}
function w_(o) {
  if (!o || !o.subscriptionOptions) return !1;
  let { subscriptionOptions: e } = o;
  return (
    typeof o.createTime == "number" &&
    o.createTime > 0 &&
    typeof o.token == "string" &&
    o.token.length > 0 &&
    typeof e.auth == "string" &&
    e.auth.length > 0 &&
    typeof e.p256dh == "string" &&
    e.p256dh.length > 0 &&
    typeof e.endpoint == "string" &&
    e.endpoint.length > 0 &&
    typeof e.swScope == "string" &&
    e.swScope.length > 0 &&
    typeof e.vapidKey == "string" &&
    e.vapidKey.length > 0
  );
}
var k_ = "firebase-messaging-database",
  T_ = 1,
  vi = "firebase-messaging-store",
  yy = null;
function vy() {
  return (
    yy ||
      (yy = my(k_, T_, {
        upgrade: (o, e) => {
          switch (e) {
            case 0:
              o.createObjectStore(vi);
          }
        },
      })),
    yy
  );
}
async function vk(o) {
  let e = Sy(o),
    r = await (await vy()).transaction(vi).objectStore(vi).get(e);
  if (r) return r;
  {
    let i = await S_(o.appConfig.senderId);
    if (i) return await fy(o, i), i;
  }
}
async function fy(o, e) {
  let t = Sy(o),
    i = (await vy()).transaction(vi, "readwrite");
  return await i.objectStore(vi).put(e, t), await i.done, e;
}
async function I_(o) {
  let e = Sy(o),
    r = (await vy()).transaction(vi, "readwrite");
  await r.objectStore(vi).delete(e), await r.done;
}
function Sy({ appConfig: o }) {
  return o.appId;
}
var A_ = {
    ["missing-app-config-values"]:
      'Missing App configuration value: "{$valueName}"',
    ["only-available-in-window"]:
      "This method is available in a Window context.",
    ["only-available-in-sw"]:
      "This method is available in a service worker context.",
    ["permission-default"]:
      "The notification permission was not granted and dismissed instead.",
    ["permission-blocked"]:
      "The notification permission was not granted and blocked instead.",
    ["unsupported-browser"]:
      "This browser doesn't support the API's required to use the Firebase SDK.",
    ["indexed-db-unsupported"]:
      "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
    ["failed-service-worker-registration"]:
      "We are unable to register the default service worker. {$browserErrorMessage}",
    ["token-subscribe-failed"]:
      "A problem occurred while subscribing the user to FCM: {$errorInfo}",
    ["token-subscribe-no-token"]:
      "FCM returned no token when subscribing the user to push.",
    ["token-unsubscribe-failed"]:
      "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
    ["token-update-failed"]:
      "A problem occurred while updating the user from FCM: {$errorInfo}",
    ["token-update-no-token"]:
      "FCM returned no token when updating the user to push.",
    ["use-sw-after-get-token"]:
      "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
    ["invalid-sw-registration"]:
      "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
    ["invalid-bg-handler"]:
      "The input to setBackgroundMessageHandler() must be a function.",
    ["invalid-vapid-key"]: "The public VAPID key must be a string.",
    ["use-vapid-key-after-get-token"]:
      "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used.",
  },
  nt = new wr("messaging", "Messaging", A_);
async function P_(o, e) {
  let t = await ky(o),
    r = Sk(e),
    i = { method: "POST", headers: t, body: JSON.stringify(r) },
    s;
  try {
    s = await (await fetch(wy(o.appConfig), i)).json();
  } catch (a) {
    throw nt.create("token-subscribe-failed", { errorInfo: a?.toString() });
  }
  if (s.error) {
    let a = s.error.message;
    throw nt.create("token-subscribe-failed", { errorInfo: a });
  }
  if (!s.token) throw nt.create("token-subscribe-no-token");
  return s.token;
}
async function R_(o, e) {
  let t = await ky(o),
    r = Sk(e.subscriptionOptions),
    i = { method: "PATCH", headers: t, body: JSON.stringify(r) },
    s;
  try {
    s = await (await fetch(`${wy(o.appConfig)}/${e.token}`, i)).json();
  } catch (a) {
    throw nt.create("token-update-failed", { errorInfo: a?.toString() });
  }
  if (s.error) {
    let a = s.error.message;
    throw nt.create("token-update-failed", { errorInfo: a });
  }
  if (!s.token) throw nt.create("token-update-no-token");
  return s.token;
}
async function fk(o, e) {
  let r = { method: "DELETE", headers: await ky(o) };
  try {
    let s = await (await fetch(`${wy(o.appConfig)}/${e}`, r)).json();
    if (s.error) {
      let a = s.error.message;
      throw nt.create("token-unsubscribe-failed", { errorInfo: a });
    }
  } catch (i) {
    throw nt.create("token-unsubscribe-failed", { errorInfo: i?.toString() });
  }
}
function wy({ projectId: o }) {
  return `${h_}/projects/${o}/registrations`;
}
async function ky({ appConfig: o, installations: e }) {
  let t = await e.getToken();
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": o.apiKey,
    "x-goog-firebase-installations-auth": `FIS ${t}`,
  });
}
function Sk({ p256dh: o, auth: e, endpoint: t, vapidKey: r }) {
  let i = { web: { endpoint: t, auth: e, p256dh: o } };
  return r !== bk && (i.web.applicationPubKey = r), i;
}
var E_ = 7 * 24 * 60 * 60 * 1e3;
async function B_(o) {
  let e = await __(o.swRegistration, o.vapidKey),
    t = {
      vapidKey: o.vapidKey,
      swScope: o.swRegistration.scope,
      endpoint: e.endpoint,
      auth: Tr(e.getKey("auth")),
      p256dh: Tr(e.getKey("p256dh")),
    },
    r = await vk(o.firebaseDependencies);
  if (r) {
    if (F_(r.subscriptionOptions, t))
      return Date.now() >= r.createTime + E_
        ? C_(o, {
            token: r.token,
            createTime: Date.now(),
            subscriptionOptions: t,
          })
        : r.token;
    try {
      await fk(o.firebaseDependencies, r.token);
    } catch (i) {
      console.warn(i);
    }
    return uk(o.firebaseDependencies, t);
  } else return uk(o.firebaseDependencies, t);
}
async function wk(o) {
  let e = await vk(o.firebaseDependencies);
  e &&
    (await fk(o.firebaseDependencies, e.token),
    await I_(o.firebaseDependencies));
  let t = await o.swRegistration.pushManager.getSubscription();
  return t ? t.unsubscribe() : !0;
}
async function C_(o, e) {
  try {
    let t = await R_(o.firebaseDependencies, e),
      r = Object.assign(Object.assign({}, e), {
        token: t,
        createTime: Date.now(),
      });
    return await fy(o.firebaseDependencies, r), t;
  } catch (t) {
    throw (await wk(o), t);
  }
}
async function uk(o, e) {
  let r = {
    token: await P_(o, e),
    createTime: Date.now(),
    subscriptionOptions: e,
  };
  return await fy(o, r), r.token;
}
async function __(o, e) {
  let t = await o.pushManager.getSubscription();
  return (
    t ||
    o.pushManager.subscribe({
      userVisibleOnly: !0,
      applicationServerKey: v_(e),
    })
  );
}
function F_(o, e) {
  let t = e.vapidKey === o.vapidKey,
    r = e.endpoint === o.endpoint,
    i = e.auth === o.auth,
    s = e.p256dh === o.p256dh;
  return t && r && i && s;
}
function mk(o) {
  let e = {
    from: o.from,
    collapseKey: o.collapse_key,
    messageId: o.fcmMessageId,
  };
  return M_(e, o), x_(e, o), W_(e, o), e;
}
function M_(o, e) {
  if (!e.notification) return;
  o.notification = {};
  let t = e.notification.title;
  t && (o.notification.title = t);
  let r = e.notification.body;
  r && (o.notification.body = r);
  let i = e.notification.image;
  i && (o.notification.image = i);
  let s = e.notification.icon;
  s && (o.notification.icon = s);
}
function x_(o, e) {
  e.data && (o.data = e.data);
}
function W_(o, e) {
  var t, r, i, s, a;
  if (
    !e.fcmOptions &&
    !(!((t = e.notification) === null || t === void 0) && t.click_action)
  )
    return;
  o.fcmOptions = {};
  let n =
    (i = (r = e.fcmOptions) === null || r === void 0 ? void 0 : r.link) !==
      null && i !== void 0
      ? i
      : (s = e.notification) === null || s === void 0
      ? void 0
      : s.click_action;
  n && (o.fcmOptions.link = n);
  let p =
    (a = e.fcmOptions) === null || a === void 0 ? void 0 : a.analytics_label;
  p && (o.fcmOptions.analyticsLabel = p);
}
function D_(o) {
  return typeof o == "object" && !!o && gk in o;
}
kk("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
kk("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4");
function kk(o, e) {
  let t = [];
  for (let r = 0; r < o.length; r++)
    t.push(o.charAt(r)), r < e.length && t.push(e.charAt(r));
  return t.join("");
}
function U_(o) {
  if (!o || !o.options) throw by("App Configuration Object");
  if (!o.name) throw by("App Name");
  let e = ["projectId", "apiKey", "appId", "messagingSenderId"],
    { options: t } = o;
  for (let r of e) if (!t[r]) throw by(r);
  return {
    appName: o.name,
    projectId: t.projectId,
    apiKey: t.apiKey,
    appId: t.appId,
    senderId: t.messagingSenderId,
  };
}
function by(o) {
  return nt.create("missing-app-config-values", { valueName: o });
}
var gy = class {
  constructor(e, t, r) {
    (this.deliveryMetricsExportedToBigQueryEnabled = !1),
      (this.onBackgroundMessageHandler = null),
      (this.onMessageHandler = null),
      (this.logEvents = []),
      (this.isLogServiceStarted = !1);
    let i = U_(e);
    this.firebaseDependencies = {
      app: e,
      appConfig: i,
      installations: t,
      analyticsProvider: r,
    };
  }
  _delete() {
    return Promise.resolve();
  }
};
async function Tk(o) {
  try {
    (o.swRegistration = await navigator.serviceWorker.register(u_, {
      scope: m_,
    })),
      o.swRegistration.update().catch(() => {});
  } catch (e) {
    throw nt.create("failed-service-worker-registration", {
      browserErrorMessage: e?.message,
    });
  }
}
async function O_(o, e) {
  if ((!e && !o.swRegistration && (await Tk(o)), !(!e && o.swRegistration))) {
    if (!(e instanceof ServiceWorkerRegistration))
      throw nt.create("invalid-sw-registration");
    o.swRegistration = e;
  }
}
async function j_(o, e) {
  e ? (o.vapidKey = e) : o.vapidKey || (o.vapidKey = bk);
}
async function Ik(o, e) {
  if (!navigator) throw nt.create("only-available-in-window");
  if (
    (Notification.permission === "default" &&
      (await Notification.requestPermission()),
    Notification.permission !== "granted")
  )
    throw nt.create("permission-blocked");
  return (
    await j_(o, e?.vapidKey), await O_(o, e?.serviceWorkerRegistration), B_(o)
  );
}
async function N_(o, e, t) {
  let r = L_(e);
  (await o.firebaseDependencies.analyticsProvider.get()).logEvent(r, {
    message_id: t[gk],
    message_name: t[y_],
    message_time: t[b_],
    message_device_time: Math.floor(Date.now() / 1e3),
  });
}
function L_(o) {
  switch (o) {
    case vs.NOTIFICATION_CLICKED:
      return "notification_open";
    case vs.PUSH_RECEIVED:
      return "notification_foreground";
    default:
      throw new Error();
  }
}
async function G_(o, e) {
  let t = e.data;
  if (!t.isFirebaseMessaging) return;
  o.onMessageHandler &&
    t.messageType === vs.PUSH_RECEIVED &&
    (typeof o.onMessageHandler == "function"
      ? o.onMessageHandler(mk(t))
      : o.onMessageHandler.next(mk(t)));
  let r = t.data;
  D_(r) && r[g_] === "1" && (await N_(o, t.messageType, r));
}
var hk = "@firebase/messaging",
  yk = "0.12.4";
var H_ = (o) => {
    let e = new gy(
      o.getProvider("app").getImmediate(),
      o.getProvider("installations-internal").getImmediate(),
      o.getProvider("analytics-internal")
    );
    return (
      navigator.serviceWorker.addEventListener("message", (t) => G_(e, t)), e
    );
  },
  V_ = (o) => {
    let e = o.getProvider("messaging").getImmediate();
    return { getToken: (r) => Ik(e, r) };
  };
function $_() {
  kr(new Ct("messaging", H_, "PUBLIC")),
    kr(new Ct("messaging-internal", V_, "PRIVATE")),
    Yt(hk, yk),
    Yt(hk, yk, "esm2017");
}
async function Ty() {
  try {
    await Wl();
  } catch {
    return !1;
  }
  return (
    typeof window < "u" &&
    xl() &&
    Iw() &&
    "serviceWorker" in navigator &&
    "PushManager" in window &&
    "Notification" in window &&
    "fetch" in window &&
    ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") &&
    PushSubscription.prototype.hasOwnProperty("getKey")
  );
}
async function K_(o) {
  if (!navigator) throw nt.create("only-available-in-window");
  return o.swRegistration || (await Tk(o)), wk(o);
}
function Ak(o = Qh()) {
  return (
    Ty().then(
      (e) => {
        if (!e) throw nt.create("unsupported-browser");
      },
      (e) => {
        throw nt.create("indexed-db-unsupported");
      }
    ),
    gs(Ul(o), "messaging").getImmediate()
  );
}
async function Pk(o, e) {
  return (o = Ul(o)), Ik(o, e);
}
function Rk(o) {
  return (o = Ul(o)), K_(o);
}
$_();
c();
var Ek = () =>
  navigator.serviceWorker.register(
    "/background/workers/firebase_messaging_worker/firebase_worker.js",
    { type: "module" }
  );
c();
var q_ = () =>
    new Promise((o, e) => {
      try {
        let t = !0,
          r =
            "validate-browser-context-for-indexeddb-analytics-module-sidekick",
          i = window.indexedDB.open(r);
        (i.onsuccess = () => {
          i.result.close(), t || window.indexedDB.deleteDatabase(r), o(!0);
        }),
          (i.onupgradeneeded = () => {
            t = !1;
          }),
          (i.onerror = () => {
            e(i.error);
          });
      } catch (t) {
        e(t);
      }
    }),
  z_ = async () => {
    try {
      return await q_(), { isOpenable: !0, error: null };
    } catch (o) {
      return { isOpenable: !1, error: o };
    }
  },
  Bk = async () => {
    l(
      new L("Browser does not support FCM", {
        extra: {
          window: typeof window < "u",
          navigator: typeof navigator < "u",
          serviceWorker: "serviceWorker" in navigator,
          PushManager: "PushManager" in window,
          Notification: "Notification" in window,
          fetch: "fetch" in window,
          showNotification:
            ServiceWorkerRegistration.prototype.hasOwnProperty(
              "showNotification"
            ),
          getKey: PushSubscription.prototype.hasOwnProperty("getKey"),
          indexedDB: typeof indexedDB == "object",
          indexedDBOpenable: await z_(),
          cookies: typeof navigator > "u" || !navigator.cookieEnabled,
        },
      })
    );
  };
var Q_ = xe(1),
  ql = class {
    constructor(e, t) {
      this.browserStorage = e;
      this.backendService = t;
      this.initListener(),
        document.readyState === "complete" ||
        document.readyState === "interactive"
          ? this.initWorker().catch(l)
          : window.addEventListener(
              "load",
              () => {
                this.initWorker().catch(l);
              },
              { once: !0 }
            );
    }
    logger = x.createInstance("firebase_notifications");
    subscriptions = new Set();
    emitter = new A();
    lastTokenErrorTime = 0;
    subscribe(e, t) {
      let r = { type: e, callback: t };
      return (
        this.subscriptions.add(r),
        () => {
          this.subscriptions.delete(r);
        }
      );
    }
    subscribeToInitializationError(e) {
      this.emitter.on("initalization-error", e);
    }
    async initWorker() {
      try {
        if (!(await Ty())) return await Bk();
        let t = this.getMessaging(),
          r = await Ek();
        return (
          await this.updateServiceWorker(r),
          await this.startMessagingSafely(t, r)
        );
      } catch (e) {
        return l(e), this.emitter.emit("initalization-error");
      }
    }
    getMessaging() {
      let e = {
          apiKey: me.FIREBASE_API_KEY,
          authDomain: me.FIREBASE_AUTH_DOMAIN,
          projectId: me.FIREBASE_PROJECT_ID,
          storageBucket: me.FIREBASE_STORAGE_BUCKET,
          messagingSenderId: me.FIREBASE_MESSAGING_SENDER_ID,
          appId: me.FIREBASE_APP_ID,
        },
        t = zh(e);
      return Ak(t);
    }
    async updateServiceWorker(e) {
      try {
        await e.update();
      } catch {
        try {
          await (
            await navigator.serviceWorker.getRegistration(e.scope)
          )?.update();
        } catch (t) {
          l(t);
        }
      }
    }
    async startMessagingSafely(e, t) {
      if (!(await this.waitForSucceededWorkerActivation(t))) {
        l(new L("Failed to activate service worker"));
        return;
      }
      try {
        await this.startMessaging(e, t);
      } catch (i) {
        this.handleMessagingErrors(e, t, i);
      }
    }
    async startMessaging(e, t) {
      let r = await Pk(e, {
        vapidKey: me.FIREBASE_VAPID_KEY,
        serviceWorkerRegistration: t,
      });
      if (!r) {
        l(new L("Have not token for firebase, but must have"));
        return;
      }
      if ((await this.browserStorage.getItem("notifications-token")) === r) {
        this.logger.info("Success worker initialize: ", r);
        return;
      }
      await this.browserStorage.setItem("notifications-token", r),
        this.backendService.extension.postNotificationsToken(r).catch(l),
        this.logger.info("Token updated in storage and backend: ", r);
    }
    handleMessagingErrors(e, t, r) {
      if (!(r instanceof Bt)) throw r;
      switch (r.code) {
        case "installations/app-offline":
          return this.waitAndRestartWhenOnline(e, t);
        case "messaging/token-update-failed":
          return navigator.onLine
            ? this.handleTokenResetAndRestartSafely(e, t, r)
            : this.waitAndRestartWhenOnline(e, t);
        case "messaging/token-subscribe-failed":
          return this.handleTokenResetAndRestartSafely(e, t, r);
        default:
          throw r;
      }
    }
    waitAndRestartWhenOnline(e, t) {
      this.logger.info("Offline error. Setup restart when became online."),
        window.addEventListener(
          "online",
          () => {
            this.startMessagingSafely(e, t).catch(l);
          },
          { once: !0 }
        );
    }
    async waitForSucceededWorkerActivation(e) {
      if (e.active) return Promise.resolve(!0);
      let t = e.installing ?? e.waiting;
      return t
        ? new Promise((r) => {
            let i = (s) => {
              let { target: a } = s;
              !a ||
                !(a?.state === "activated") ||
                (t.removeEventListener("statechange", i), r(!0));
            };
            t.addEventListener("statechange", i);
          })
        : Promise.resolve(!1);
    }
    handleTokenResetAndRestartSafely(e, t, r) {
      let i = Date.now();
      if (i - this.lastTokenErrorTime <= Q_) throw r;
      (this.lastTokenErrorTime = i), this.resetTokenAndRestart(e, t).catch(l);
    }
    async resetTokenAndRestart(e, t) {
      return (
        await Rk(e),
        await this.browserStorage.removeItem("notifications-token"),
        this.startMessagingSafely(e, t)
      );
    }
    initListener() {
      let e = new BroadcastChannel(hb);
      e.onmessage = (t) => this.processMessage(t.data);
    }
    isFirebaseMessage(e) {
      return Ge(e) && oe(e, "title") && oe(e, "body");
    }
    processMessage(e) {
      this.isFirebaseMessage(e) &&
        (this.logger.info("New notification: ", e),
        this.subscriptions.forEach((t) => {
          t.type === e.title && ee(t.callback(e.body));
        }));
    }
  };
c();
var Y_ = [
    "activated_app_on_launchpad",
    "activated_app_on_sidebar",
    "activated_session",
    "added_app_through_plus_icon_on_sidebar",
    "added_second_account",
    "created_session",
    "opened_app_specific_search",
    "opened_tab_switcher",
    "performed_global_search",
  ],
  zl = class {
    constructor(e, t, r, i) {
      this.exploredFeaturesService = e;
      this.featureFlagsRepository = t;
      this.browserStorage = r;
      this.actualUsageDaysRepository = i;
      this.init().catch(l);
    }
    data = null;
    emitter = new A();
    async init() {
      (this.data =
        (await this.browserStorage.getItem("pmf-survey-banner")) ?? {}),
        this.emitter.emit("data-updated");
    }
    setDataAsExplored() {
      this.setData({ explored: !0 });
    }
    setDataAsIgnored() {
      let e = this.data?.ignoredNumberOfTimes ?? 0,
        t = this.actualUsageDaysRepository.getCount();
      g(t !== void 0, "actualUsageDays must be type of number"),
        this.setData({ lastIgnoredAtDay: t, ignoredNumberOfTimes: e + 1 });
    }
    setData(e) {
      (this.data = e),
        this.browserStorage.setItem("pmf-survey-banner", this.data).catch(l),
        this.emitter.emit("data-updated");
    }
    onDataUpdated(e) {
      return this.emitter.on("data-updated", e);
    }
    shouldBeVisible() {
      if (
        !this.featureFlagsRepository.getFeatureFlags().pmfSurveyEnabled ||
        this.data === null ||
        this.data.explored
      )
        return !1;
      let e = this.featureFlagsRepository.getFeatureFlags().pmfSurvey;
      if (!e.surveyUrl) return !1;
      let t = this.actualUsageDaysRepository.getCount() ?? 0;
      return t <= 7 || !this.getAreFeaturesForPmfSurveyExplored()
        ? !1
        : this.data.lastIgnoredAtDay
        ? (this.data.ignoredNumberOfTimes ?? 0) < e.maxTimesToShow &&
          t - this.data.lastIgnoredAtDay >= e.showEveryDays
        : !0;
    }
    getAreFeaturesForPmfSurveyExplored() {
      let e = 0;
      return Y_.some((t) =>
        this.exploredFeaturesService.getIsFeatureExplored(t)
          ? ((e += 1), e > 1)
          : !1
      );
    }
  };
c();
var Ql = { silent: !0 };
var Yl = class {
  constructor(e, t, r) {
    this.browserService = e;
    this.browserEventsService = t;
    this.userSettingsRepository = r;
    this.browserEventsService.subscribeToPopupClosed((i, s, a) => {
      if (!a) return;
      this.tryRemoveRecentlyClosed(i, s);
      let n = this.popupsByWindowId[i];
      n?.[s] && delete n[s], this.emitter.emit("changed", i);
    });
  }
  popupsByWindowId = {};
  recentlyClosedPopups = {};
  emitter = new A();
  prevApplicationPopupInfo;
  setLastActivatedAppPopupInfo(e) {
    this.prevApplicationPopupInfo = { ...e };
  }
  getLastActivatedAppPopupInfo(e) {
    let t = this.prevApplicationPopupInfo;
    return !t || t.appId !== e ? {} : t.position;
  }
  getPopupInfo(e, t) {
    return this.popupsByWindowId[e]?.[t];
  }
  getVisiblePopupIds(e) {
    return Object.keys(this.popupsByWindowId[e] ?? {});
  }
  subscribeToPopupChanged(e) {
    return this.emitter.on("changed", e);
  }
  subscribeToLaunchpadPopup(e) {
    return this.emitter.on("launchpad-popup", e);
  }
  async showLaunchpadPopup(e) {
    let t,
      r,
      i = (p, d, u = !0) => {
        if (
          (d(),
          g(p, "Tab id must be type of number to request launchpad popup"),
          !u)
        ) {
          this.emitter.emit("launchpad-popup", p, e);
          return;
        }
        setTimeout(() => {
          this.emitter.emit("launchpad-popup", p, e);
        }, 250);
      },
      s = this.browserEventsService.subscribeToTabActivated((p) => {
        (r = p.tabId), r === t && i(r, s);
      }),
      { isFocus: a, tabId: n } = await this.browserService.openHomeTab();
    if (((t = n), a)) {
      i(t, s, !1);
      return;
    }
    r === t && i(r, s);
  }
  showHintsStackPopupInWindowIfNotExists(e, t) {
    let r = "hints-stack";
    if (this.getPopupInfo(e, r)?.id === r) return;
    let s = this.getPosition(12, -12, { windowRelativeAnchor: Ve.LEFT_BOTTOM });
    this.showPopup({
      info: { id: r, position: s, payload: { appId: t } },
      windowId: e,
      keepOpen: !0,
      ignoreSidebarSize: !1,
      shouldFocusOnShow: !1,
    });
  }
  hideHintsStackPopupInWindow(e) {
    return this.hidePopup(e, "hints-stack");
  }
  showNotificationsStackPopup(e, t) {
    let r = "notification-stack",
      i = this.getPosition(-16, 12, { windowRelativeAnchor: Ve.RIGHT_TOP });
    e.forEach((s) => {
      let a = Number(s);
      this.getPopupInfo(a, r) ||
        this.showPopup({
          info: { id: r, position: i },
          windowId: a,
          keepOpen: !0,
          ignoreSidebarSize: !0,
          shouldFocusOnShow: t.shouldFocusOnShow,
        });
    });
  }
  async hideNotificationsStackPopup() {
    let e = await this.browserService.getNormalWindowsById(),
      t = "notification-stack";
    Object.values(e).forEach((r) => {
      r.id && this.hidePopup(r.id, t);
    });
  }
  toggleApplicationPopup(e, t, r) {
    let i = this.getPopupInfo(e, "application");
    if (i?.id === "application" && i.payload.appId === t && i.position !== Ql) {
      this.hidePopup(e, "application");
      return;
    }
    this.showPopup({
      info: { id: "application", position: r, payload: { appId: t } },
      windowId: e,
      insertedCode: `globalThis.appId='${t}';`,
    });
  }
  async showApplicationPopup(e, t) {
    let r = await this.browserService.getLastFocusedWindowId();
    r &&
      this.showPopup({
        info: {
          id: "application",
          position: t,
          payload: { appId: e, settingsView: t.settingsView },
        },
        windowId: r,
        insertedCode: `globalThis.appId='${e}';`,
      });
  }
  showUserNotificationsSettingsPopup(e) {
    return this.showPopup({
      info: {
        id: "notifications-settings",
        position: this.getPosition(0, 0, {
          windowRelativeAnchor: Ve.LEFT_BOTTOM,
        }),
      },
      windowId: e,
      keepOpen: !1,
    });
  }
  hideUserNotificationsSettingsPopup(e) {
    return this.hidePopup(e, "notifications-settings");
  }
  async toggleWalkthroughPopup(e, t) {
    let r = await this.browserService.getLastFocusedWindowId();
    if (!r) return;
    let i = this.getPopupInfo(r, "walkthrough");
    (i &&
      (this.hidePopup(r, "walkthrough"),
      i.id === "walkthrough" &&
        i.payload.step === e.step &&
        i.payload.context === e.context)) ||
      this.showPopup({
        info: { id: "walkthrough", position: t, payload: e },
        windowId: r,
        keepOpen: !0,
      });
  }
  async toggleCpuMonitorNotificationPopup(e) {
    let t = await this.browserService.getLastFocusedWindowId();
    if (!t) return;
    let r = this.getPopupInfo(t, "cpu-monitor-notification");
    if (
      r?.id === "cpu-monitor-notification" &&
      e.hostname === r.payload.hostname
    ) {
      this.hidePopup(t, "cpu-monitor-notification");
      return;
    }
    this.showPopup({
      info: {
        id: "cpu-monitor-notification",
        position: this.getPosition(16, -16, {
          windowRelativeAnchor: Ve.LEFT_BOTTOM,
        }),
        payload: e,
      },
      windowId: t,
      keepOpen: !0,
    });
  }
  async showApplicationPopupSilently(e) {
    let t = await this.browserService.getLastFocusedWindowId();
    t &&
      this.showPopupSilently(
        { id: "application", position: Ql, payload: { appId: e } },
        t
      );
  }
  async showQuickSessionSwitcherPopup(e, t) {
    let r = t ?? (await this.browserService.getLastFocusedWindowId());
    r &&
      this.showPopup({
        info: {
          id: "quick-session-switcher",
          position: this.getPosition(6, -16, {
            windowRelativeAnchor: Ve.LEFT_BOTTOM,
          }),
          payload: e,
        },
        windowId: r,
      });
  }
  async showTabContextMenuPopup(e, t, r, i) {
    let s = i ?? (await this.browserService.getLastFocusedWindowId());
    s &&
      this.showPopup({
        info: {
          id: "vertical-tab-context-menu",
          position: this.getPosition(e.x, e.y, {
            windowRelativeAnchor: Ve.LEFT_TOP,
          }),
          payload: t,
        },
        keepOpen: !1,
        ignoreSidebarSize: r,
        windowId: s,
      });
  }
  async showTabGroupContextMenuPopup(e, t, r, i) {
    let s = i ?? (await this.browserService.getLastFocusedWindowId());
    s &&
      this.showPopup({
        info: {
          id: "vertical-tab-group-context-menu",
          position: this.getPosition(e.x, e.y, {
            windowRelativeAnchor: Ve.LEFT_TOP,
          }),
          payload: t,
        },
        keepOpen: !1,
        ignoreSidebarSize: r,
        windowId: s,
      });
  }
  showAdblockPopupIfIsNotVisible(e, t) {
    if (this.getPopupInfo(t, "adblock-popup")?.id === "adblock-popup") {
      this.hidePopup(t, "adblock-popup");
      return;
    }
    this.showPopup({
      info: {
        id: "adblock-popup",
        position: this.getPosition(-300, 24, {
          toolbarButtonAnchor: "adBlockIcon",
        }),
        payload: e,
      },
      insertedCodeAfterClose: `globalThis.chrome.sidekick.adBlock.onAdBlockPopupClosed(${t}, () => {})`,
      windowId: t,
    });
  }
  hideQuickSessionSwitcherPopup(e) {
    return this.hidePopup(e, "quick-session-switcher");
  }
  hideVerticalTabContextMenuPopup(e) {
    return this.hidePopup(e, "vertical-tab-context-menu");
  }
  hideVerticalTabGroupContextMenuPopup(e) {
    return this.hidePopup(e, "vertical-tab-group-context-menu");
  }
  hidePopup(e, t, r = !1) {
    let i = this.getPopupInfo(e, t);
    if (i) {
      if (i.position !== Ql) {
        if (r) return;
        this.browserService.hidePopup(e, t);
      }
      this.tryRemoveRecentlyClosed(e, t), this.deletePopup(e, t);
    }
  }
  setPopup(e, t) {
    this.popupsByWindowId[e] === void 0 && (this.popupsByWindowId[e] = {});
    let r = this.popupsByWindowId[e];
    g(r, "No popupsById to mutate for window id", { windowId: e }),
      (r[t.id] = t),
      this.emitter.emit("changed", e);
  }
  deletePopup(e, t) {
    let r = this.popupsByWindowId[e];
    r !== void 0 && (delete r[t], this.emitter.emit("changed", e));
  }
  showPopupSilently(e, t) {
    g(e.position === Ql, "Position must be silent to show popup silently");
    let r = this.getPopupInfo(t, e.id);
    r && this.browserService.hidePopup(t, r.id), this.setPopup(t, { ...e });
  }
  showPopup({
    info: e,
    windowId: t,
    insertedCode: r,
    insertedCodeAfterClose: i,
    keepOpen: s,
    ignoreSidebarSize: a,
    shouldFocusOnShow: n = !1,
  }) {
    let p = this.getPopupInfo(t, e.id);
    p &&
      ((this.recentlyClosedPopups[t] = (
        this.recentlyClosedPopups[t] ?? new Set()
      )?.add(p.id)),
      this.browserService.hidePopup(t, p.id)),
      this.setPopup(t, e),
      this.browserService.showPopup(
        t,
        e.id,
        this.composeChromePosition(e.position, a),
        r,
        i,
        s,
        e || p
      ),
      n && this.browserService.focusWindow(t).catch(fe);
  }
  composeChromePosition(e, t) {
    let { sidebarSize: r } = this.userSettingsRepository.getSettings();
    return this.getPosition(
      t ? Math.floor(e?.x ?? 0) : Math.floor(e?.x ?? 0) + Hi(r),
      Math.floor(e?.y ?? 0),
      e?.anchor ?? { windowRelativeAnchor: Ve.LEFT_TOP }
    );
  }
  tryRemoveRecentlyClosed(e, t) {
    return this.recentlyClosedPopups[e]?.has(t)
      ? (this.recentlyClosedPopups[e]?.delete(t), !0)
      : !1;
  }
  getPosition(e, t, r) {
    return { x: e, y: t, anchor: r };
  }
};
c();
var Xl = class {
  constructor(e, t) {
    this.popupService = e;
    t.subscribeToWindowRemoved((r) => {
      this.clearHintsByWindow(r);
    });
  }
  hintsByWindowId = {};
  emitter = new A();
  onHintsChanged(e) {
    return this.emitter.on("changed", e);
  }
  getPopupInfo(e, t) {
    return this.popupService.getPopupInfo(e, t);
  }
  getHintsForWindow(e) {
    return this.hintsByWindowId[e];
  }
  showHint(e, t, r) {
    this.hideHint(e, t, !1),
      this.popupService.showHintsStackPopupInWindowIfNotExists(e, r),
      this.hintsByWindowId[e] || (this.hintsByWindowId[e] = new Set()),
      this.hintsByWindowId[e]?.add(t),
      this.emitter.emit("changed", e);
  }
  hideHint(e, t, r = !0) {
    this.hintsByWindowId[e]?.has(t) &&
      (this.hintsByWindowId[e]?.delete(t),
      r && this.tryHideStackInWindow(e),
      this.emitter.emit("changed", e));
  }
  hideAllHintsById(e) {
    Object.keys(this.hintsByWindowId).forEach((t) => {
      this.hideHint(Number(t), e);
    });
  }
  tryHideStackInWindow(e) {
    this.hintsByWindowId[e]?.size ||
      (this.clearHintsByWindow(e),
      this.popupService.hideHintsStackPopupInWindow(e));
  }
  clearHintsByWindow(e) {
    delete this.hintsByWindowId[e];
  }
};
c();
var fi = "before-product-hunt-alarm",
  fs = "product-hunt-live-alarm";
var Jl = class {
  constructor(e, t, r, i, s) {
    this.featureFlagsRepository = e;
    this.browserStorage = t;
    this.browserService = r;
    this.browserEventsService = i;
    this.notificationsManager = s;
    this.browserEventsService.subscribeToAlarm((a) => {
      switch (a.name) {
        case fi:
          this.showNextPopup().catch(l);
          break;
        case fs:
          this.showLivePopup().catch(l);
          break;
        default:
      }
    }),
      this.featureFlagsRepository.onFeatureFlagsLoaded(() => {
        this.init().catch(l);
      }),
      this.browserEventsService.subscribeToIdleStateChanged((a) => {
        a === "active" && this.init().catch(l);
      }),
      this.init().catch(l);
  }
  currentPopup = 0;
  emitter = new A();
  getCurrentPopup() {
    return this.currentPopup;
  }
  disableBeforeLandingPopup() {
    this.saveStateToLS("beforePopup").catch(l),
      this.browserService.clearAlarmByName(fi).catch(l);
  }
  disableProductHuntLivePopup() {
    this.saveStateToLS("livePopup").catch(l),
      this.browserService.clearAlarmByName(fs).catch(l);
  }
  onStateChanged(e) {
    return this.emitter.on("changed", e);
  }
  closeProductHuntPopup() {
    (this.currentPopup = 0), this.emitter.emit("changed");
  }
  getProductHuntLink() {
    return this.featureFlagsRepository.getFeatureFlag("productHuntLivePopup")
      .productHuntLink;
  }
  async init() {
    if (
      !(
        this.featureFlagsRepository.getFeatureFlag(
          "beforeProductHuntPopupEnabled"
        ) ||
        this.featureFlagsRepository.getFeatureFlag(
          "productHuntPopupLiveEnabled"
        )
      )
    ) {
      this.browserService.clearAlarmByName(fi).catch(l),
        this.browserService.clearAlarmByName(fs).catch(l);
      return;
    }
    let t = await this.loadStateFromLS();
    this.tryScheduleBeforePopup(t), await this.tryShowLiveNotification(t);
  }
  tryScheduleBeforePopup(e) {
    let t = Date.now(),
      r = wb(t),
      i = kb(t),
      s = this.featureFlagsRepository.getFeatureFlag(
        "beforeProductHuntPopup"
      ).date,
      a = s.month - 1,
      n = s.year || Ou(t);
    if (i !== a || r > s.day + 3) {
      this.browserService.clearAlarmByName(fi).catch(l);
      return;
    }
    if (e === void 0) {
      let p = qr(new Date(n, a, s.day, s.hour, s.minutes, 0, 0));
      this.browserService.createAlarm(fi, { when: Math.max(t, p) });
    } else if (e === "beforeNotification") {
      let p = qr(new Date(n, a, s.day, s.hour + 4, s.minutes, 0, 0)),
        d = qr(ta(Js(p, 2)));
      t > p && t < d
        ? ((this.currentPopup = 1),
          this.emitter.emit("changed"),
          this.saveStateToLS("beforePopup").catch(l),
          this.browserService.clearAlarmByName(fi).catch(l))
        : this.browserService.createAlarm(fi, { when: p });
    }
  }
  async tryShowLiveNotification(e) {
    if (
      !this.featureFlagsRepository.getFeatureFlag("productHuntPopupLiveEnabled")
    )
      return;
    let r = await this.loadDateFromLS(),
      i = r ? new Date(r) : void 0;
    if (
      (i ||
        (this.notificationsManager.showProductHuntLiveNotification(),
        this.saveStateToLS("liveNotification").catch(l),
        (i = new Date()),
        await this.saveDateToLS(i.getTime())),
      e !== "livePopup")
    ) {
      let s = qr(Du(i, 12)),
        a = Date.now();
      if (a > Du(i, 4).getTime() && a < s) {
        (this.currentPopup = 2),
          this.emitter.emit("changed"),
          await this.saveStateToLS("livePopup"),
          this.browserService.clearAlarmByName(fs).catch(l);
        return;
      }
      let n = qr(
        new Date(
          i.getFullYear(),
          i.getMonth(),
          i.getDate(),
          i.getHours() + 4,
          i.getMinutes(),
          0,
          0
        )
      );
      this.browserService.createAlarm(fs, { when: n });
    }
  }
  showLivePopup() {
    return (
      (this.currentPopup = 2),
      this.emitter.emit("changed"),
      this.saveStateToLS("livePopup")
    );
  }
  loadStateFromLS() {
    return this.browserStorage.getItem("product-hunt-state");
  }
  saveStateToLS(e) {
    return this.browserStorage.setItem("product-hunt-state", e);
  }
  loadDateFromLS() {
    return this.browserStorage.getItem("product-hunt-date");
  }
  saveDateToLS(e) {
    return this.browserStorage.setItem("product-hunt-date", e);
  }
  async showNextPopup() {
    let e = await this.loadStateFromLS(),
      t = null,
      r = Date.now(),
      i = this.featureFlagsRepository.getFeatureFlag(
        "beforeProductHuntPopup"
      ).date,
      s = i.month - 1,
      a = qr(new Date(i.year || Ou(r), s, i.day, i.hour + 1, i.minutes, 0, 0));
    switch (e) {
      case void 0: {
        r < a && this.notificationsManager.showBeforeProductHuntNotification(),
          (t = "beforeNotification");
        break;
      }
      case "beforeNotification": {
        (this.currentPopup = 1),
          this.emitter.emit("changed"),
          (t = "beforePopup");
        break;
      }
      default:
    }
    return t && (await this.saveStateToLS(t)), this.init();
  }
};
c();
var Iy = /(?<username>[^/]+):(?<password>[^/]+)@/,
  X_ = /:\d+$/,
  J_ = (o) => (X_.test(o) ? o : `${o}:443`),
  Ck = (o) => o.replace(/^.*:\/\//, ""),
  Z_ = (o) => J_(Ck(o).replace(Iy, "")),
  eF = (o) => {
    let e = Iy.exec(Ck(o));
    if (e?.groups)
      return {
        username: e.groups.username ?? "",
        password: e.groups.password ?? "",
        url: o.replace(Iy, ""),
      };
  },
  tF = (o) => {
    if (!o.includes("://")) return "HTTPS";
    let e = o.split("://", 1)[0].toUpperCase();
    return e === "HTTP" ? "PROXY" : e;
  },
  rF = (o, e) => {
    let t = o.servers.map((i) => `${tF(i)} ${Z_(i)}`),
      r = e.filter((i) => i.enabled).flatMap((i) => i.domains);
    return `
      function FindProxyForURL(url, host) {
        const domains = ${JSON.stringify(r)}
        const domainInList = domains.find((domain) => {
          return host.endsWith(domain)
        })

        if (domainInList) {
          return '${t.join("; ")}; DIRECT'
        }

        return 'DIRECT'
      }
    `;
  },
  Zl = class {
    constructor(e, t, r) {
      this.featureFlagsRepository = e;
      this.userSettingsRepository = t;
      this.browserService = r;
      this.loadProxy(),
        W.onSeveral(Ce, () => {
          this.loadProxy();
        });
    }
    proxySites = [];
    loadProxy() {
      let e = this.featureFlagsRepository.getFeatureFlags().proxy,
        { selectedProxySites: t, useProxy: r } =
          this.userSettingsRepository.getSettings();
      this.proxySites = this.getCollectionSites(e, t ?? []);
      let i = this.proxySites.some((s) => s.enabled);
      r && i
        ? (this.setProxyConfig(e, this.proxySites ?? []),
          this.setProxyCredentials(e).catch(l))
        : this.clearProxyConfig();
    }
    getCollectionSites(e, t) {
      return Object.entries(e.domains).map(([r, i]) => ({
        id: r,
        name: r,
        domains: i,
        enabled: t.includes(r),
      }));
    }
    getProxySites() {
      return this.proxySites;
    }
    async setProxyCredentials(e) {
      await Promise.all(
        e.servers.map(async (t) => {
          let r = eF(t);
          r && (await this.browserService.setProxyCredentials(r));
        })
      );
    }
    setProxyConfig(e, t) {
      this.browserService.setProxyConfig({
        value: { mode: "pac_script", pacScript: { data: rF(e, t) } },
      });
    }
    clearProxyConfig() {
      this.browserService.clearProxyConfig();
    }
  };
c();
var _k = { IndexChanged: "index-changed" },
  ed = class {
    constructor(e, t, r, i) {
      this.sessionApi = e;
      this.sessionRepository = t;
      this.workspaceRepository = r;
      this.billingApi = i;
      this.currentIndex = 0;
    }
    currentIndex;
    emitter = new A();
    onIndexChanged(e) {
      return this.emitter.on(_k.IndexChanged, e);
    }
    getIndex() {
      return this.currentIndex;
    }
    getIndexedSession(e) {
      let t = this.getSessionsByLastUsedWithHeadCurrent(e);
      return t[Qt(this.currentIndex, t.length)];
    }
    getSessionsByLastUsedWithHeadCurrent(e) {
      let t = this.workspaceRepository.getWorkspaceIdForWindow(e);
      if (!t) return [];
      let r = this.sessionRepository.getSessionsByLastUsedByWorkspaceId(t),
        i = this.sessionRepository.getSessionByWindowId(e);
      if (!i) return r;
      let s = r.findIndex((a) => a.id === i.id);
      return r.splice(s, 1), [i, ...r];
    }
    async switchToCurrentIndexedSession(e) {
      let t = this.getSessionsByLastUsedWithHeadCurrent(e),
        r = Qt(this.currentIndex, t.length);
      if (
        this.billingApi.showLimitPopupIfBlocked(
          () => this.billingApi.canOpenSession(r),
          "popups.sessions-become-pro.quick-sessions-switcher-open"
        )
      )
        return;
      let s = this.getIndexedSession(e);
      if (!s?.id || this.sessionRepository.getSessionByWindowId(e)?.id === s.id)
        return;
      let n = this.sessionRepository.getWindowIdBySessionId(s.id);
      if (n && n !== e) {
        this.sessionApi.focusSessionWindow(n).catch(l);
        return;
      }
      await this.sessionApi.switchWindowSession(s?.id, e);
    }
    incrementCurrentIndex() {
      this.setIndex(this.currentIndex + 1);
    }
    resetCurrentIndex() {
      this.setIndex(0);
    }
    setIndex(e) {
      (this.currentIndex = e), this.emitter.emit(_k.IndexChanged);
    }
  };
c();
c();
var td = class {
  constructor(e, t) {
    this.id = e;
    this.task = t;
  }
  runEveryMinutes = 0;
  everyNthMinute(e) {
    return (
      g(e > 0, "It should be positive value"), (this.runEveryMinutes = e), this
    );
  }
  everyMinute() {
    return this.everyNthMinute(1);
  }
  everyFiveMinutes() {
    return this.everyNthMinute(5);
  }
  everyTenMinutes() {
    return this.everyNthMinute(10);
  }
  everyThirtyMinutes() {
    return this.everyNthMinute(30);
  }
  hourly() {
    return this.everyNthHour(1);
  }
  everyNthHour(e) {
    return this.everyNthMinute(e * 60);
  }
  everyTwoHours() {
    return this.everyNthHour(2);
  }
  everySixHours() {
    return this.everyNthHour(6);
  }
  daily() {
    return this.everyNthDays(1);
  }
  everyNthDays(e) {
    return this.everyNthHour(24 * e);
  }
  weekly() {
    return this.everyNthMinute(10080);
  }
  isNeedRun(e, t) {
    return Boolean(this.runEveryMinutes && ur(e - t) > this.runEveryMinutes);
  }
  execute() {
    ee(this.task());
  }
};
var rd = class {
  constructor(e) {
    this.browserStorage = e;
    this.init().catch(l);
  }
  tasks = new Map();
  history = {};
  task(e, t) {
    let r = new td(e, t);
    return (
      g(
        !this.tasks.has(r.id),
        `Found duplicate of scheduled task with id: "${r.id}"`
      ),
      this.tasks.set(r.id, r),
      r
    );
  }
  taskSuicidal(e, t) {
    return this.task(e, () => {
      ee(t()), this.removeTask(e);
    });
  }
  hasTask(e) {
    return Boolean(this.tasks.get(e));
  }
  removeTask(e) {
    this.tasks.delete(e), delete this.history[e], this.saveHistory().catch(l);
  }
  async init() {
    (this.history = (await this.readHistory()) ?? {}),
      this.scheduleNextExecuting();
  }
  async readHistory() {
    return this.browserStorage.getItem("scheduler-history");
  }
  saveHistory() {
    return this.browserStorage.setItem("scheduler-history", this.history);
  }
  scheduleNextExecuting() {
    let e = Date.now();
    setTimeout(() => {
      this.tasks.forEach((t) => {
        let r = this.history[t.id] ?? 0;
        t.isNeedRun(e, r) && (t.execute(), (this.history[t.id] = e));
      }),
        this.saveHistory().catch(l),
        this.scheduleNextExecuting();
    }, ye(1));
  }
};
c();
c();
c();
c();
var iF = (o) => `[${o.join("")}]`,
  Mk = { "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&apos;", "&": "&amp;" },
  oF = Object.keys(Mk),
  sF = new RegExp(iF(oF), "g"),
  Fk = (o) => o.replace(sF, (e) => Mk[e] || ""),
  id = (o) => {
    switch (typeof o) {
      case "string":
        return Fk(o);
      case "number":
        return Fk(String(o));
      default:
        throw new TypeError(`Unexpected XML value type ${typeof o}`);
    }
  },
  aF = (o) => {
    if (!o.raw)
      throw new Error("Expected function to be called as a string tag");
  },
  xk = (o, ...e) => (
    aF(o), e.reduce((t, r, i) => [...t, id(r), o[i + 1]], [o[0]]).join("")
  );
var od = (o, e) => [o, Boolean(e)],
  nF = (o, e) =>
    !o || !e
      ? [od(o, !1)]
      : [
          od(o.slice(0, e.start), !1),
          od(o.slice(e.start, e.end), !0),
          od(o.slice(e.end), !1),
        ],
  cF = ([o, e]) => (o ? (e ? xk`<match>${o}</match>` : id(o)) : ""),
  pF = (o) => o.map(cF).join(""),
  Ay = (o, e) => pF(nF(o, e)),
  lF = (o) => {
    let e = Ay(o.title, o.match?.title ?? null),
      t = Ay(o.itemType, o.match?.itemType ?? null),
      r = e ? `${e}<dim> - ${t}</dim>` : `<dim>${t}</dim>`;
    if (o.match?.url) {
      let a = Ay(o.url, o.match?.url);
      r += ` - <url>${a}</url>`;
    }
    let i = id(o.title),
      s =
        "favIconUrl" in o && o.favIconUrl && !o.favIconUrl.endsWith(".svg")
          ? o.favIconUrl
          : "";
    return {
      content: o.url || i || "\u200A",
      description: r,
      image: s,
      favicon: o.url || "",
    };
  },
  Wk = (o) => o.map((e, t) => ({ sidekick_result_id: t, ...lF(e) }));
var dF = (o) => Gt(o) !== null,
  sd = class {
    constructor(e, t, r, i) {
      this.browserService = e;
      this.searchService = r;
      this.analyticsTracker = i;
      this.subscriptions.add(
        t.subscribeToOmniboxInputChanged(
          yt(async (s, a) => {
            Date.now() - this.queryResetAt < 100 ||
              ((this.searchResults = await this.search(
                s.replace("_aaaaaaasidekick", "")
              )),
              a(Wk(this.searchResults).slice()));
          }, 50)
        )
      ),
        this.subscriptions.add(
          t.subscribeToOmniboxInputEntered((s, a, n) => {
            (this.queryResetAt = Date.now()),
              !(n === void 0 || !Number.isInteger(n)) &&
                this.selectResult(s, n).catch(l);
          })
        );
    }
    queryResetAt = 0;
    searchResults = [];
    subscriptions = new Set();
    dispose() {
      this.subscriptions.forEach((e) => e()), this.subscriptions.clear();
    }
    async search(e) {
      let t = await this.browserService.getLastFocusedWindowId(),
        { result: r } = await this.searchService.searchGlobally({
          text: e,
          maxResults: 7,
          searchExternalSuggest: null,
          windowId: t,
          isOmnibox: !0,
        });
      return r;
    }
    selectResult(e, t) {
      let r = this.searchResults[t];
      return r?.url === e
        ? this.openSearchItem(r)
        : dF(e)
        ? this.openInCurrentTab(e)
        : e
        ? this.browserService.openSearchPage(e)
        : (l(
            new L("Empty `query` parameter in Omnibox has been detected.", {
              level: "warning",
              extra: { query: e, index: t },
            })
          ),
          Promise.resolve());
    }
    async openSearchItem(e) {
      this.analyticsTracker.sendAnalyticsEvent(
        "omnibox.search-suggestion-selected",
        { type: e.type }
      );
      let t = await this.browserService.getLastFocusedWindowId();
      t &&
        (await this.searchService.openSearchItem({
          item: e,
          source: "omnibox.search-suggestion-selected",
          openInActiveTab: !0,
          openInAppWithId: e.type === "service" ? e.serviceId : null,
          openInNewTab: !1,
          windowId: t,
        }));
    }
    async openInCurrentTab(e) {
      let t = await this.browserService.getActiveTab();
      t?.id &&
        (await this.browserService.updateTabById({
          tabId: t.id,
          changes: { url: e },
        }));
    }
  };
c();
c();
var ad = class {
  constructor(e, t, r, i, s, a, n) {
    this.gateway = e;
    this.applicationApi = t;
    this.applicationRepository = r;
    this.workspaceRepository = i;
    this.accountRepository = s;
    this.recipesRepository = a;
    this.runningApplicationsObserver = n;
    this.subscriptions = [
      D.onSeveral(
        [
          "apps-added",
          "apps-changed",
          "activation-statistic-updated",
          "apps-closed",
          "apps-activated",
        ],
        (p) => {
          let d = r.getAppById(p);
          d && this.publishApp(d);
        }
      ),
      D.on("apps-added", (p, d, u, m) => {
        m && this.removeAppById(m), this.publishApp(d);
      }),
      D.on("apps-added-after-onboarding", () => this.publishAllApps()),
      D.on("accounts-loaded", () => this.publishAllApps()),
      D.on("apps-removed", (p) => this.removeAppById(p)),
      D.on("activation-statistic-loaded", () => {
        this.isReady &&
          this.applicationRepository
            .getAllApps()
            .forEach((p) => this.publishApp(p));
      }),
    ];
  }
  subscriptions;
  isReady = !1;
  dispose() {
    this.subscriptions.forEach((e) => e()), (this.subscriptions.length = 0);
  }
  removeAppById(e) {
    this.gateway.actions.removeAppById(e);
  }
  publishApp(e) {
    let t = this.recipesRepository.getRecipeForApp(e),
      { startUrl: r, partition: i } =
        this.accountRepository.getCurrentAppAccount(e, t),
      s = this.workspaceRepository.getWorkspaceById(e.workspaceId);
    g(s, "Failed to publish app: no workspace found for app"),
      this.gateway.actions.upsertApp({
        id: e.id,
        url: r,
        partitionId: i,
        openedTabId: this.runningApplicationsObserver.getAppTabId(e.id),
        hostname: Vt(r),
        title: e.name,
        favIconUrl: e.customIconUrl || e.iconUrl || "",
        isRunning: this.runningApplicationsObserver.getIsRunningApp(e.id),
        workspaceId: s.id,
        visits: this.applicationApi.getActivationsByAppId(e.id),
      });
  }
  publishAllApps() {
    this.gateway.actions.clearAllApps(),
      this.applicationRepository
        .getAllApps()
        .forEach((e) => this.publishApp(e)),
      (this.isReady = !0);
  }
};
c();
var Dk = (o) => Boolean(o.url),
  nd = class {
    constructor(e, t, r) {
      this.gateway = e;
      this.browserService = t;
      this.browserEventsService = r;
    }
    async init() {
      return await this.initBookmarks(), this.subscribeBookmarksUpdates();
    }
    async initBookmarks() {
      let e = await this.browserService.getWholeBookmarks();
      await this.gateway.queries.initBookmarks(e.filter(Dk.bind(this)));
    }
    subscribeBookmarksUpdates() {
      let e = new Set([
        this.browserEventsService.subscribeToBookmarkCreated((t, r) => {
          Dk(r) && this.gateway.actions.addBookmark(r);
        }),
        this.browserEventsService.subscribeToBookmarkChanged((t, r) => {
          this.gateway.actions.updateBookmark(t, r);
        }),
        this.browserEventsService.subscribeToBookmarkRemoved(
          (t, { node: r }) => {
            this.removeBookmark(r);
          }
        ),
        this.browserEventsService.subscribeToBookmarksImportEnded(() => {
          this.initBookmarks().catch(l);
        }),
      ]);
      return () => {
        e.forEach((t) => t()), e.clear();
      };
    }
    removeBookmark({ id: e, children: t }) {
      t?.forEach((r) => this.removeBookmark(r)),
        this.gateway.actions.removeBookmark(e);
    }
  };
c();
var cd = class {
  constructor(e) {
    this.gateway = e;
  }
  emitter = new A();
  init() {
    return Promise.resolve(this.subscribeDomainStatistic());
  }
  onDomainsStatistic = (e) => this.emitter.on("update-domain-statistic", e);
  getUrlStatistic(e) {
    return this.gateway.queries.getUrlStatistic(e);
  }
  subscribeDomainStatistic() {
    let e = () => {
        this.gateway.queries
          .getDomainsStatistic()
          .then((r) => this.emitter.emit("update-domain-statistic", r))
          .catch(l);
      },
      t = setInterval(e, xe(1));
    return e(), () => clearInterval(t);
  }
};
c();
var uF = "history-index-optimize",
  Py = ce(30),
  pd = class {
    constructor(e, t, r, i, s, a, n) {
      this.gateway = e;
      this.browserService = t;
      this.browserStorage = r;
      this.browserEventsService = i;
      this.applicationRepository = s;
      this.accountRepository = a;
      this.scheduler = n;
    }
    emitter = new A();
    upsertQueue = new Set();
    async init() {
      await this.initHistory();
      let e;
      return (
        this.scheduler
          .task(uF, () => {
            e?.(),
              (e = this.browserEventsService.subscribeToIdleStateChanged(
                (t) => {
                  (t !== "idle" && t !== "locked") ||
                    (e?.(), this.gateway.actions.optimizeHistory());
                }
              ));
          })
          .daily(),
        this.subscribeHistoryUpdates()
      );
    }
    async refetchHistory() {
      this.gateway.actions.stopHistory(),
        this.emitter.emit("history-refresh"),
        await this.initHistory();
    }
    setModelForHistory(e) {
      this.gateway.actions.setModelForHistory(e);
    }
    upsertToHistory(e, t) {
      this.upsertQueue.add({ tabId: e, data: t, at: Date.now() }),
        this.flushUpsertQueue();
    }
    onHistoryRefresh = (e) => this.emitter.on("history-refresh", e);
    onFlagForHidingImportButtonInit = (e) =>
      this.emitter.on("flag-for-hiding-import-button-Init", e);
    subscribeTotalHistoryCount(e) {
      let t = () => {
        this.gateway.queries.getTotalHistoryCount().then(e).catch(l);
      };
      return t(), this.onHistoryRefresh(t);
    }
    async initHistory() {
      let e = await this.gateway.queries.getTotalHistoryCount(),
        t = Nb(e) ? await this.browserService.getWholeChromeHistory() : [];
      await this.setFlagForHidingImportButtonFromNtp(t),
        await this.gateway.queries.initHistory(t),
        this.gateway.actions.setRequestVisitsHandler(
          Hs(this.requestVisitsHandler.bind(this))
        );
    }
    subscribeHistoryUpdates() {
      let e = [
        this.browserEventsService.subscribeToImportEnded(() => {
          this.refetchHistory().catch(l);
        }),
        this.browserEventsService.subscribeToVisitRemoved(
          ({ allHistory: t, urls: r }) => {
            t || !r
              ? this.gateway.actions.clearAllHistory()
              : this.gateway.actions.removeUrlsFromHistory(r),
              this.emitter.emit("history-refresh");
          }
        ),
        this.browserEventsService.subscribeToPageVisited((t) => {
          let r = { ...this.composeHistoryRecord(t), visits: [Date.now()] };
          this.upsertToHistory(t.id, r);
        }),
        this.browserEventsService.subscribeToPageChanged((t) => {
          let r = this.composeHistoryRecord(t);
          this.upsertToHistory(t.id, r);
        }),
        this.browserEventsService.subscribeToFirstFocusLeave(
          ({ tab: t, visitAt: r, leaveAt: i }) => {
            let s = {
              ...this.composeHistoryRecord(t),
              attentionSpans: [i - r],
            };
            this.upsertToHistory(t.id, s);
          }
        ),
        this.browserEventsService.subscribeToWindowRemoved(
          (t, { hasShutdownStarted: r }) => {
            r && this.gateway.actions.saveBatchToIDBStore();
          }
        ),
        D.on("partition-cleared", (...t) => {
          this.gateway.actions.clearUnusedPartitionForAccount(...t);
        }),
        re.on("partition-cleared", (t) => {
          this.gateway.actions.clearUnusedPartitionForWorkspace(t);
        }),
      ];
      return F(e);
    }
    composeHistoryRecord(e) {
      g(e.url, "Tab url must be type of string to compose history record");
      let t = this.applicationRepository.getAppByTab(e),
        r = t ? this.accountRepository.getCurrentAppAccountId(t) : null;
      return {
        ...qy,
        url: e.url,
        partitionId: e.partitionName ?? "",
        accountId: r ?? "",
        title: e.title ?? null,
        favIconUrl: e.favIconUrl ?? null,
        visits: [],
      };
    }
    async setFlagForHidingImportButtonFromNtp(e) {
      if (
        (await this.browserStorage.getGlobalItem(
          "user-has-already-imported-history-and-bookmarks"
        )) !== void 0
      )
        return;
      let r = bb(e, "lastVisitTime")?.lastVisitTime;
      (e.length >= 3e3 || (r && Zs(new Date(), new Date(r)) >= 30)) &&
        (await this.browserStorage.setGlobalItem(
          "user-has-already-imported-history-and-bookmarks",
          !0
        ),
        this.emitter.emit("flag-for-hiding-import-button-Init", !0));
    }
    requestVisitsHandler(e, t) {
      this.browserService.getVisitsByUrls(e).then(t, l);
    }
    flushUpsertQueue = yt(
      () => {
        let e = Array.from(this.upsertQueue);
        this.upsertQueue.clear();
        let t = Date.now();
        e.forEach((r) => {
          if (r.at >= t - Py) {
            this.upsertQueue.add(r);
            return;
          }
          this.gateway.actions.upsertToHistory(r.data);
        }),
          this.upsertQueue.size && this.flushUpsertQueue();
      },
      Py,
      { maxWait: Py }
    );
  };
c();
var ld = class {
  constructor(e, t, r) {
    this.gateway = e;
    this.navigationScriptsRepository = t;
    this.navigationScriptsManager = r;
  }
  init() {
    let e = () => {
      this.setNavigationScripts(
        this.navigationScriptsRepository.getNavigationScripts()
      );
    };
    return e(), this.navigationScriptsRepository.onNavigationScriptsLoaded(e);
  }
  setNavigationScripts(e) {
    return (
      this.navigationScriptsManager.setNavigationScripts(e),
      this.gateway.actions.setNavigationScripts(e)
    );
  }
};
c();
var dd = class {
  constructor(e, t, r, i, s) {
    this.gateway = e;
    this.browserService = t;
    this.browserEventsService = r;
    this.extraDataService = i;
    this.workspaceRepository = s;
  }
  async init() {
    return await this.initOpenedTabs(), this.subscribeOpenedTabsUpdates();
  }
  async initOpenedTabs() {
    let e = await this.browserService.getAllTabs();
    await this.gateway.queries.initOpenedTabs(e.map((t) => this.getTabInfo(t)));
  }
  subscribeOpenedTabsUpdates() {
    let e = ["pendingUrl", "url", "favIconUrl", "title", "extraData"],
      t = ["id", "url", "partitionName", "windowId"],
      r = (u) => (u?.id && (u.pendingUrl || u.url) ? u : null),
      i = (u) => {
        let m = r(u);
        m &&
          this.gateway.actions.addOpenedTab(
            this.getTabInfo(Do(m, [...t, ...e]))
          );
      },
      s = async (u, m) => {
        let y = r(await this.browserService.getTabById(u));
        y &&
          this.gateway.actions.updateOpenedTab(
            this.getTabInfo({ ...Do(y, [...t, ...e]), ...Do(m, e) })
          );
      },
      a = async (u, m) => {
        let y = r(await this.browserService.getTabById(u));
        y &&
          this.gateway.actions.updateOpenedTab(
            this.getTabInfo({ ...Do(y, [...t, ...e]), windowId: m.windowId })
          );
      },
      n = (u) => this.gateway.actions.removeOpenedTab(u),
      p = async (u, m) => {
        n(m),
          await this.browserService.getTabById(u).then((y) => {
            y && i(y);
          });
      },
      d = new Set([
        this.browserEventsService.subscribeToTabCreated((u) => i(u)),
        this.browserEventsService.subscribeToTabUpdated((u, m) => {
          e.some((y) => oe(m, y)) && s(u, m).catch(l);
        }),
        this.browserEventsService.subscribeToTabRemoved((u) => n(u)),
        this.browserEventsService.subscribeToTabReplaced((u, m) => {
          p(u, m).catch(l);
        }),
        this.browserEventsService.subscribeToTabMoved((u, m) => {
          a(u, m).catch(l);
        }),
      ]);
    return () => {
      d.forEach((u) => u()), d.clear();
    };
  }
  getTabInfo(e) {
    let t = this.workspaceRepository.getWorkspaceForWindow(e.windowId)?.id,
      r = this.extraDataService.getTabExtraData(e)?.app;
    return {
      id: e.id || -1,
      url: e.pendingUrl || e.url || "",
      title: e.title || "",
      partitionId: e.partitionName || "",
      favIconUrl: e.favIconUrl || "",
      windowId: e.windowId,
      appId: r,
      workspaceId: t,
    };
  }
};
var ud = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m, y, b, v, S) {
    this.browserService = e;
    this.applicationApi = s;
    this.applicationRepository = a;
    this.workspaceRepository = n;
    this.recipesRepository = d;
    this.accountRepository = u;
    this.tabInfoFollowerService = m;
    this.runningApplicationsObserver = y;
    (this.gateway =
      S ??
      Rl({
        worker: new Worker(
          "/background/workers/search_worker/init_search_worker_gateway.js",
          { type: "module" }
        ),
      })),
      (this.history = new pd(this.gateway, e, t, r, a, u, v)),
      (this.bookmarks = new nd(this.gateway, e, r)),
      (this.openedTabs = new dd(this.gateway, e, r, b, n)),
      (this.apps = new ad(this.gateway, s, a, n, u, d, y)),
      (this.domainStatistic = new cd(this.gateway)),
      (this.navigationScripts = new ld(
        this.gateway,
        p,
        this.navigationScriptsManager
      ));
    let w = () => {
      this.setConfig(i.getFeatureFlags().search);
    };
    w(), i.onFeatureFlagsLoaded(w), this.init().catch(l);
  }
  gateway;
  history;
  bookmarks;
  openedTabs;
  apps;
  domainStatistic;
  navigationScripts;
  emitter = new A();
  subscriptions = new Set();
  isInitialized = !1;
  navigationScriptsManager = new ob();
  searchPromise = null;
  setConfig(e) {
    this.gateway.actions.setConfig(e);
  }
  dispose() {
    this.subscriptions.forEach((e) => e()),
      this.subscriptions.clear(),
      (this.isInitialized = !1);
  }
  searchInApp(e) {
    return this.search(e);
  }
  async searchGlobally(e) {
    let r =
        this.workspaceRepository.getWorkspaceForWindow(e.windowId)
          ?.partitionDomain ?? "",
      { searchExternalSuggest: i = await this.getSearchExternalSuggest() } = e;
    return this.search({ ...e, partitionId: r, searchExternalSuggest: i });
  }
  search(e) {
    this.searchPromise?.abort();
    let t = le(),
      r = this.getWorkspaceIdFromQuery(e);
    return (
      (this.searchPromise = new mb(
        () => this.gateway.queries.search(t, { ...e, workspaceId: r }),
        () => this.gateway.actions.cancelSearch(t)
      )),
      this.searchPromise
    );
  }
  async openSearchItem({
    item: e,
    source: t,
    windowId: r,
    openInAppWithId: i,
    openInActiveTab: s,
    openInNewTab: a,
  }) {
    let n = await this.browserService.getActiveTab(r),
      p = Boolean(s || (n?.url && this.browserService.isNTP(n.url)));
    if ((this.select({ id: e.id, type: e.type, source: t }), a)) {
      await this.browserService.createTab({
        url: e.url,
        partitionName: e.partitionId,
        active: p,
        windowId: r,
      }),
        p && n?.id && (await this.browserService.closeTab(n.id));
      return;
    }
    if (e.type === "service") {
      await this.applicationApi.activateApplication(e.serviceId, {
        keepInSplit: !0,
      });
      return;
    }
    if (i) {
      await this.applicationApi.activateApplication(i, {
        url: e.url,
        keepInSplit: !0,
      });
      return;
    }
    let d = oe(e, "openInAppWithRecipeId") ? e.openInAppWithRecipeId : null;
    if (d) {
      let y = this.workspaceRepository.getWorkspaceIdForWindow(r);
      if (!y) return;
      let b = this.recipesRepository.getRecipeByIdSafely(d),
        S = this.applicationRepository.getAllApps().filter((_) => {
          let O = this.accountRepository.getCurrentAppAccount(_, b),
            E = _.recipeId === b.id,
            f = e.partitionId === O.partition,
            j = !e.hostname || !b.hasCustomUrl || Vt(O.startUrl) === e.hostname;
          return E && f && j;
        }),
        w = await this.runningApplicationsObserver.getTabsByAppId(),
        T = (_) => {
          let O = w[_];
          return O?.id
            ? this.tabInfoFollowerService.getTabInfoById(O.id)
                ?.wasActivatedAt ?? 0
            : 0;
        },
        I = Mo(S, [
          (_) => -T(_.id),
          (_) => {
            let O = this.workspaceRepository.getPinnedIndexByAppId(y, _.id);
            return O !== -1 ? O : Number.MAX_SAFE_INTEGER;
          },
        ]),
        [k] = I;
      if (k) {
        await this.applicationApi.activateApplication(k.id, {
          url: e.url,
          keepInSplit: !0,
        });
        return;
      }
    }
    let m =
      s &&
      e.type !== "tab" &&
      !this.runningApplicationsObserver.getAppIdByTabId(n?.id)
        ? n
        : await this.getTabForReuse(e, r);
    m?.id
      ? await this.browserService.updateTabById({
          tabId: m.id,
          changes: dr({ url: m.url !== e.url ? e.url : null, active: !0 }),
        })
      : await this.browserService.createTab({
          url: e.url,
          partitionName: e.partitionId,
          active: !0,
        }),
      p &&
        n?.id &&
        n.id !== m?.id &&
        (await this.browserService.closeTab(n.id));
  }
  getTitleFromUrl(e) {
    return this.gateway.queries.getTitleFromUrl(e);
  }
  select({ id: e, type: t, source: r }) {
    this.gateway.actions.selectSearchItem(e),
      this.emitter.emit("select", { type: t, source: r });
  }
  onSelect(e) {
    return this.emitter.on("select", e);
  }
  async init() {
    if (this.isInitialized) return;
    this.isInitialized = !0;
    let e = await Promise.all([
      this.history.init(),
      this.bookmarks.init(),
      this.openedTabs.init(),
      this.domainStatistic.init(),
      this.navigationScripts.init(),
    ]);
    this.isInitialized
      ? e.forEach((t) => this.subscriptions.add(t))
      : e.forEach((t) => t());
  }
  async getTabForReuse(e, t) {
    let r = { partitionName: e.partitionId, hidden: !1, windowId: t },
      [i] = await this.browserService.getAllTabs({ ...r, url: e.url });
    if (i) return i;
    let s = await this.getTabWithSameTarget(e, t);
    if (s) return s;
    let a = await this.browserService.getActiveTabs(r),
      [n] = a.filter((p) => this.browserService.isReusableTab(p.url ?? ""));
    if (n) return n;
  }
  async getTabWithSameTarget(e, t) {
    let r = this.getTargetContainer(e.url, e.title);
    if (!r) return null;
    let i = zs(e.url);
    if (!i) return null;
    let s = await this.browserService.getAllTabs({
        partitionName: e.partitionId,
        url: i,
        windowId: t,
      }),
      a = null;
    return (
      s.some((n) =>
        this.getTargetContainer(n.url ?? "", n.title ?? "") !== r
          ? !1
          : ((a = n), n.hidden)
      ),
      a
    );
  }
  getTargetContainer(e, t) {
    let r = this.navigationScriptsManager.polishDocument({ url: e, title: t });
    return !r || r.excluded || r.targetContainer === "_blank"
      ? null
      : r.targetContainer;
  }
  getWorkspaceIdFromQuery(e) {
    if (!(!oe(e, "windowId") || typeof e.windowId != "number"))
      return this.workspaceRepository.getWorkspaceForWindow(e.windowId)?.id;
  }
  async getSearchExternalSuggest() {
    let {
      name: e,
      favicon: t,
      url: r,
    } = await this.browserService.getSearchEngine();
    return { name: e, favicon: t, url: r };
  }
};
c();
var Uk = "sidekick.search_button_on_window_head",
  md = class {
    constructor(e, t, r, i, s) {
      this.browserService = e;
      this.featureFlagsRepository = t;
      this.browserEventsService = r;
      this.analyticsTracker = i;
      this.modalService = s;
      this.browserEventsService.subscribeToGlobalSearchButtonPressed((a) => {
        this.handleClickInWindowHead(a);
      }),
        this.loadStateAndStartListeningFeatures();
    }
    loadStateAndStartListeningFeatures() {
      let e = this.getIsFeatureEnabled();
      this.setPref(e).catch(l),
        this.featureFlagsRepository.onFeatureFlagsLoaded(
          ({ enableSearchIconInToolbar: t }) => {
            this.setPref(t).catch(l);
          }
        );
    }
    getShouldShowSearchIconInSidebar() {
      return !this.getIsFeatureEnabled();
    }
    handleClickOnSidebar(e) {
      let t = "sidebar.global-search-button-clicked";
      this.analyticsTracker.sendAnalyticsEvent(t, void 0),
        this.toggleSearchModal(e, t).catch(l);
    }
    getIsFeatureEnabled() {
      return this.featureFlagsRepository.getFeatureFlag(
        "enableSearchIconInToolbar"
      );
    }
    handleClickInWindowHead(e) {
      let t = "browser.tabstrip.search-icon-clicked";
      this.analyticsTracker.sendAnalyticsEvent(t, void 0),
        this.toggleSearchModal(e, t).catch(l);
    }
    setPref(e) {
      return this.browserService.setPref(Uk, e);
    }
    async getPref() {
      let { value: e } = await this.browserService.getPref(Uk);
      return e;
    }
    toggleSearchModal(e, t) {
      return this.modalService.toggleGlobalSearchModal({ source: t }, e);
    }
  };
c();
var ho = class {
  constructor(e) {
    this.sentry = e;
    Ly(this.sentry);
  }
  static async build(e, t) {
    let [r, i] = await Lb.build(e, { ...t, keepalive: !0 });
    return [new ho(r), i];
  }
  subscribeToFeatureFlags(e) {
    let t = e.getFeatureFlag("sentrySampling");
    this.updateStoredConfig(t),
      e.onFeatureFlagsLoaded(({ sentrySampling: r }) =>
        this.updateSentryConfig(r)
      );
  }
  setBrowserVersion(e) {
    this.sentry.setBrowserVersion(e);
  }
  setOsInfo(e, t) {
    this.sentry.setOsInfo(e, t);
  }
  updateSentryConfig(e) {
    this.updateStoredConfig(e),
      de(e.tracesSampleRateBackground) &&
        this.sentry.setTracesSampleRateBackground(e.tracesSampleRateBackground),
      de(e.tracesSampleRateUI) &&
        this.sentry.setTracesSampleRateUI(e.tracesSampleRateUI),
      de(e.sampleRate) && this.sentry.setSampleRate(e.sampleRate),
      de(e.rules) && this.sentry.setRules(e.rules);
  }
  updateStoredConfig(e) {
    Bi("sentry-config", e);
  }
};
c();
c();
c();
var hd = {
    "Up Arrow": "\u2191",
    "Down Arrow": "\u2193",
    Comma: ",",
    "\u21E5": "Tab",
  },
  yd = {
    MacCtrl: "\u2303",
    Ctrl: "\u2318",
    Alt: "\u2325",
    Shift: "\u21E7",
    Backspace: "\u232B",
    Delete: "\u2326",
    Tab: "\u21E5",
  },
  Ry = (o) => new RegExp(`[${Object.values(o).join("")}]`, "gi"),
  mF = Ry(yd),
  Ey = (o) =>
    o
      .replace(mF, (e) => `${e}+`)
      .split("+")
      .map((e) => hd[e] || e)
      .filter(Boolean)
      .map((e) => e.trim()),
  hF = (o, e) => o.map((t) => (e && yd[t]) || t).map((t) => hd[t] || t),
  Ir = ({
    key: o,
    alt: e = !1,
    shift: t = !1,
    macCtrl: r = !1,
    ctrl: i = !1,
    isMac: s = !1,
  }) =>
    hF(
      (s
        ? [r && "MacCtrl", e && "Alt", t && "Shift", i && "Ctrl", o]
        : [(r || i) && "Ctrl", e && "Alt", t && "Shift", o]
      ).filter(mo),
      s
    ),
  Ok = (o) => Object.fromEntries(Object.entries(o).map(([e, t]) => [t, e])),
  jk = (o) => {
    let e = Ry(yd),
      t = Ok(yd),
      r = Ok(hd),
      i = Ry(hd);
    return o
      .join("+")
      .replace(e, (s) => t[s] || s)
      .replace(i, (s) => r[s] || s);
  };
var yo = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m, y, b, v, S, w, T) {
    this.systemInfoService = e;
    this.browserService = t;
    this.modalService = r;
    this.popupService = i;
    this.sidecarService = s;
    this.tabSwitcherService = a;
    this.splitViewService = n;
    this.quickSessionSwitcherService = p;
    this.applicationApi = d;
    this.featureFlagsRepository = u;
    this.analytics = m;
    this.browserEventsService = y;
    this.browserStorage = b;
    this.focusModeService = v;
    this.userSettingsRepository = S;
    this.sidebarVisibilityManager = w;
    this.notificationsSettingsApi = T;
    this.browserEventsService.subscribeToCommand((I, k) => {
      (this.wasCtrlTabCommand =
        this.prevCommandId === Y.SwitchTabCtrlTab ||
        this.prevCommandId === Y.SwitchTabCtrlShiftTab),
        (this.isRepeatedCommand = this.prevCommandId === I),
        (this.prevCommandId = I),
        (this.lastCommandTimestamp = Date.now());
      let _ = this.commandsById?.[I];
      switch (
        (_ &&
          (this.analytics.sendAnalyticsEvent("shortcut-used", {
            command: I,
            description: _.description,
            shortcut: _.shortcut,
          }),
          this.logger.info("Shortcut activated", _),
          this.emitter.emit("shortcut-used", _)),
        I)
      ) {
        case Y.SwitchTab:
          this.handleSwitchTabCommand(!1).catch(l);
          return;
        case Y.KeyUpSwitchTab:
          this.handleKeyUpSwitchTabCommand().catch(l);
          return;
        case Y.SwitchTabCtrlTab:
          this.handleSwitchTabCommand(!0).catch(l);
          break;
        case Y.SwitchTabCtrlShiftTab:
          this.handleSwitchTabCommand(!0, !0).catch(l),
            this.tabSwitcherService.tryOpenPreviousTab().catch(l);
          break;
        case Y.ToggleSessionsSidecar:
          s.toggleSessions({ source: "shortcut" }).catch(l);
          break;
        case Y.ToggleHelpSidecar:
          s.toggleHelp({ source: "shortcut" }).catch(l);
          break;
        case Y.GlobalSearch:
          r.toggleGlobalSearchModal({ source: "shortcut" }).catch(l);
          break;
        case Y.OpenSplitMenu:
          n.openSplitViewMenu();
          break;
        case Y.OpenLastSplitPanel:
          this.openLastSplitAppOrTab(k, k.windowId).catch(l);
          break;
        case Y.OpenCollectionsSidecar:
          this.handleToggleCollectionsOrTasks(k.windowId).catch(l);
          break;
        case Y.ShowSessions:
          if ((p.incrementCurrentIndex(), this.isRepeatedCommand)) return;
          i.showQuickSessionSwitcherPopup({ source: "shortcut" }).catch(l);
          break;
        case Y.KeyUpShowSessions:
          this.handleKeyUpShowSession().catch(l);
          break;
        case Y.ToggleWindowFocusMode:
          this.handleToggleWindowFocusMode();
          break;
        case Y.ToggleSidebar:
          this.handleToggleSidebar().catch(l);
          break;
        case Y.PinVerticalTabsSidecar:
          this.sidecarService.togglePinSidecar(k.windowId);
          break;
        case Y.ActivateService1:
        case Y.ActivateService2:
        case Y.ActivateService3:
        case Y.ActivateService4:
        case Y.ActivateService5:
        case Y.ActivateService6:
        case Y.ActivateService7:
        case Y.ActivateService8:
        case Y.ActivateService9: {
          let O = Number(I.slice(-1)) - 1;
          d.activatePinnedApplication(O).catch(l);
          break;
        }
        default:
          break;
      }
    }),
      this.browserEventsService.subscribeToShortcutsUpdated((I) =>
        this.handleShortcutsUpdated(I)
      ),
      this.featureFlagsRepository.onFeatureFlagsLoaded(() => {
        this.overrideShortcutsSafe().catch(l);
      }),
      this.overrideShortcutsSafe().catch(l);
  }
  shortcuts;
  commandsById;
  prevCommandId;
  lastCommandTimestamp;
  isRepeatedCommand = !1;
  wasCtrlTabCommand = !1;
  emitter = new A();
  logger = x.createInstance("shortcuts");
  static async build(e, t, r, i, s, a, n, p, d, u, m, y, b, v, S, w, T) {
    let I = new yo(e, t, r, i, s, a, n, p, d, u, m, y, b, v, S, w, T);
    return await I.loadShortcuts(), I;
  }
  getShortcuts() {
    return g(this.shortcuts, "Shortcuts not found"), this.shortcuts;
  }
  getLastCommand() {
    return this.prevCommandId;
  }
  getLastCommandUsage() {
    return this.lastCommandTimestamp;
  }
  activateShortcutCommand(e) {
    switch (e) {
      case "enter-focus-mode":
        this.handleToggleWindowFocusMode();
        break;
      case "open-last-split-panel":
        this.applicationApi.activateApplicationInSplitPanel().catch(l);
        break;
      case "open-tab-switcher": {
        let { ctrlTabOrder: t } = this.userSettingsRepository.getSettings();
        this.handleSwitchTabCommand(t === "mru").catch(l);
        break;
      }
      case "open-sessions":
        this.sidecarService.toggleSessions({ source: "command" }).catch(l);
        break;
      case "open-current-app-as-tab":
        this.applicationApi.activateCurrentApplicationAsTab().catch(l);
        break;
      case "open-app-or-tab-in-split-view":
        this.applicationApi
          .activateCurrentApplicationInSplitView()
          .then((t) => {
            t || this.splitViewService.openSplitViewMenu();
          })
          .catch(l);
        break;
      case "close-app-or-tab":
        this.browserService
          .getActiveTab()
          .then((t) => {
            t?.id && this.browserService.closeTab(t?.id).catch(l);
          })
          .catch(l);
        break;
      default:
    }
  }
  async overrideShortcutsSafe() {
    let { version: e } =
        this.featureFlagsRepository.getFeatureFlags().overrideShortcuts,
      r = (await this.browserStorage.getItem("shortcuts-are-overridden"))
        ?.version;
    e && r && e > r && (await this.overrideShortcuts());
  }
  async overrideShortcuts() {
    let { locale: e } = this.systemInfoService,
      {
        all: t,
        byLocale: r,
        version: i,
      } = this.featureFlagsRepository.getFeatureFlags().overrideShortcuts,
      s = await this.browserService.loadAllCommands(),
      a = Object.values(s),
      n = this.objFindValueByKey(r, (u) => e.startsWith(u)),
      p = { version: i, locale: e, at: Date.now() };
    this.browserStorage.setItem("shortcuts-are-overridden", p).catch(l);
    let d = {
      ...this.overriddenShortcuts(a, t),
      ...(n ? this.overriddenShortcuts(a, n) : null),
    };
    this.analytics.sendAnalyticsEvent("system.shortcuts-are-overridden", {
      version: i,
      locale: e,
      "overridden-commands": d,
    });
  }
  getShortcutByCommand(e) {
    if (!this.shortcuts) return;
    let t = this.extractShortcutKeys(e);
    return Object.values(this.shortcuts).find(
      (r) => r.keys.toString() === t.toString()
    );
  }
  async loadShortcuts(e) {
    this.commandsById = e
      ? Object.fromEntries(
          e.map((i) => (i.name ? [i.name, i] : null)).filter(de)
        )
      : await this.browserService.loadAllCommands();
    let { isMac: t } = this.systemInfoService,
      { ctrlTabOrder: r } = this.userSettingsRepository.getSettings();
    (this.shortcuts = {
      help: {
        title: P("background_shortcuts__help_title"),
        keys: this.extractShortcutKeys(Y.ToggleHelpSidecar),
      },
      manageSession: {
        title: P("background_shortcuts__manage_sessions_title"),
        keys: this.extractShortcutKeys(Y.ToggleSessionsSidecar),
      },
      globalSearch: {
        title: P("background_shortcuts__global_search_title"),
        keys: this.extractShortcutKeys(Y.GlobalSearch),
      },
      switchSession: {
        title: P("background_shortcuts__switch_sessions_title"),
        keys: this.extractShortcutKeys(Y.ShowSessions),
      },
      browserCloseTab: {
        title: P("background_shortcuts__close_tab_title"),
        keys: Ir({ key: "W", ctrl: !0, isMac: t }),
      },
      browserCopy: {
        title: P("background_shortcuts__copy_title"),
        keys: Ir({ key: "C", ctrl: !0, isMac: t }),
      },
      openInSplitView: {
        title: P("background_shortcuts__open_in_split_view_title"),
        keys: Ir({ key: "Left-click", alt: !0, isMac: t }),
      },
      toggleLastSplitPanel: {
        title: P("background_shortcuts__open_last_split_view_title"),
        keys: this.extractShortcutKeys(Y.OpenLastSplitPanel),
      },
      openSplitMenu: {
        title: P("background_shortcuts__open_split_menu_title"),
        keys: this.extractShortcutKeys(Y.OpenSplitMenu),
      },
      toggleCollectionsSidecar: {
        title: P("background_shortcuts__open_collections_title"),
        keys: this.extractShortcutKeys(Y.OpenCollectionsSidecar),
      },
      pinVerticalTabsSidecar: {
        title: P("background_shortcuts__pin_vertical_tabs_title"),
        keys: this.extractShortcutKeys(Y.PinVerticalTabsSidecar),
      },
      toggleSidebar: {
        title: P("background_shortcuts__open_sidebar_title"),
        keys: this.extractShortcutKeys(Y.ToggleSidebar),
      },
      toggleMuteWithNotificationsPopup: {
        title: P("background_shortcuts__toggle_mute_title"),
        keys: Ir({ key: "Left-click", alt: !0, isMac: t }),
      },
      appContextPopup: {
        title: P("background_shortcuts__open_app_popup_title"),
        keys: ["Right", "Click"],
      },
      closeOpenedTab: {
        title: P("background_shortcuts__close_opened_tab_title"),
        keys: Ir({ key: "Backspace", alt: !0, isMac: t }),
      },
      createNewTab: {
        title: P("background_shortcuts__create_tab_title"),
        keys: Ir({ key: "T", ctrl: !0, isMac: t }),
      },
      switchTab: {
        title: P("background_shortcuts__switch_tab_title"),
        keys: this.extractShortcutKeys(
          r === "appearance" ? Y.SwitchTab : Y.SwitchTabCtrlTab
        ),
      },
      switchFocusMode: {
        title: P("background_shortcuts__enter_focus_mode"),
        keys: this.extractShortcutKeys(Y.ToggleWindowFocusMode),
      },
      appAsTab: {
        title: P("background_shortcuts__open_tab_as_tab"),
        keys: Ir({ key: "Left-Click", ctrl: !0, isMac: t }),
      },
      activateServiceRange: {
        title: P("background_shortcuts__open_apps"),
        keys: Ir({ key: "1-9", alt: !0, isMac: t }),
      },
      activateService1: {
        title: `${P("background_shortcuts__activate_service")} 1`,
        keys: this.extractShortcutKeys(Y.ActivateService1),
      },
      activateService2: {
        title: `${P("background_shortcuts__activate_service")} 2`,
        keys: this.extractShortcutKeys(Y.ActivateService2),
      },
      activateService3: {
        title: `${P("background_shortcuts__activate_service")} 3`,
        keys: this.extractShortcutKeys(Y.ActivateService3),
      },
      activateService4: {
        title: `${P("background_shortcuts__activate_service")} 4`,
        keys: this.extractShortcutKeys(Y.ActivateService4),
      },
      activateService5: {
        title: `${P("background_shortcuts__activate_service")} 5`,
        keys: this.extractShortcutKeys(Y.ActivateService5),
      },
      activateService6: {
        title: `${P("background_shortcuts__activate_service")} 6`,
        keys: this.extractShortcutKeys(Y.ActivateService6),
      },
      activateService7: {
        title: `${P("background_shortcuts__activate_service")} 7`,
        keys: this.extractShortcutKeys(Y.ActivateService7),
      },
      activateService8: {
        title: `${P("background_shortcuts__activate_service")} 8`,
        keys: this.extractShortcutKeys(Y.ActivateService8),
      },
      activateService9: {
        title: `${P("background_shortcuts__activate_service")} 9`,
        keys: this.extractShortcutKeys(Y.ActivateService9),
      },
    }),
      this.logger.info("Shortcuts loaded", this.shortcuts);
  }
  onShortcutsUpdated(e) {
    return this.emitter.on("shortcuts-updated", e);
  }
  onShortcutUsed(e) {
    return this.emitter.on("shortcut-used", e);
  }
  getAppShortcut(e) {
    let {
      activateService1: t,
      activateService2: r,
      activateService3: i,
      activateService4: s,
      activateService5: a,
      activateService6: n,
      activateService7: p,
      activateService8: d,
      activateService9: u,
    } = this.getShortcuts();
    switch (e) {
      case 0:
        return t;
      case 1:
        return r;
      case 2:
        return i;
      case 3:
        return s;
      case 4:
        return a;
      case 5:
        return n;
      case 6:
        return p;
      case 7:
        return d;
      case 8:
        return u;
      default:
        return;
    }
  }
  handleShortcutsUpdated(e) {
    let t = e.map((r) => ({
      name: r.name,
      description: r.description,
      shortcut: r.keybinding,
    }));
    this.loadShortcuts(t).catch(l), this.emitter.emit("shortcuts-updated", t);
  }
  overriddenShortcuts(e, t) {
    let r = {};
    return (
      e
        .filter((s) => {
          g(s.name, "Command must have a name");
          let a = s.name,
            n = t[a];
          return n ? n.from === jk(Ey(s.shortcut || "")) : !1;
        })
        .forEach((s) => {
          g(s.name, "Command must have a name");
          let a = t[s.name];
          g(a, "overrideCommand not found for command", {
            commandName: s.name,
          });
          let n = Ie(a, "from");
          this.browserService.addShortcut(s.name, {
            description: s.description,
            suggested_key: n,
          }),
            (r[s.name] = a);
        }),
      r
    );
  }
  extractShortcutKeys(e) {
    let t = this.commandsById?.[e];
    return t?.shortcut ? Ey(t.shortcut) : [];
  }
  async handleSwitchTabCommand(e, t = !1) {
    if (await this.tabSwitcherService.tryOpenNextTab(e)) return;
    let r = await this.browserService.getLastFocusedWindowId();
    if (r === void 0) return;
    let i = this.modalService.getModalForWindow(r);
    if (
      (this.isRepeatedCommand || this.wasCtrlTabCommand) &&
      i?.id === "tabs-switcher"
    )
      t
        ? this.tabSwitcherService.decrementCurrentIndex()
        : this.tabSwitcherService.incrementCurrentIndex();
    else {
      let s = this.tabSwitcherService.getTabOrder(e);
      this.modalService.closeAllModalsById("tabs-switcher"),
        await this.tabSwitcherService.resetCurrentIndex(s),
        await this.modalService.showTabSwitcherModal({
          source: "shortcut",
          tabOrder: s,
          isOpenedByCtrlTab: e,
        });
    }
  }
  async handleKeyUpSwitchTabCommand() {
    let e = await this.browserService.getLastFocusedWindowId();
    e === void 0 ||
      this.modalService.getModalForWindow(e)?.id !== "tabs-switcher" ||
      (this.analytics.sendAnalyticsEvent("tab-switcher.tab-opened", void 0),
      await this.tabSwitcherService.activateSelectedTab(e));
  }
  async handleToggleCollectionsOrTasks(e) {
    return this.sidecarService.getIsTasksOrCollectionsSidecarEnabled(e)
      ? this.sidecarService.toggleCollectionsOrTasks(e, { source: "shortcut" })
      : Promise.resolve();
  }
  handleToggleWindowFocusMode() {
    this.featureFlagsRepository.getFeatureFlag("focusModeShortcutEnabled") &&
      this.toggleFocusModeAndCloseExtraModals().catch(fe);
  }
  async toggleFocusModeAndCloseExtraModals() {
    let e = await this.browserService.getNormalLastFocusedWindowId();
    e && this.notificationsSettingsApi.hideSettingsPopup(e),
      await this.focusModeService.toggleWindowFocusMode();
  }
  async handleToggleSidebar() {
    let e = await this.browserService.getLastFocusedWindowId();
    e !== void 0 && this.sidebarVisibilityManager.toggleSidebar(e);
  }
  async handleKeyUpShowSession() {
    let e = await this.browserService.getLastFocusedWindowId();
    e !== void 0 &&
      (this.popupService.hidePopup(e, "quick-session-switcher"),
      this.analytics.sendAnalyticsEvent("sessions.activate-clicked", {
        source: "quick-switch",
      }),
      await this.quickSessionSwitcherService.switchToCurrentIndexedSession(e),
      this.quickSessionSwitcherService.resetCurrentIndex());
  }
  objFindValueByKey(e, t) {
    let r = Object.keys(e).find(t);
    return r ? e[r] : void 0;
  }
  async openLastSplitAppOrTab(e, t) {
    if ((await this.splitViewService.getLastSplitViewType()) !== "tab") {
      this.applicationApi.activateApplicationInSplitPanel().catch(l);
      return;
    }
    this.splitViewService.openLastSplitTab(e, t).catch(l);
  }
};
c();
c();
var bd = "sidebar-session-control-app";
var gd = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m, y, b) {
    this.popupService = e;
    this.applicationApi = t;
    this.workspaceApi = r;
    this.billingApi = i;
    this.sessionApi = s;
    this.analyticsTracker = a;
    this.systemInfoService = n;
    this.exploredFeaturesService = p;
    this.featureFlagsRepository = d;
    this.applicationRepository = u;
    this.workspaceRepository = m;
    this.sidecarService = y;
    b.subscribeToSidebarAppMouseEvents((v, S, w, T) => {
      this.isSessionControlAction(v)
        ? this.handleSessionControlEvent(w, T)
        : this.shouldActivateApp(w)
        ? this.handleAppActivate(w, v, T, S)
        : this.shouldOpenAppPopup(w)
        ? this.handleAppClick(v, S, T)
        : this.shouldHoverApp(w)
        ? this.handleAppHover(v, S)
        : this.shouldLeaveApp(w) && this.clearHoverTimeout();
    }),
      b.subscribeToSidebarNewAppAdded((v, S, w) => {
        this.workspaceApi.changeAppIsPinned(w, v, !0, S);
      }),
      b.subscribeToSidebarAppMoved((v, S, w) =>
        this.workspaceApi.moveAppInWorkspace(w, v, S)
      ),
      b.subscribeToSidebarAppPinChanged((v, S, w, T) => {
        this.analyticsTracker.sendAnalyticsEvent("sidebar.app-dnd", void 0),
          this.workspaceApi.changeAppIsPinned(T, v, S, w);
      }),
      b.subscribeToSidebarAppRemoved((v, S) => {
        this.workspaceApi.removeAppFromSidebar(S, v).catch(l);
      });
  }
  hoverAppTimer = null;
  activateApplication(e, t, r, i) {
    let a =
      this.workspaceRepository
        .getWorkspaceForWindow(e)
        ?.pinnedOrderAppIds.findIndex((y) => y === t) ?? 0;
    if (
      this.billingApi.showLimitPopupIfBlocked(
        () => this.billingApi.canOpenSidebarApp(a),
        "not-ready-to-upgrade-popup"
      )
    )
      return;
    let p = r.ctrlKey || r.metaKey,
      d = this.applicationApi.getRecipeIdByAppId(t);
    g(d, "App activation failed: recipeId cannot be null");
    let u = this.applicationRepository.getAppById(t);
    g(u, "App activation failed: app not found");
    let m = this.workspaceRepository.getWorkspaceById(u.workspaceId);
    this.analyticsTracker.sendAnalyticsEvent(
      p ? "app.activated-as-tab" : "app.activated",
      {
        source: i,
        "app.pinned-index": a,
        "app.recipe-id": d,
        "app.is-team-app": u.isTeamApp,
        "app.is-shared": u.sharedToMe,
        "team.uuid": m?.teamUuid ?? null,
      }
    ),
      p
        ? this.applicationApi.activateApplicationsAsTab(t).catch(l)
        : this.applicationApi
            .activateApplication(t, {
              inGlobalSplit: r.altKey,
              keepReusableTab: !0,
            })
            .catch(l);
  }
  shouldOpenAppPopup(e) {
    let { isMac: t } = this.systemInfoService;
    return (
      (e.button === 2 || (t && e.button === 0 && e.ctrlKey)) &&
      e.type === "mousedown"
    );
  }
  shouldActivateApp(e) {
    return e.button === 0 && e.type === "click";
  }
  shouldHoverApp(e) {
    return (
      this.featureFlagsRepository.getFeatureFlag(
        "isHoverAppMenuSidebarEnabled"
      ) && e.type === "mouseenter"
    );
  }
  shouldLeaveApp(e) {
    return (
      this.featureFlagsRepository.getFeatureFlag(
        "isHoverAppMenuSidebarEnabled"
      ) && e.type === "mouseleave"
    );
  }
  isSessionControlAction(e) {
    return e === bd;
  }
  clearHoverTimeout() {
    this.hoverAppTimer !== null &&
      (clearTimeout(this.hoverAppTimer), (this.hoverAppTimer = null));
  }
  handleAppHover(e, t) {
    let { openningTime: r } = this.featureFlagsRepository.getFeatureFlag(
      "hoverAppMenuSidebar"
    );
    this.hoverAppTimer = setTimeout(() => {
      this.popupService.showApplicationPopup(e, t).catch(l),
        this.exploredFeaturesService.explore("opened_app_popup"),
        this.analyticsTracker.sendAnalyticsEvent("sidebar.app-menu-requested", {
          by: "hover",
        });
    }, r);
  }
  handleAppClick(e, t, r) {
    this.clearHoverTimeout(),
      this.popupService.toggleApplicationPopup(r, e, t),
      this.exploredFeaturesService.explore("opened_app_popup"),
      this.analyticsTracker.sendAnalyticsEvent("sidebar.app-menu-requested", {
        by: "click",
      });
  }
  handleAppActivate(e, t, r, i) {
    if (
      (this.clearHoverTimeout(),
      this.applicationRepository.getAllApps().length === 0)
    )
      return;
    let a = this.applicationRepository.getAppById(t);
    g(a, "Failed to handle app activation: app not found for current app id", {
      appId: t,
    }),
      this.analyticsTracker.sendAnalyticsEvent("sidebar.app-clicked", {
        "app.recipe-id": a.recipeId,
      }),
      this.activateApplication(r, t, e, "sidebar.app-clicked"),
      this.popupService.setLastActivatedAppPopupInfo({
        appId: t,
        position: { ...i },
      }),
      this.exploredFeaturesService.explore("activated_app_on_sidebar");
  }
  handleSessionControlEvent(e, t) {
    e.type === "mouseenter"
      ? this.sidecarService.showLastOpenedSidecar(t)
      : e.type === "click" &&
        this.sessionApi.openLastActiveSessionTabInWindow(t).catch(l);
  }
};
c();
c();
c();
var ft = class {};
var vd = class extends ft {
  constructor(t) {
    super();
    this.sidecarService = t;
  }
  handleEvent(t, r, i) {
    r.type === "click" &&
      this.sidecarService
        .toggleCollectionsOrTasks(i, {
          source: "sidebar.collections-tasks-button-clicked",
        })
        .catch(l);
  }
};
c();
var fd = class extends ft {
  constructor(t, r) {
    super();
    this.notificationsSettingsApi = t;
    this.featureFlagsRepository = r;
  }
  hoverTimer = null;
  handleEvent(t, r, i) {
    if (r.type === "click") {
      this.notificationsSettingsApi.toggleGlobalMute();
      return;
    }
    if (this.notificationsSettingsApi.isMuteNotificationsPopupEnabled()) {
      if (this.isRightClickEvent(r)) {
        this.notificationsSettingsApi.toggleSettingsPopup(i);
        return;
      }
      if (r.type === "mouseenter") {
        this.scheduleHoverOpenning(i);
        return;
      }
      r.type === "mouseleave" && this.resetTimeout();
    }
  }
  scheduleHoverOpenning(t) {
    let { delayBeforeShowing: r } = this.featureFlagsRepository.getFeatureFlag(
      "muteNotificationsPopup"
    );
    this.hoverTimer = setTimeout(() => {
      this.notificationsSettingsApi.showSettingsPopup(t), this.resetTimeout();
    }, r);
  }
  isRightClickEvent(t) {
    return t.type === "mousedown" && t.button === 2;
  }
  resetTimeout() {
    this.hoverTimer !== null &&
      (clearTimeout(this.hoverTimer), (this.hoverTimer = null));
  }
};
c();
var Sd = class extends ft {
  constructor(t) {
    super();
    this.searchIconService = t;
  }
  handleEvent(t, r, i) {
    r.type === "click" && this.searchIconService.handleClickOnSidebar(i);
  }
};
c();
var wd = class extends ft {
  constructor(t, r) {
    super();
    this.analyticsTracker = t;
    this.modalService = r;
  }
  handleEvent(t, r, i) {
    r.type === "click" &&
      (this.analyticsTracker.sendAnalyticsEvent(
        "sidebar.global-settings-button-clicked",
        void 0
      ),
      this.modalService
        .showGlobalSettingsModal(
          { source: "sidebar.global-settings-button-clicked" },
          i
        )
        .catch(l));
  }
};
c();
var kd = class extends ft {
  constructor(t, r) {
    super();
    this.analyticsTracker = t;
    this.sidecarService = r;
  }
  handleEvent(t, r, i) {
    r.type === "click" &&
      (this.analyticsTracker.sendAnalyticsEvent(
        "sidebar.help-button-clicked",
        void 0
      ),
      this.sidecarService
        .toggleHelp({ source: "sidebar.help-button-clicked" }, i)
        .catch(l));
  }
};
c();
var Td = class extends ft {
  constructor(t, r, i, s) {
    super();
    this.analyticsTracker = t;
    this.sidecarService = r;
    this.featureFlagsRepository = i;
    this.popupService = s;
  }
  hoverTimer = null;
  handleEvent(t, r, i) {
    if (r.type === "click") {
      this.handleClick(i);
      return;
    }
    if (
      this.featureFlagsRepository.getFeatureFlag(
        "isHoverSessionSwitcherSidebarEnabled"
      )
    ) {
      if (r.type === "mouseenter") {
        this.scheduleHoverOpenning(i);
        return;
      }
      r.type === "mouseleave" && this.resetTimeout();
    }
  }
  handleClick(t) {
    this.analyticsTracker.sendAnalyticsEvent(
      "sidebar.sessions-button-clicked",
      void 0
    ),
      this.sidecarService
        .toggleSessions({ source: "sidebar.sessions-button-clicked" }, t)
        .catch(l);
  }
  scheduleHoverOpenning(t) {
    let { delayBeforeShowing: r } = this.featureFlagsRepository.getFeatureFlag(
      "hoverSessionSwitcherSidebar"
    );
    this.hoverTimer = setTimeout(() => {
      this.popupService
        .showQuickSessionSwitcherPopup({ source: "sidebar" }, t)
        .catch(l),
        this.resetTimeout();
    }, r);
  }
  resetTimeout() {
    this.hoverTimer !== null &&
      (clearTimeout(this.hoverTimer), (this.hoverTimer = null));
  }
};
var Id = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m) {
    this.modalService = e;
    this.userApi = t;
    this.analyticsTracker = i;
    this.exploredFeaturesService = s;
    this.billingApi = a;
    let y = {
      collections: new vd(r),
      "global-mute": new fd(n, u),
      "global-search": new Sd(m),
      "global-settings": new wd(i, e),
      help: new kd(i, r),
      session: new Td(i, r, u, p),
    };
    d.subscribeToSidebarButtonMouseEvents((b, v, S, w) => {
      y[b].handleEvent(v, S, w);
    }),
      d.subscribeToSidebarAddAppClicked(this.handleAddAppClick.bind(this)),
      d.subscribeToSidebarToggleMinimized(
        this.handleToggleMinimizedClick.bind(this)
      );
  }
  handleToggleMinimizedClick() {
    let e = !this.userApi.getSettings().isHiddenSidebarIcons;
    this.analyticsTracker.sendAnalyticsEvent(
      "sidebar.bottom-buttons-collapsed",
      { "new-value": e }
    ),
      this.userApi.changeIsHiddenSidebarIcons(e);
  }
  handleAddAppClick(e) {
    if (
      (this.analyticsTracker.sendAnalyticsEvent(
        "sidebar.add-application-button-clicked",
        void 0
      ),
      this.shouldShowLimitsModalForAddApp(e))
    ) {
      this.modalService
        .showBillingLimitsReachedModal({ source: "sidebar.app-clicked" })
        .catch(l);
      return;
    }
    this.modalService
      .showMarketplaceModal(
        { source: "sidebar.add-application-button-clicked" },
        e
      )
      .catch(l),
      this.exploredFeaturesService.explore(
        "added_app_through_plus_icon_on_sidebar"
      );
  }
  shouldShowLimitsModalForAddApp(e) {
    return !this.billingApi.canAddAppToWorkspaceByWindow(e);
  }
};
c();
c();
var Ad = class {
  constructor(e, t, r, i, s, a, n, p, d, u, m, y, b, v, S, w, T, I, k) {
    this.userSettingsRepository = e;
    this.workspaceRepository = t;
    this.applicationRepository = r;
    this.sessionRepository = i;
    this.shortcutService = s;
    this.browserService = a;
    this.themeService = n;
    this.accountRepository = p;
    this.browserEventsService = d;
    this.helpExperimentalLayer = u;
    this.exploredFeaturesService = m;
    this.browserUpdaterService = y;
    this.billingRepository = b;
    this.featureFlagsRepository = v;
    this.runningApplicationsObserver = S;
    this.searchIconService = w;
    this.sidecarAppearanceService = T;
    this.collectionsRepository = I;
    (this.cachedState = {
      settings: this.getSettings(),
      apps: [],
      buttons: this.getUniversalButtons(),
    }),
      this.initState(k),
      this.initBrowserChangedObservers(),
      this.initExtensionChangedObservers(),
      (this.isRerenderBlocked =
        !this.applicationRepository.getIsLoadedFromCache()),
      this.reloadAppsAndUpdate();
  }
  windowIds = new Set();
  cachedState;
  isRerenderBlocked = !0;
  initState(e) {
    this.cacheApps(),
      e.forEach((t) => {
        t.id && this.windowIds.add(t.id);
      });
  }
  initBrowserChangedObservers() {
    let e = null,
      t = !1;
    pe.on("session-created-from-window", ({ windowId: r }) => {
      this.windowIds.add(r), this.updateSidebarState(r);
    }),
      pe.on("session-changed", (r) => {
        let i = this.sessionRepository.getWindowIdBySessionId(r);
        i && this.updateSidebarState(i);
      }),
      this.browserEventsService.subscribeToTabActivated(
        ({ tabId: r, windowId: i }) => {
          if (this.sessionRepository.getTabByWindowId(i, r)) {
            this.updateSidebarState(i);
            return;
          }
          (e = r), (t = !1), this.reloadAppsAndUpdate();
        }
      ),
      this.browserEventsService.subscribeToTabUpdated(
        (r, { status: i, url: s }, a) => {
          let n = i === "loading";
          if ((!n && i !== "complete") || (s && this.browserService.isNTP(s)))
            return;
          if (this.sessionRepository.getTabByWindowId(a.windowId, r)) {
            this.sessionRepository.getSessionByWindowId(a.windowId)
              ?.isTemporary && this.updateSidebarState(a.windowId);
            return;
          }
          if (e === r && n && t) return;
          t = !0;
          let u = this.runningApplicationsObserver.getAppIdByTabId(r);
          u &&
            (this.updateAppCacheById(u), this.updateSidebarState(a.windowId));
        }
      ),
      this.browserEventsService.subscribeToTabRemoved((r, i) => {
        i.isWindowClosing || this.updateSidebarState(i.windowId);
      }),
      this.browserEventsService.subscribeToNormalWindowCreated(({ id: r }) => {
        r && this.windowIds.add(r);
      }),
      this.browserEventsService.subscribeToWindowRemoved((r) => {
        this.windowIds.delete(r), this.reloadAppsAndUpdate();
      }),
      this.browserEventsService.subscribeToSidebarToggleMinimized(
        this.toggleButtonMinimizedSetting.bind(this)
      ),
      pe.on("session-tab-changed", (r, i) => {
        i === this.sessionRepository.getLastActiveTabInSession(r)?.id &&
          this.updateAllStates();
      }),
      this.sidecarAppearanceService.onSidecarModeChanged(() => {
        this.updateAllStates();
      });
  }
  initExtensionChangedObservers() {
    let e = ["apps-closed", "accounts-loaded", "accounts-changed"];
    D.on("apps-loaded", () => {
      (this.isRerenderBlocked = !1), this.reloadAppsAndUpdate();
    }),
      D.onSeveral(e, this.reloadAppsAndUpdate.bind(this)),
      D.on("apps-changed", this.updateAppByChangeInfo.bind(this)),
      W.on("user-settings-changed", this.updateSidebarAndReloadApps.bind(this)),
      se.on("billing-plan-loaded", this.reloadAppsAndUpdate.bind(this)),
      this.browserUpdaterService.onUpdateStatusChanged(
        this.updateButtons.bind(this)
      ),
      this.exploredFeaturesService.onExploredLoaded(
        this.updateSidebarAndReloadApps.bind(this)
      ),
      this.exploredFeaturesService.onExploredUpdated(
        this.updateOnFeatureExplored.bind(this)
      ),
      this.featureFlagsRepository.onFeatureFlagsLoaded(
        this.updateButtons.bind(this)
      ),
      re.on("workspaces-changed", (t) => {
        t?.pinnedOrderAppIds && this.reloadAppsAndUpdate();
      }),
      this.shortcutService.onShortcutsUpdated(() => () => {
        (this.cachedState = {
          ...this.cachedState,
          buttons: this.getUniversalButtons(),
        }),
          this.reloadAppsAndUpdate();
      }),
      this.helpExperimentalLayer.onHelpStateChanged(
        this.updateButtons.bind(this)
      ),
      this.themeService.onThemeChanged(this.updateTheme.bind(this));
  }
  toggleButtonMinimizedSetting() {
    (this.cachedState = {
      ...this.cachedState,
      settings: {
        ...this.cachedState.settings,
        isButtonsMinimized: !this.cachedState.settings.isButtonsMinimized,
      },
    }),
      this.updateAllStates();
  }
  updateButtons() {
    (this.cachedState = {
      ...this.cachedState,
      buttons: this.getUniversalButtons(),
    }),
      this.updateAllStates();
  }
  reloadAppsAndUpdate() {
    this.cacheApps(), this.updateAllStates();
  }
  updateAppByChangeInfo(e, t) {
    this.appCacheUpdatingGuard(t) &&
      (this.updateAppCacheById(e), this.updateAllStates());
  }
  updateSidebarAndReloadApps() {
    this.updateSidebarSize(), this.reloadAppsAndUpdate();
  }
  updateOnFeatureExplored(e, t) {
    t || this.updateSidebarAndReloadApps();
  }
  updateTheme() {
    let e = this.themeService.getTheme();
    (this.cachedState = {
      ...this.cachedState,
      settings: { ...this.cachedState.settings, theme: e },
    }),
      this.updateAllStates();
  }
  updateSidebarSize() {
    let { sidebarSize: e } = this.userSettingsRepository.getSettings();
    this.cachedState = {
      ...this.cachedState,
      settings: { ...this.cachedState.settings, size: e },
    };
  }
  updateAllStates() {
    this.windowIds.forEach(this.updateSidebarState.bind(this));
  }
  updateSidebarState(e) {
    if (this.isRerenderBlocked) return;
    let t = this.workspaceRepository.getWorkspaceIdForWindow(e);
    if (!t) return;
    let r = this.sessionRepository.getSessionByWindowId(e);
    if (!r) return;
    let i = this.runningApplicationsObserver.getActiveAppId(e),
      { inactiveServiceGrayscale: s, globalMute: a } =
        this.userSettingsRepository.getSettings(),
      n = this.getFocusModeGrayscale(a, s),
      p = [];
    this.cachedState.apps.forEach((m) => {
      m.workspaceId === t &&
        p.push({
          ...m,
          isActive: m.id === i,
          grayscaleInactive: m.grayscaleInactive || n,
        });
    });
    let { settings: d } = this.cachedState,
      u = {
        apps: p,
        buttons: this.createButtons(r, e),
        settings: d,
        sessionControlApp: this.createSessionControlApp(e),
      };
    this.browserService.updateSidebarState(e, u).catch((m) => {
      this.windowIds.has(e) && fe(m);
    });
  }
  updateAppCacheById(e) {
    let t = this.applicationRepository.getAppById(e);
    if (!t) return;
    let r = this.workspaceRepository.getWorkspaceById(t.workspaceId);
    if (!r) return;
    let i = this.cachedState.apps.find((u) => u.id === e);
    if (!i) {
      this.cachedState.apps.length === 0 && this.reloadAppsAndUpdate();
      return;
    }
    let { globalMute: s } = this.userSettingsRepository.getSettings(),
      a = r.pinnedOrderAppIds.indexOf(e),
      n = a === -1 ? void 0 : a,
      p = {
        app: t,
        isPinned: i.isPinned,
        isRunning: i.isRunning,
        index: n,
        globalMute: s,
        isInactive: i.grayscaleInactive === 1,
        disabledByBilling: i.grayscaleInactive === 2,
      },
      d = this.composeAppForSidebar(p);
    this.cachedState = {
      ...this.cachedState,
      apps: this.cachedState.apps.map((u) => (u.id === e ? d : u)),
    };
  }
  createButtons(e, t) {
    let { manageSession: r } = this.shortcutService.getShortcuts(),
      i = {
        id: "session",
        iconUrl: No(e.name ?? ""),
        tooltip: r.title,
        shortcut: r.keys,
        bgColor: pa(e.name),
        hasRedDot: !1,
      },
      s = this.getCollectionsAndTasksButton(t),
      a = this.getUniversalButtons();
    return s && a.push(s), a.push(i), a;
  }
  cacheApps() {
    let e = this.workspaceRepository.getWorkspacesArray();
    if (!e.length) return;
    let t = this.applicationRepository.getAppsById(),
      { globalMute: r, inactiveServiceGrayscale: i } =
        this.userSettingsRepository.getSettings(),
      s =
        this.billingRepository.getBillingPlanOption("pinnedAppsLimit") ?? 1 / 0,
      a = [];
    e.forEach((n) => {
      n.pinnedOrderAppIds.forEach((p, d) => {
        let u = t[p];
        if (!u) return;
        let m = this.runningApplicationsObserver.getIsRunningApp(u.id),
          y = d >= s,
          b = {
            app: u,
            isPinned: !0,
            isRunning: m,
            globalMute: r,
            index: d,
            isInactive: y,
            disabledByBilling: y,
          };
        a.push(this.composeAppForSidebar(b));
      }),
        n.orderAppIds.forEach((p) => {
          if (n.pinnedOrderAppIds.includes(p)) return;
          let d = t[p];
          if (!d || !this.runningApplicationsObserver.getIsRunningApp(d.id))
            return;
          let m = { app: d, isRunning: !0, globalMute: r, isInactive: i };
          a.push(this.composeAppForSidebar(m));
        });
    }),
      (this.cachedState = { ...this.cachedState, apps: a });
  }
  composeAppForSidebar({
    app: e,
    isPinned: t = !1,
    isRunning: r = !1,
    globalMute: i,
    index: s,
    isInactive: a,
    disabledByBilling: n,
  }) {
    let { url: p, name: d, bg: u } = this.getAccountAvatarForApp(e),
      { tooltip: m, shortcut: y } = this.getTooltipForApp(e, t, s),
      b = this.featureFlagsRepository.getFeatureFlag(
        "isHoverAppMenuSidebarEnabled"
      ),
      { areNotificationsEnabled: v, unreadMessages: S } = Gb(e, i),
      w = Number(S) > 99 ? "99+" : S,
      I = n
        ? `${
            this.billingRepository.getBillingPlan()?.planOptions
              .pinnedAppsLimit ?? 5
          } ${P("background_sidebar_state__tooltip_with_billing")}`
        : b
        ? ""
        : m,
      k =
        e.iconUrl ||
        Fu(e.customUrl || e.recipeMetaData?.welcomeURL || "") ||
        nb(),
      _ = this.getFocusModeGrayscale(i, a),
      O = n ? 2 : _,
      E = e.showAsSidecarPanelSetting;
    return {
      id: e.id,
      iconUrl: k,
      accountAvatarUrl: p,
      accountName: d,
      accountBg: u,
      hasBadge: v && r,
      tooltip: I,
      shortcut: n ? [] : y,
      unreadMessagesCount: w,
      isActive: !1,
      isRunning: r,
      isPinned: t,
      grayscaleInactive: O,
      workspaceId: e.workspaceId,
      shouldOpenInSplitView: E,
    };
  }
  getUniversalButtons() {
    return [
      this.getGlobalMuteButton(),
      this.getGlobalSearchButton(),
      this.getHelpButton(),
      this.getGlobalSettingsButton(),
    ].filter(de);
  }
  getSettings() {
    let e = this.themeService.getTheme(),
      { sidebarSize: t, isHiddenSidebarIcons: r } =
        this.userSettingsRepository.getSettings();
    return { theme: e, size: t, isButtonsMinimized: r };
  }
  getAccountAvatarForApp(e) {
    let t = this.accountRepository.getAccountForAppAvatar(e);
    return t
      ? t.avatar
        ? { url: t.avatar }
        : { name: t.name.toUpperCase(), bg: pa(t.name) }
      : {};
  }
  getTooltipForApp(e, t, r) {
    if (
      Boolean(
        this.exploredFeaturesService.getIsFeatureUnexplored("opened_app_popup")
      )
    )
      return {
        tooltip: P("background_sidebar_state__tooltip_right_click"),
        shortcut: [],
      };
    let s = t ? this.shortcutService.getAppShortcut(r)?.keys ?? [] : [];
    return { tooltip: e.name, shortcut: s };
  }
  getGlobalMuteButton() {
    let { globalMute: e } = this.userSettingsRepository.getSettings(),
      r = !this.featureFlagsRepository.getFeatureFlag(
        "isMuteNotificationsPopupEnabled"
      );
    return {
      id: "global-mute",
      isMuted: e,
      tooltip: e
        ? P("background_sidebar_state__tooltip_unmute")
        : P("background_sidebar_state__tooltip_mute"),
      shortcut: [],
      hasRedDot: r,
    };
  }
  getGlobalSearchButton() {
    if (!this.searchIconService.getShouldShowSearchIconInSidebar()) return null;
    let { globalSearch: e } = this.shortcutService.getShortcuts(),
      t = Boolean(
        this.exploredFeaturesService.getIsFeatureUnexplored(
          "performed_global_search"
        )
      );
    return {
      id: "global-search",
      tooltip: e.title,
      shortcut: e.keys,
      hasRedDot: t,
    };
  }
  getHelpButton() {
    let { help: e } = this.shortcutService.getShortcuts(),
      t = Boolean(this.exploredFeaturesService.getIsFeatureUnexplored("help"));
    return {
      id: "help",
      tooltip: e.title,
      shortcut: e.keys,
      hasRedDot: t,
      progressPercent: this.getHelpButtonProgress(),
    };
  }
  getHelpButtonProgress() {
    if (!this.helpExperimentalLayer.getIsNtpMode())
      return this.helpExperimentalLayer.getProgress() * 100;
  }
  getGlobalSettingsButton() {
    let e = this.browserUpdaterService.getIsUpdateCompleted(),
      t = Boolean(
        this.exploredFeaturesService.getIsFeatureUnexplored("opened_settings")
      );
    return {
      id: "global-settings",
      tooltip: P("background_sidebar_state__tooltip_show_settings"),
      shortcut: [],
      hasRedDot: t || e,
    };
  }
  createSessionControlApp(e) {
    let t = this.sessionRepository.getSessionByWindowId(e);
    if (!t || !this.sidecarAppearanceService.getIsVerticalTabsModeEnabled())
      return;
    let { inactiveServiceGrayscale: r, globalMute: i } =
        this.userSettingsRepository.getSettings(),
      s = this.getFocusModeGrayscale(i, r),
      a =
        this.sessionRepository.getLastActiveTabInSession(t.id)?.favIconUrl ||
        Fu("chrome://newtab") ||
        "";
    return {
      id: bd,
      sessionName: t.name || "Session",
      bgColor: pa(t.name),
      faviconUrl: a,
      grayscaleInactive: s,
    };
  }
  getCollectionsAndTasksButton(e) {
    let t =
        this.collectionsRepository.isCollectionsEnabledForWorkspaceByWindowId(
          e
        ),
      r = this.featureFlagsRepository.getFeatureFlag("tasksEnabled");
    if (!t && !r) return null;
    let { toggleCollectionsSidecar: i } = this.shortcutService.getShortcuts(),
      s = [t && P("sidecar_collections__title"), r && P("sidecar_tasks__title")]
        .filter(mo)
        .join(" & ");
    return { id: "collections", tooltip: s, shortcut: i.keys, hasRedDot: !1 };
  }
  appCacheUpdatingGuard(e) {
    let t = [
      "customIconUrl",
      "iconUrl",
      "unreadMessageCount",
      "disableNotificationBadgeNumber",
      "isNotificationBadgeEnabled",
      "isNotificationEnabled",
      "name",
      "showAsSidecarPanelSetting",
    ];
    for (let r of t) if (r in e) return !0;
    return !1;
  }
  getFocusModeGrayscale(e, t) {
    return t || e ? 1 : 0;
  }
};
c();
var bo = class {
  constructor(e, t) {
    this.browserService = e;
    this.browserStorage = t;
  }
  visibilityMap = {};
  mainWindowsByPartitionMap = new Map();
  partitionsByWindowId = new Map();
  emitter = new A();
  static async build(e, t, r) {
    let i = new bo(e, r);
    if (
      ((i.visibilityMap = await e.getSidebarVisibilityMap()),
      (await e.getAllNormalWindows()).forEach(
        ({ id: p, partitionDomain: d }) => {
          !p ||
            d === void 0 ||
            (i.partitionsByWindowId.set(p, d),
            !(i.visibilityMap[p] ?? !1) ||
              i.mainWindowsByPartitionMap.has(d)) ||
            i.mainWindowsByPartitionMap.set(d, p);
        }
      ),
      i.mainWindowsByPartitionMap.size === 0)
    ) {
      let p = await e.getNormalLastFocusedWindow();
      p?.id && i.mainWindowsByPartitionMap.set(p.partitionDomain, p.id);
    }
    let a = [...i.mainWindowsByPartitionMap.values()],
      n = (await r.getItem("sidebar-hidden-state")) ?? !1;
    return (
      a.forEach((p) => {
        i.updateVisibilityState(p, !n);
      }),
      t.subscribeToNormalWindowCreated(i.onWindowCreated.bind(i)),
      t.subscribeToWindowRemoved((p) => i.onWindowRemoved(p)),
      t.subscribeToSidebarVisibilityChanged(i.updateVisibilityState.bind(i)),
      i
    );
  }
  onVisibilityChanged(e) {
    return this.emitter.on("changed", e);
  }
  getVisibilityState(e) {
    return this.visibilityMap[e] ?? !1;
  }
  updateVisibilityState(e, t, r) {
    (this.visibilityMap[e] = t),
      this.browserService
        .setSidebarVisible(e, t)
        .catch((i) =>
          r ? (l(i), Promise.resolve()) : this.onWindowRemoved(e, !0)
        ),
      this.browserStorage.setItem("sidebar-hidden-state", !t).catch(l),
      this.emitter.emit("changed", t);
  }
  toggleSidebar(e) {
    let t = this.getVisibilityState(e);
    this.updateVisibilityState(e, !t);
  }
  onWindowCreated(e) {
    if (!e.id || e.type !== "normal") return;
    this.partitionsByWindowId.set(e.id, e.partitionDomain);
    let t = !Object.entries(this.visibilityMap).length;
    (this.visibilityMap[e.id] = t),
      (t || !this.mainWindowsByPartitionMap.has(e.partitionDomain)) &&
        (this.mainWindowsByPartitionMap.set(e.partitionDomain, e.id),
        this.updateVisibilityState(e.id, !0));
  }
  onWindowRemoved(e, t) {
    delete this.visibilityMap[e];
    let r = this.partitionsByWindowId.get(e);
    if (
      (this.partitionsByWindowId.delete(e),
      r === void 0 || !this.mainWindowsByPartitionMap.has(r))
    )
      return;
    let a = [...this.partitionsByWindowId.entries()].find(
      ([, n]) => n === r
    )?.[0];
    if (!a) {
      this.mainWindowsByPartitionMap.delete(r);
      return;
    }
    this.mainWindowsByPartitionMap.set(r, a),
      this.updateVisibilityState(a, !0, t);
  }
};
c();
var Nk = "Appearance strategy not found. Forgot to call setStrategy?",
  Pd = class {
    appearanceStrategy = null;
    showSidecar(e, t, r) {
      g(this.appearanceStrategy, Nk),
        this.appearanceStrategy.showSidecar(e, t, r);
    }
    hideSidecar(e) {
      g(this.appearanceStrategy, Nk), this.appearanceStrategy.hideSidecar(e);
    }
    setStrategy(e) {
      this.appearanceStrategy = e;
    }
  };
c();
c();
var Rd = class {
    constructor(e) {
      this.browserService = e;
    }
    showSidecar(e, t, r = "default") {
      this.browserService.showSidecar(e, t, !1, !1, r);
    }
    hideSidecar(e) {
      this.browserService.hideSidecar(e);
    }
  },
  Ed = class {
    constructor(e) {
      this.browserService = e;
    }
    showSidecar(e, t, r = "default") {
      this.browserService.showSidecar(e, t, !0, !0, r);
    }
    hideSidecar(e) {
      this.browserService.hideSidecar(e, !0);
    }
  };
var Lk = "sidekick.display_switch_ui_toolbar_button",
  Bd = "sidekick.vertical_tabs_mode",
  yF = 200,
  Cd = class {
    constructor(e, t, r, i, s) {
      this.browserService = e;
      this.featureFlagsRepository = t;
      this.browserEventsService = r;
      this.sidecarAppearanceContext = i;
      this.analyticsTracker = s;
      this.featureFlagsRepository.onFeatureFlagsLoaded((a, n) => {
        !n &&
          !a.verticalTabsEnabled &&
          this.browserService.setPref(Bd, !1).catch(l),
          this.isModeSwitchingEnabled !== a.verticalTabsEnabled &&
            this.browserService
              .setPref(Lk, a.verticalTabsEnabled)
              .then(() => {
                (this.isModeSwitchingEnabled = a.verticalTabsEnabled),
                  this.handleBehaviorChanged();
              })
              .catch(l);
      }),
        this.browserEventsService.subscribeToPrefsChanged((a) => {
          let n = a.find((p) => p.key === Bd);
          n &&
            ((this.isVerticalTabsModeEnabled = Boolean(n.value)),
            this.handleBehaviorChanged(),
            this.sendAnalytics());
        }),
        this.initAppearanceBehavior().catch(l);
    }
    isVerticalTabsModeEnabled = !1;
    isModeSwitchingEnabled = !1;
    hoverSubscriptions = [];
    openTimeout = null;
    hideTimeout = null;
    emitter = new A();
    sidecarPinnedByWindowId = {};
    sendAnalytics() {
      if (this.isVerticalTabsModeEnabled) {
        this.analyticsTracker.sendAnalyticsEvent(
          "system.vertical-tabs.on",
          void 0
        );
        return;
      }
      this.analyticsTracker.sendAnalyticsEvent(
        "system.vertical-tabs.off",
        void 0
      );
    }
    onSidecarModeChanged(e) {
      return this.emitter.on("sidecar-mode-changed", e);
    }
    onHotZoneMouseEnter(e) {
      return this.emitter.on("sidecar-hot-zone-mouse-enter", e);
    }
    pinSidecar(e, t, r) {
      this.getIsVerticalTabsModeEnabled &&
        ((this.sidecarPinnedByWindowId[e] = !0), this.showSidecar(e, t, r));
    }
    unpinSidecar(e) {
      this.getIsVerticalTabsModeEnabled &&
        ((this.sidecarPinnedByWindowId = Ie(this.sidecarPinnedByWindowId, e)),
        this.showSidecar(e));
    }
    isSidecarPinned(e) {
      return Boolean(this.sidecarPinnedByWindowId[e]);
    }
    toggleSidecarPinned(e, t, r) {
      if (this.isSidecarPinned(e)) {
        this.unpinSidecar(e), this.hideSidecar(e);
        return;
      }
      this.pinSidecar(e, t, r);
    }
    getIsVerticalTabsModeEnabled() {
      return this.isModeSwitchingEnabled && this.isVerticalTabsModeEnabled;
    }
    getIsModeSwitchingEnabled() {
      return this.isModeSwitchingEnabled;
    }
    showSidecar(e, t, r) {
      this.cancelSidecarClosing(),
        this.selectAppearanceStrategyForWindow(e),
        this.sidecarAppearanceContext.showSidecar(e, t, r);
    }
    hideSidecar(e) {
      this.selectAppearanceStrategyForWindow(e),
        this.sidecarAppearanceContext.hideSidecar(e);
    }
    hideSidecarWithTimeout(e, t) {
      this.hideTimeout = setTimeout(() => {
        this.hideSidecar(e);
      }, t);
    }
    async initAppearanceBehavior() {
      await Promise.all([
        this.initEnableModeSwitchingPref(),
        this.initVerticalTabsPref(),
      ]),
        this.handleBehaviorChanged();
    }
    async initVerticalTabsPref() {
      let e = await this.browserService.getPref(Bd);
      this.isVerticalTabsModeEnabled = e.value;
    }
    async initEnableModeSwitchingPref() {
      await this.browserService.setPref(Lk, !1),
        (this.isModeSwitchingEnabled = !1);
    }
    switchToVerticalTabs() {
      this.browserService.setPref(Bd, !0).catch(l);
    }
    handleBehaviorChanged() {
      if (this.getIsVerticalTabsModeEnabled()) {
        this.subscribeToHoverEvents(),
          this.emitter.emit("sidecar-mode-changed", "overlap");
        return;
      }
      this.unsubscribeFromHoverEvents(),
        (this.sidecarPinnedByWindowId = {}),
        this.emitter.emit("sidecar-mode-changed", "default");
    }
    subscribeToHoverEvents() {
      this.hoverSubscriptions.length ||
        (this.hoverSubscriptions = [
          this.browserEventsService.subscribeToMouseEnterHotZone(
            this.scheduleSidecarShowing.bind(this)
          ),
          this.browserEventsService.subscribeToMouseExitHotZone(
            this.clearShowingTimeout.bind(this)
          ),
        ]);
    }
    clearShowingTimeout() {
      this.openTimeout &&
        (clearTimeout(this.openTimeout), (this.openTimeout = null));
    }
    cancelSidecarClosing() {
      this.hideTimeout && clearTimeout(this.hideTimeout);
    }
    scheduleSidecarShowing(e) {
      this.openTimeout && clearTimeout(this.openTimeout),
        (this.openTimeout = setTimeout(() => {
          this.emitter.emit("sidecar-hot-zone-mouse-enter", e);
        }, yF));
    }
    unsubscribeFromHoverEvents() {
      this.hoverSubscriptions.length &&
        (F(this.hoverSubscriptions)(),
        (this.hoverSubscriptions = []),
        this.clearShowingTimeout());
    }
    selectAppearanceStrategyForWindow(e) {
      if (
        !this.getIsVerticalTabsModeEnabled() ||
        this.sidecarPinnedByWindowId[e]
      ) {
        this.sidecarAppearanceContext.setStrategy(new Rd(this.browserService));
        return;
      }
      this.sidecarAppearanceContext.setStrategy(new Ed(this.browserService));
    }
  };
c();
var bF = { mode: "sessions", payload: void 0, source: "hover" },
  gF = ["tasks", "collections", "help"];
var _d = class {
  constructor(e, t, r, i, s, a) {
    this.browserService = e;
    this.browserStorage = t;
    this.featureFlagsRepository = r;
    this.browserEventsService = i;
    this.collectionsRepository = s;
    this.sidecarAppearanceService = a;
    this.loadLastActiveView().catch(l),
      this.browserEventsService.subscribeToTabActivated((n) => {
        this.toggleFullscreen(n.windowId, !1, !0);
      }),
      this.sidecarAppearanceService.onHotZoneMouseEnter((n) => {
        this.showLastOpenedSidecar(n);
      });
  }
  sidecarByWindowId = {};
  lastActiveView = null;
  lastFullscreenState = !1;
  emitter = new A();
  onSidecarChanged(e) {
    return this.emitter.on("sidecar-changed", e);
  }
  getSidecarForWindow(e) {
    return this.sidecarByWindowId[e];
  }
  toggleHelp(e, t) {
    return this.toggleSidecar({ mode: "help", payload: void 0, ...e }, t);
  }
  toggleSessions(e, t) {
    return this.toggleSidecar({ mode: "sessions", payload: void 0, ...e }, t);
  }
  getIsTasksOrCollectionsSidecarEnabled(e) {
    let t =
        this.collectionsRepository.isCollectionsEnabledForWorkspaceByWindowId(
          e
        ),
      r = this.featureFlagsRepository.getFeatureFlag("tasksEnabled");
    return t || r;
  }
  toggleCollectionsOrTasks(e, t) {
    let r =
        this.collectionsRepository.isCollectionsEnabledForWorkspaceByWindowId(
          e
        ),
      i = this.featureFlagsRepository.getFeatureFlag("tasksEnabled");
    return !r && !i
      ? Promise.resolve()
      : r && (!i || this.lastActiveView !== "tasks")
      ? this.toggleCollections(t, e)
      : i && (!r || this.lastActiveView !== "collections")
      ? this.toggleTasks(t, e)
      : Promise.resolve();
  }
  toggleCollections(e, t) {
    return (
      this.updateLastActiveView("collections"),
      this.toggleSidecar({ mode: "collections", payload: void 0, ...e }, t)
    );
  }
  toggleTasks(e, t) {
    let r = me.SIDEKICK_TASKS;
    return (
      g(r, "Forgot to set SIDEKICK_TASKS in env vars?"),
      this.updateLastActiveView("tasks"),
      this.toggleSidecar({ mode: "tasks", payload: { src: r }, ...e }, t)
    );
  }
  toggleFullscreen(e, t, r = !0) {
    let i = t ?? !this.lastFullscreenState;
    i
      ? this.browserService.expandFullscreen(e)
      : this.browserService.collapseFullscreen(e),
      r && (this.lastFullscreenState = i);
  }
  isTasksSidecarOpen(e) {
    return this.getSidecarForWindow(e)?.mode === "tasks";
  }
  pinSidecar(e) {
    let t = this.sidecarAppearanceService.getIsVerticalTabsModeEnabled(),
      r = this.sidecarByWindowId[e];
    this.sidecarAppearanceService.pinSidecar(
      e,
      r?.mode,
      t && r?.mode === "sessions" ? "slim" : "default"
    ),
      this.emitter.emit("sidecar-changed", e, null);
  }
  unpinSidecar(e) {
    this.sidecarAppearanceService.unpinSidecar(e),
      this.emitter.emit("sidecar-changed", e, null);
  }
  togglePinSidecar(e) {
    let t = this.sidecarByWindowId[e],
      r = this.sidecarAppearanceService.getIsVerticalTabsModeEnabled();
    t?.mode === "sessions" &&
      (this.sidecarAppearanceService.toggleSidecarPinned(
        e,
        t.mode,
        r && t.mode === "sessions" ? "slim" : "default"
      ),
      this.emitter.emit("sidecar-changed", e, null));
  }
  hideSidecar(e, t) {
    if (typeof t == "number") {
      this.sidecarAppearanceService.hideSidecarWithTimeout(e, t);
      return;
    }
    this.sidecarAppearanceService.hideSidecar(e);
  }
  closeSidecar(e) {
    (this.sidecarByWindowId = Ie(this.sidecarByWindowId, e)),
      this.sidecarAppearanceService.hideSidecar(e),
      this.emitter.emit("sidecar-changed", e, null);
  }
  showLastOpenedSidecar(e) {
    this.showSidecar(e, this.sidecarByWindowId[e] || bF);
  }
  showSidecar(e, t) {
    this.sidecarByWindowId[e] = t;
    let r = this.sidecarAppearanceService.getIsVerticalTabsModeEnabled(),
      i = t.mode === "sessions" && r,
      s = this.sidecarAppearanceService.isSidecarPinned(e);
    this.sidecarAppearanceService.showSidecar(
      e,
      t.mode,
      i && s ? "slim" : "default"
    ),
      this.emitter.emit("sidecar-changed", e, t),
      this.toggleFullscreen(e, !1, !0);
  }
  async toggleSidecar(e, t) {
    let r = t ?? (await this.browserService.getLastFocusedWindowId());
    if (r === void 0) return;
    if (this.sidecarByWindowId[r]?.mode === e.mode) {
      this.sidecarAppearanceService.unpinSidecar(r), this.closeSidecar(r);
      return;
    }
    gF.includes(e?.mode) && this.sidecarAppearanceService.pinSidecar(r),
      this.showSidecar(r, e);
  }
  async loadLastActiveView() {
    this.lastActiveView =
      (await this.browserStorage.getItem("sidecar-last-active-view")) ?? null;
  }
  updateLastActiveView(e) {
    (this.lastActiveView = e),
      this.browserStorage.setItem("sidecar-last-active-view", e).catch(l);
  }
};
c();
var Fd = "special-offer-popup-alarm",
  Md = class {
    constructor(e, t, r, i, s, a, n) {
      this.billingApi = e;
      this.featureFlagsRepository = t;
      this.billingRepository = r;
      this.browserStorage = i;
      this.browserService = s;
      this.analyticsTracker = a;
      se.on("billing-plan-loaded", () => {
        this.tryEnable().catch(l);
      }),
        t.onFeatureFlagsLoaded(() => {
          this.tryEnable().catch(l);
        }),
        n.subscribeToAlarm((p) => {
          p.name === Fd && this.showYearlyOfferPopup();
        }),
        this.loadVisibleFromStorage().catch(l);
    }
    emitter = new A();
    shouldBeVisible = !1;
    switchFromMonthlyToYearlyPlan() {
      this.closeYearlyOfferPopup();
      let {
        yearlyPlan: { planId: e },
      } = this.billingApi.getPlansForUpgrade();
      return (
        this.analyticsTracker.sendAnalyticsEvent(
          "monetization.yearly-plan-hint.clicked",
          void 0
        ),
        this.billingApi.openUpgradePlanTab(e)
      );
    }
    getShouldBeVisible() {
      return this.shouldBeVisible;
    }
    closeYearlyOfferPopup() {
      (this.shouldBeVisible = !1),
        this.emitter.emit("close-offer-popup"),
        this.saveVisibleToStorage().catch(l);
    }
    subscribeToCloseOfferPopup(e) {
      return this.emitter.on("close-offer-popup", e);
    }
    subscribeToOpenOfferPopup(e) {
      return this.emitter.on("open-offer-popup", e);
    }
    showYearlyOfferPopup() {
      (this.shouldBeVisible = !0),
        this.emitter.emit("open-offer-popup"),
        this.analyticsTracker.sendAnalyticsEvent(
          "monetization.yearly-plan-hint.shown",
          void 0
        ),
        this.saveVisibleToStorage().catch(l);
    }
    disable() {
      return (
        this.closeYearlyOfferPopup(), this.browserService.clearAlarmByName(Fd)
      );
    }
    async tryEnable() {
      if (
        !this.featureFlagsRepository.getFeatureFlag("yearlyOfferPopupEnabled")
      )
        return this.disable();
      if (
        !this.billingRepository.getIsMonthlyPaid() ||
        this.billingRepository.getIsTeam()
      )
        return this.disable();
      let { intervalInDays: t } =
          this.featureFlagsRepository.getFeatureFlag("yearlyOfferPopup"),
        r = t * 24 * 60;
      return (
        (await this.browserService.getAlarmByName(Fd))?.periodInMinutes === r ||
          this.browserService.createAlarm(Fd, { periodInMinutes: r }),
        Promise.resolve()
      );
    }
    saveVisibleToStorage() {
      return this.shouldBeVisible
        ? this.browserStorage.setItem("billing-yearly-offer-visible", !0)
        : this.browserStorage.removeItem("billing-yearly-offer-visible");
    }
    async loadVisibleFromStorage() {
      (await this.browserStorage.getItem("billing-yearly-offer-visible")) &&
        this.showYearlyOfferPopup();
    }
  };
c();
c();
var xd = class {
  constructor(e, t, r) {
    this.browserService = e;
    this.browserServiceEvents = t;
    this.PREFIX = r.getUserId();
  }
  PREFIX;
  clear() {
    return this.browserService.clearLocalBrowserStorage();
  }
  async getGlobalItem(e) {
    return (await this.browserService.getFromLocalBrowserStorage(e))[e];
  }
  async getGlobalItemFromSyncStorage(e) {
    return (await this.browserService.getFromSyncBrowserStorage(e))[e];
  }
  async getAllItems() {
    return await this.browserService.getFromLocalBrowserStorage(null);
  }
  async getItem(e) {
    return this.getGlobalItem(this.getPrefixedKey(e));
  }
  async getItemFromSyncStorage(e) {
    return this.getGlobalItemFromSyncStorage(this.getPrefixedKey(e));
  }
  async setGlobalItem(e, t) {
    return this.browserService.saveIntoLocalBrowserStorage({ [e]: t });
  }
  async setItem(e, t) {
    return this.setGlobalItem(this.getPrefixedKey(e), t);
  }
  async setGlobalItemToSyncStorage(e, t) {
    return this.browserService.saveIntoSyncBrowserStorage({ [e]: t });
  }
  async setItemToSyncStorage(e, t) {
    return this.setGlobalItemToSyncStorage(this.getPrefixedKey(e), t);
  }
  async removeGlobalItem(e) {
    return this.browserService.removeFromLocalBrowserStorage(e);
  }
  async removeGlobalItemFromSyncStorage(e) {
    return this.browserService.removeFromSyncBrowserStorage(e);
  }
  async removeItemFromSyncStorage(e) {
    return this.removeGlobalItemFromSyncStorage(this.getPrefixedKey(e));
  }
  async removeItem(e) {
    return this.removeGlobalItem(this.getPrefixedKey(e));
  }
  subscribe(e, t, r = !1, i = "local") {
    return this.browserServiceEvents.subscribeToBrowserStorageChanged(
      (s, a) => {
        if (a !== i) return;
        let n = s[r ? e : this.getPrefixedKey(e)];
        n && t(n.newValue);
      }
    );
  }
  getStorageSize(e = null) {
    return this.browserService.getLocalBrowserStorageSize(e);
  }
  getPrefixedKey(e) {
    return `${this.PREFIX}_${e}`;
  }
};
c();
c();
c();
var ge = class {};
var Wd = class extends ge {
  shouldRun() {
    return !0;
  }
  async prepare() {}
  migrate(e) {
    return e.removeItem("features");
  }
};
c();
var Gk = ((N) => (
    (N.LAST_OLD_EXTENSION_VERSION = "last-ext-version"),
    (N.AUTH_STATE = "auth-state"),
    (N.THEME = "theme"),
    (N.ANONYMOUS_ID_KEY = "anonymous-id"),
    (N.PRINT_ANALYTICS_TO_CONSOLE = "PRINT_ANALYTICS_TO_CONSOLE"),
    (N.SHORTCUTS_ARE_OVERRIDDEN = "shortcuts-are-overridden"),
    (N.CRASHES_LAST_SENT = "crashes-last-sent"),
    (N.EXTENSION_KICKED = "extension-kicked"),
    (N.CPU_MONITOR_ALARM_IGNORED_AT = "cpu-monitor-alarm-ignored-at"),
    (N.IS_HISTORY_AND_BOOKMARKS_IMPORTED =
      "user-has-already-imported-history-and-bookmarks"),
    (N.BG_INITED_KEY = "bg-inited"),
    (N.WALLPAPER_LS_KEY = "wallpaper-cached"),
    (N.Accounts = "accounts"),
    (N.AccountsMigrated = "accounts-migrated"),
    (N.ActualUsage = "actual-usage"),
    (N.AppAccounts = "app-accounts"),
    (N.AppCurrentAccounts = "app-current-accounts"),
    (N.ApplicationsSafeRecipes = "applications-safe-recipes"),
    (N.AppSettings = "app-settings"),
    (N.BackendCachePrefix = "backend_cache_"),
    (N.CalendarsPermissions = "calendars-permissions"),
    (N.CalendarsSetupShown = "calendars-setup-shown"),
    (N.ChecklistCompleted = "checklist-completed"),
    (N.Credentials = "credentials"),
    (N.CredentialsPairs = "credentials-pairs"),
    (N.Explored = "explored"),
    (N.ExternalAuthCredentials = "external-auth-credentials-by-type"),
    (N.FocusModeHint = "focus-mode-hint"),
    (N.HeadlessHint = "headless-hint"),
    (N.LimitPopupShowAt = "limit-popup-show-at"),
    (N.PmfSurveyBanner = "pmf-survey-banner"),
    (N.SchedulerHistory = "scheduler-history"),
    (N.SessionActiveId = "session-active-id"),
    (N.SessionLinksPrefix = "session-links-"),
    (N.SessionList = "session-list"),
    (N.SessionLastUsed = "session-last-used"),
    (N.SessionLinksLastUsed = "session-links-last-used"),
    (N.SessionTabsMigrated = "session-tabs-migrated"),
    (N.SessionNameMigrated = "session-name-migrated"),
    (N.SessionTabsUrlMigrated = "session-tabs-url-migrated"),
    (N.SidebarSizeMigrated = "sidebar-size-migrated"),
    (N.ShortcutUserReport = "shortcut-used-report"),
    (N.Stage3Enabled = "stage-3-enabled"),
    (N.UserActivated = "user-activated"),
    (N.WallpaperInfo = "wallpaper-info"),
    (N.LastSplitPanelApp = "last-split-panel-app"),
    N
  ))(Gk || {}),
  Dd = class extends ge {
    shouldRun(e) {
      return e === 0;
    }
    async prepare() {}
    async migrate(e) {
      if (!localStorage || !window) return;
      let t = this.getUserIdFromLS(),
        r = Object.values(Gk),
        i = Object.keys(localStorage).reduce(
          (s, a) => (
            r.find((p) => a.includes(p) || a.includes(`${t}_${p}`))
              ? s.push(a)
              : localStorage.removeItem(a),
            s
          ),
          new Array()
        );
      await Promise.all(
        i.map(async (s) => {
          let a = Oe(localStorage.getItem(s));
          return a ? e.setGlobalItem(s, a) : Promise.resolve();
        })
      );
    }
    getUserIdFromLS() {
      let e = localStorage.getItem("auth-state")?.split(".")[1];
      if (!e) return "";
      let t = atob(e),
        r = Oe(t);
      return r ? r.uuid : "";
    }
  };
c();
var By = "session-list",
  vF = "session-list-v2-migrated",
  Hk = "session-last-used",
  fF = "session-list-v2",
  Ud = class extends ge {
    shouldRun(e, t) {
      return e < 2 && t >= 2;
    }
    async prepare() {}
    async migrate(e) {
      let t = (await e.getItem(By)) ?? [];
      if (!t.length) {
        await e.removeItem(By), await e.removeItem(vF);
        return;
      }
      let r = (a) => Boolean(a.workspaceId) && !a.name,
        i = t.map((a) => {
          let n = {
            name: a.name ?? "Untitled",
            workspaceId: a.workspaceId,
            id: a.savedId,
            lastTimeUsed: a.wasActivatedAt,
            isTemporary: Boolean(a.isTemporary),
            lastActiveSessionTabId: a.lastActiveSessionTabId,
          };
          return r(a)
            ? { ...n, id: a.workspaceId, name: "Personal workspace" }
            : n;
        }),
        s = await e.getItem(Hk);
      if (s) {
        let a = i.find((n) => n.id === s.savedId);
        a && (await e.setItem(Hk, a));
      }
      await e.setItem(fF, i), await e.removeItem(By);
    }
  };
c();
var Od = class extends ge {
  shouldRun(e, t) {
    return e < 3 && t >= 3;
  }
  async prepare() {}
  migrate(e) {
    return e.removeItem("notifications-token");
  }
};
c();
var SF = "session-list-v2",
  wF = "session-links-last-used",
  kF = "session-links-",
  jd = class extends ge {
    shouldRun(e, t) {
      return e < 4 && t >= 4;
    }
    async prepare() {}
    async migrate(e) {
      let t = Object.keys(await e.getAllItems()),
        i = (await e.getItem(SF))?.map((a) => a.id),
        s = t.reduce((a, n) => {
          if (!n.match(wF) && n.match(kF)) {
            let p = n.split("_session-links-").at(-1);
            p && !i?.includes(p) && a.push(n);
          }
          return a;
        }, []);
      await Promise.all(s.map((a) => e.removeGlobalItem(a)));
    }
  };
c();
var Nd = class extends ge {
  shouldRun(e, t) {
    return e < 5 && t >= 5;
  }
  async prepare() {}
  migrate(e) {
    return e.removeItem("last-split-panel-app");
  }
};
c();
var Ld = class extends ge {
  shouldRun(e, t) {
    return e < 6 && t >= 6;
  }
  async prepare() {}
  async migrate(e) {
    return (
      await e.removeItem("default-browser-notification-was-showed"),
      e.removeItem("default-browser-prompt-count")
    );
  }
};
c();
var Gd = class extends ge {
  shouldRun(e, t) {
    return e < 15 && t >= 15;
  }
  async prepare() {}
  async migrate(e) {
    await Promise.all([
      e.removeItem("product-hunt-date"),
      e.removeItem("product-hunt-state"),
    ]);
  }
};
c();
var Hd = class extends ge {
  shouldRun(e, t) {
    return e < 8 && t >= 8;
  }
  async prepare() {}
  migrate(e) {
    return e.removeItem("notifications-token");
  }
};
c();
var Vd = class extends ge {
  shouldRun(e, t) {
    return e < 9 && t >= 9;
  }
  async prepare() {}
  migrate(e) {
    return e.removeItem("sidecar-last-fullscreen-state");
  }
};
c();
var $d = class extends ge {
  shouldRun(e, t) {
    return e < 10 && t >= 10;
  }
  async prepare() {}
  migrate(e) {
    return e.removeItem("billing-show-start-trial-alarm");
  }
};
c();
var Kd = class extends ge {
  shouldRun(e, t) {
    return e < 11 && t >= 11;
  }
  async prepare() {}
  async migrate(e) {
    let t = await e.getGlobalItem("anonymous-id");
    t &&
      (await e.removeGlobalItem("anonymous-id"),
      await e.setGlobalItem("anonymous-meta-info", {
        anonymousId: t,
        extra: {},
      }));
  }
};
c();
var qd = class extends ge {
  shouldRun(e, t) {
    return e < 12 && t >= 12;
  }
  async prepare() {}
  async migrate(e) {
    let t = await e.getItem("external-auth-credentials-by-type");
    if (!t) return;
    let r = t;
    await e.setItem("external-auth-credentials-by-type", {
      ["google"]: { CALENDAR: r.google, CONTACTS: {}, EMAIL_SIGNATURES: {} },
      ["slack"]: { CALENDAR: {}, CONTACTS: {}, EMAIL_SIGNATURES: {} },
    });
  }
};
c();
var Vk = "session-list-v2",
  $k = "session-links-",
  Kk = "session-tab-groups",
  TF = "session-last-used",
  IF = "session-links-last-used",
  AF = "session-list-v2-migrated",
  PF = "session-tabs-migrated",
  RF = "session-name-migrated",
  EF = "session-tabs-url-migrated",
  BF = "session-active-id",
  CF = "session-workspace-id-migrated",
  zd = class extends ge {
    shouldRun(e, t) {
      return e < 13 && t >= 13;
    }
    async prepare() {}
    async migrate(e) {
      let t = (await e.getItem(Vk)) ?? [],
        r = {},
        i = t.map(async (p) => {
          let d = await e.getItem(`${$k}${p.id}`);
          (r[p.id] =
            d?.map((u) => this.mapSaveableSessionTabToSessionTab(u, p.id)) ??
            []),
            await e.removeItem(`${$k}${p.id}`);
        }),
        s = (await e.getItem(Kk)) ?? {};
      await Promise.all(i);
      let a = {};
      t.forEach((p) => {
        let d = r[p.id] ?? [],
          u = d?.reduce((v, S) => ((v[S.id] = this.mapOldTabToNew(S)), v), {}),
          m = Object.values(s[p.id] ?? []).reduce(
            (v, S) => ((v[S.id] = this.mapOldGroupToNew(S)), v),
            {}
          ),
          y = d.map((v) => v.id),
          b = Object.keys(m).reduce((v, S) => {
            let w = d.filter((T) => T.sessionTabGroupId === S).map((T) => T.id);
            return (v[S] = w), v;
          }, {});
        a[p.id] = {
          name: p.name,
          isTemporary: !1,
          id: p.id,
          workspaceId: p.workspaceId,
          lastTimeUsed: p.lastTimeUsed ?? 0,
          lastActiveSessionTabId: p.lastActiveSessionTabId,
          tabsById: u,
          tabsOrder: y,
          tabGroupsById: m,
          tabsByGroupId: b,
        };
      });
      let n = [
        e.removeItem(Vk),
        e.removeItem(Kk),
        e.removeItem(TF),
        e.removeItem(IF),
        e.removeItem(AF),
        e.removeItem(PF),
        e.removeItem(RF),
        e.removeItem(EF),
        e.removeItem(BF),
        e.removeItem(CF),
      ];
      return await Promise.all(n), e.setItem("sessions", a);
    }
    mapOldGroupToNew(e) {
      return {
        id: e.id,
        browserId: e.tabStripId,
        color: e.color,
        collapsed: e.collapsed,
        title: e.title ?? "",
      };
    }
    mapOldTabToNew(e) {
      return {
        id: e.id,
        url: e.url,
        favIconUrl: e.favIconUrl,
        browserId: e.tabId,
        pinned: e.pinned,
        partitionId: e.partitionId,
        title: e.title,
      };
    }
    mapSaveableSessionTabToSessionTab(e, t) {
      return {
        id: e.savedId,
        url: e.url ?? "",
        favIconUrl: e.favIconUrl,
        title: e.title,
        partitionId: e.partition,
        pinned: e.pinned,
        sessionId: e.sessionId ?? t,
        sessionTabGroupId: e.tabGroupId,
      };
    }
  };
c();
var Qd = class extends ge {
  shouldRun(e, t) {
    return e < 14 && t >= 14;
  }
  async prepare() {}
  async migrate(e) {
    let t = await e.getItem("external-auth-credentials-by-type");
    t &&
      (await e.setItem("external-auth-credentials-by-type", {
        ["google"]: {
          CALENDAR: t.google.CALENDAR,
          CONTACTS: t.google.CONTACTS,
          EMAIL_SIGNATURES: {},
        },
        ["slack"]: {
          CALENDAR: t.slack.CALENDAR,
          CONTACTS: t.slack.CONTACTS,
          EMAIL_SIGNATURES: {},
        },
      }));
  }
};
var Yd = class {
  constructor(e, t, r, i, s) {
    this.browserStorage = e;
    this.newStorageVersion = r;
    this.newExtVersion = s;
    i && this.migrations.push(...this.cacheInvalidationMigrations),
      (this.migrations = this.migrations.filter((a) => a.shouldRun(t, r)));
  }
  migrations = [
    new Dd(),
    new Ud(),
    new Od(),
    new jd(),
    new Nd(),
    new Ld(),
    new Gd(),
    new Hd(),
    new Vd(),
    new $d(),
    new Kd(),
    new qd(),
    new zd(),
    new Qd(),
  ];
  cacheInvalidationMigrations = [new Wd()];
  async run() {
    return await this.prepare(), await this.migrate(), this.updateVersion();
  }
  prepare() {
    return Promise.all(
      this.migrations.map((e) => e.prepare(this.browserStorage))
    );
  }
  migrate() {
    return Promise.all(
      this.migrations.map((e) => e.migrate(this.browserStorage))
    );
  }
  updateVersion() {
    return Promise.all([
      this.browserStorage.setGlobalItem("version", this.newStorageVersion),
      this.browserStorage.setGlobalItem(
        "extension-version",
        this.newExtVersion
      ),
    ]);
  }
};
c();
var Xd = class {
  constructor(e) {
    this.browserStorage = e;
  }
  QUOTA_BYTES = 5242880;
  logger = x.createInstance("storage");
  async generateReport(e) {
    let t = (await this.browserStorage.getItem("size-bytes")) ?? 0,
      r = await this.browserStorage.getStorageSize();
    r >= this.QUOTA_BYTES &&
      this.logger.error(
        new L("Storage size is too big.", {
          extra: { sizeInBytes: r },
          level: "warning",
        })
      );
    let i = r - t;
    this.logger.info(`Storage size is: ${r} bytes. Changed to: ${i} bytes.`);
    let s = { version: e, sizeInBytes: r, sizeBeforeMigrationInBytes: t };
    return await this.browserStorage.setItem("size-bytes", r), s;
  }
  async trackFirstMigration(e) {
    let t = 0;
    if (
      (localStorage &&
        Object.keys(localStorage).forEach((s) => {
          if (!Object.hasOwn(localStorage, s)) return;
          let a =
            (Number(localStorage.getItem(s)?.length) + Number(s.length)) * 2;
          t += a;
        }),
      await e(),
      !t)
    )
      return;
    let r = await this.browserStorage.getStorageSize(),
      i = r - t;
    this.logger.info(
      `After first migration: LocalStorage was: ${t} bytes, chromeStorage became ${r} bytes, diff: ${i}`
    ),
      i > 0 &&
        this.logger.error(
          new L(
            "Storage growth after migration from localStorage to chromeStorage.",
            {
              extra: { localStorageInBytes: t, chromeStorageInBytes: r },
              level: "warning",
            }
          )
        );
  }
};
var qk = 15,
  zk = async (o, e, t, r) => {
    let i = r.startChild(Ee.INIT_STORAGE),
      s = new xd(o, e, t),
      a = new Xd(s),
      [n = 0, p] = await Promise.all([
        s.getGlobalItem("version"),
        s.getGlobalItem("extension-version"),
      ]),
      d = o.getManifestVersion(),
      u = d !== p,
      m = new Yd(s, n, qk, u, d);
    if (n === 0)
      try {
        await a.trackFirstMigration(m.run.bind(m));
      } catch (v) {
        l(v), await s.clear(), await t.signOut();
      }
    else {
      let v = i.startChild(Ee.STORAGE_MIGRATIONS);
      await m.run(), v.finish();
    }
    let y = i.startChild(Ee.STORAGE_REPORT),
      b = await a.generateReport(qk);
    return y.finish(), i.finish(), { browserStorage: s, storageReport: b };
  };
c();
c();
var Qk = (o) => (g(!o, "Storage is empty"), !0),
  Cy = (o) =>
    new Promise((e) => {
      o.getBytesInUse(e);
    }).then(Qk),
  Yk = async (o) => {
    if (
      !(o
        ? globalThis.localStorage.length === 0
        : globalThis.localStorage.length <= 1)
    )
      return !1;
    try {
      return (
        await Promise.all([
          eb().then((r) => Qk(r.length)),
          Cy(chrome.storage.local),
          Cy(chrome.storage.sync),
          Cy(chrome.storage.managed),
        ])
      ).every(Boolean);
    } catch (t) {
      if (t instanceof Co) return !1;
      throw t;
    }
  };
var _F = ["x86-64/translated", "arm64"],
  go = class {
    constructor(e, t, r, i, s, a, n, p, d, u, m, y, b, v, S, w, T, I) {
      this.extensionVersion = e;
      this.browserVersion = t;
      this.deviceId = r;
      this.locale = i;
      this.userAgent = s;
      this.timezone = a;
      this.cpuArchitecture = n;
      this.isMac = p;
      this.isMacM1 = d;
      this.isWindows = u;
      this.isLinux = m;
      this.os = y;
      this.screen = b;
      this.versionInfo = v;
      this.isFirstStart = S;
      this.isSidekickTeam = w;
      this.anonymousId = T;
      this.extraIds = I;
    }
    static async build(e, t, r) {
      let i = this.getExtensionVersion(e),
        [s, a, n, p, d, u, { anonymousId: m, extra: y }] = await Promise.all([
          this.getBrowserVersion(e),
          this.getDeviceId(e),
          e.getCPUArchitecture(),
          this.getVersionInfo(e),
          Yk(!1),
          la(),
          this.loadAnonymousMetaInfo(t, r),
        ]),
        {
          isMac: b,
          isMacM1: v,
          isWindows: S,
          isLinux: w,
        } = this.getPlatform(n),
        T = this.getScreen(),
        I = {
          name: n.osName,
          version: this.isWindows11(n.osVersion) ? "11.0" : n.osVersion,
        };
      return new go(
        i,
        s,
        a,
        navigator.language,
        navigator.userAgent,
        Intl.DateTimeFormat().resolvedOptions().timeZone,
        n?.architecture ?? null,
        b,
        v,
        S,
        w,
        I,
        T,
        p,
        d,
        u,
        m,
        y
      );
    }
    static getExtensionVersion(e) {
      return e.getManifestVersion();
    }
    static async getBrowserVersion(e) {
      return e.getBrowserVersionFromSidekick();
    }
    static async getDeviceId(e) {
      return { value: await e.getDeviceId(), fresh: !1 };
    }
    static getScreen() {
      let { height: e, width: t } = window.screen,
        r =
          window.devicePixelRatio && !Number.isNaN(window.devicePixelRatio)
            ? window.devicePixelRatio
            : 1;
      return { height: e, width: t, density: r };
    }
    static getPlatform(e) {
      let t = e.platform.toLowerCase(),
        r = /mac/i.test(t),
        i = r && this.isMacM1(e);
      return {
        isLinux: /linux/i.test(t),
        isWindows: /win/i.test(t),
        isMac: r,
        isMacM1: i,
      };
    }
    static isMacM1(e) {
      return e.platform === "Mac" && _F.includes(e.architecture);
    }
    static isWindows11(e) {
      if (!e) return !1;
      let t = e.split(".");
      return Number(t[0]) >= 10 && Number(t[2]) >= 22e3;
    }
    static async getVersionInfo(e) {
      let t = await e.getVersionInfo();
      return Oe(t) ?? {};
    }
    static async loadAnonymousMetaInfo(e, t) {
      let r = await e.getGlobalItem("anonymous-meta-info"),
        i = t.getAnonymousMetaInfo();
      !r && i && (await e.setGlobalItem("anonymous-meta-info", i));
      let s = r || i,
        a = s?.anonymousId ?? globalThis.crypto.randomUUID(),
        n = s?.extra ?? {};
      return { anonymousId: a, extra: n };
    }
  };
c();
var Jd = class {
  constructor(e, t) {
    this.browserService = e;
    this.browserEventsService = t;
    this.init().catch(l);
  }
  tabs = {};
  activeTabs = {};
  focusedWindowId = null;
  getAllTabsInfoById() {
    return this.tabs;
  }
  getTabInfoById(e) {
    return e ? this.tabs[e] ?? null : null;
  }
  initializeTab(e) {
    return {
      isFullActive: e.active && e.windowId === (this.focusedWindowId ?? -1),
      isSemiActive: e.active && e.windowId !== (this.focusedWindowId ?? -1),
      wasActivatedAt: e.discarded ? null : Date.now(),
      wasAudibleAt: null,
      tabHostnameChangedAt: null,
      tabActivations: [],
      tabActivationsInLastDomain: [],
      audibleInLastDomain: [],
      hostname: At(e.pendingUrl || e.url || "") ?? null,
      wasLastActiveAt: Date.now(),
    };
  }
  async init() {
    (this.focusedWindowId =
      (await this.browserService.getLastFocusedWindowId()) ?? null),
      (this.tabs = Object.fromEntries(
        Object.entries(await this.browserService.getTabsById()).map(
          ([e, t]) => [e, this.initializeTab(t)]
        )
      )),
      this.browserEventsService.subscribeToTabActivated(
        ({ tabId: e, windowId: t }) => {
          let r = this.tabs[e];
          if (!r) return;
          let i = Date.now(),
            s = this.activeTabs[t];
          if (s) {
            let a = this.tabs[s];
            a &&
              ((a.wasLastActiveAt = i),
              (a.isFullActive = !1),
              (a.isSemiActive = !1));
          }
          (this.activeTabs[t] = e),
            (r.wasActivatedAt = i),
            (r.tabActivations = [...r.tabActivations, i]),
            (r.tabActivationsInLastDomain = [
              ...r.tabActivationsInLastDomain,
              i,
            ]),
            this.focusedWindowId &&
              ((r.isFullActive = t === this.focusedWindowId),
              (r.isSemiActive = t !== this.focusedWindowId));
        }
      ),
      this.browserEventsService.subscribeToTabUpdated((e, t) => {
        let r = this.tabs[e];
        if (!r) return;
        let i = Date.now();
        if (t.url) {
          let s = At(t.url) ?? null;
          s !== r.hostname &&
            ((r.hostname = s),
            (r.tabHostnameChangedAt = i),
            (r.tabActivationsInLastDomain = []),
            (r.audibleInLastDomain = []));
        }
        t.audible &&
          ((r.wasAudibleAt = i),
          (r.audibleInLastDomain = [...r.audibleInLastDomain, i]));
      }),
      this.browserEventsService.subscribeToTabReplaced((e, t) => {
        let r = this.tabs[t];
        r && ((this.tabs[e] = r), delete this.tabs[t]);
      }),
      this.browserEventsService.subscribeToTabCreated((e) => {
        e.id && (this.tabs[e.id] = this.initializeTab(e));
      }),
      this.browserEventsService.subscribeToTabRemoved((e) => {
        delete this.tabs[e];
      });
  }
};
c();
var Zd = class {
  constructor(e, t, r, i, s) {
    this.browserService = e;
    this.extraDataService = t;
    this.modalService = i;
    this.userSettingsRepository = s;
    (this.lastActiveTabIds = {}),
      (this.lastCreatedTabIds = {}),
      this.loadTabs().catch(l);
    let a = yt(() => this.emitter.emit("tabs-changed"), 50);
    r.subscribeToTabCreated((n) => {
      g(
        n.id,
        "Failed to handle tab creation: tab.id not found to get last active tab"
      ),
        !this.lastActiveTabIds[n.id] &&
          ((this.lastCreatedTabIds[n.id] = Date.now()), a());
    }),
      r.subscribeToTabActivated((n) => {
        (this.lastCreatedTabIds = Ie(this.lastCreatedTabIds, n.tabId)),
          (this.lastActiveTabIds[n.tabId] = Date.now()),
          a();
      }),
      r.subscribeToTabUpdated((n, p) => {
        (!("title" in p) && !("favIconUrl" in p)) || a();
      }),
      r.subscribeToTabReplaced((n, p) => {
        let d = this.lastCreatedTabIds[p];
        d &&
          ((this.lastCreatedTabIds[n] = d),
          (this.lastCreatedTabIds = Ie(this.lastCreatedTabIds, p)));
        let u = this.lastActiveTabIds[p];
        u &&
          ((this.lastActiveTabIds[n] = u),
          (this.lastActiveTabIds = Ie(this.lastActiveTabIds, p))),
          a();
      }),
      r.subscribeToTabRemoved((n) => {
        (this.lastActiveTabIds = Ie(this.lastActiveTabIds, n)), a();
      });
  }
  lastActiveTabIds;
  lastCreatedTabIds;
  currentIndex = 0;
  emitter = new A();
  onIndexChanged(e) {
    return this.emitter.on("index-changed", e);
  }
  onTabsChanged(e) {
    return this.emitter.on("tabs-changed", e);
  }
  async tryOpenPreviousTab() {
    if (this.getTabOrder(!0) !== "appearance") return;
    let { tabs: e, activeTab: t } = await this.getTabsWithActiveTab(),
      r = e.findIndex((s) => s.id === t?.id) - 1,
      i = r < 0 ? e.length + r : r;
    await this.activateTabById(e[i]?.id);
  }
  async tryOpenNextTab(e) {
    if (this.getTabOrder(e) !== "appearance") return !1;
    let { tabs: t, activeTab: r } = await this.getTabsWithActiveTab(),
      i = t.findIndex((a) => a.id === r?.id) + 1,
      s = i < t.length ? i : 0;
    return await this.activateTabById(t[s]?.id), !0;
  }
  getIndex() {
    return this.currentIndex;
  }
  incrementCurrentIndex() {
    (this.currentIndex += 1), this.emitter.emit("index-changed");
  }
  decrementCurrentIndex() {
    (this.currentIndex -= 1), this.emitter.emit("index-changed");
  }
  async resetCurrentIndex(e) {
    if (((this.currentIndex = 1), e === "appearance")) {
      let t = await this.getTabsSortedByNativeIndex();
      this.currentIndex = t.findIndex((r) => r.active) + 1;
    }
    this.emitter.emit("index-changed");
  }
  getTabOrder(e) {
    let { ctrlTabOrder: t } = this.userSettingsRepository.getSettings();
    return e ? t : "mru";
  }
  async activateSelectedTab(e, t) {
    this.modalService.closeModal(e);
    let r = t ?? (await this.getSelectedTabId(e));
    return this.browserService.activateTab(r);
  }
  closeSelectedTab(e, t) {
    return t ? this.browserService.closeTab(t) : Promise.resolve();
  }
  getTabOrderByWindowId(e) {
    let t = this.modalService.getModalForWindow(e);
    if (t?.id === "tabs-switcher") return t.payload.tabOrder;
  }
  getOpenedTabs(e) {
    return this.getTabOrderByWindowId(e) === "appearance"
      ? this.getOpenedTabsSortedByNativeIndex()
      : this.getLastUsedOpenedTabs();
  }
  async getLastUsedOpenedTabs() {
    let e = Mo(Object.entries(this.lastActiveTabIds), ([, s]) => -s).map(
        ([s]) => Number(s)
      ),
      t = Object.entries(this.lastCreatedTabIds).map(([s]) => Number(s)),
      r = await this.getOpenedTabsByIds(e),
      i = await this.getOpenedTabsByIds(t);
    return r.concat(i);
  }
  async getTabsSortedByNativeIndex() {
    let e = await this.getRelatedTabsById(),
      t = Object.values(e).filter((r) => !r.hidden);
    return Mo(t, (r) => r.index);
  }
  async getOpenedTabsSortedByNativeIndex() {
    return (await this.getTabsSortedByNativeIndex())
      .map((e) => this.mapToOpenedTab(e))
      .filter(de);
  }
  mapToOpenedTab(e) {
    if (!e.id) return null;
    let t = this.extraDataService.getTabExtraData(e)?.app;
    return {
      id: e.id,
      url: e.url || "",
      title: e.title || "",
      favIconUrl: e.favIconUrl ?? null,
      type: t
        ? P("background_tab_switcher__application")
        : P("background_tab_switcher__opened_tab"),
    };
  }
  async getOpenedTabsByIds(e) {
    let t = await this.getRelatedTabsById();
    return e
      .map((r) => {
        let i = t[r];
        return i ? this.mapToOpenedTab(i) : null;
      })
      .filter(de);
  }
  async loadTabs() {
    let e = Object.values(await this.browserService.getTabsById());
    this.lastActiveTabIds = Object.fromEntries(
      e.map((t) => (t.id ? [t.id, Date.now()] : null)).filter(de)
    );
  }
  async getSelectedTabId(e) {
    let t = await this.getOpenedTabs(e),
      r = Qt(this.currentIndex, t.length),
      i = t[r]?.id;
    return g(i, "No selected tabId"), i;
  }
  async getRelatedTabsById() {
    let e = await this.browserService.getNormalLastFocusedWindowId();
    return this.browserService.getTabsById({ windowId: e });
  }
  async activateTabById(e) {
    e && (await this.browserService.activateTab(e));
  }
  async getTabsWithActiveTab() {
    let e = await this.getTabsSortedByNativeIndex(),
      t = await this.browserService.getActiveTab();
    return { tabs: e, activeTab: t };
  }
};
c();
var eu = class {
  constructor(e, t, r) {
    this.browserService = e;
    this.browserEventsService = t;
    this.extraDataService = r;
    this.browserEventsService.subscribeToNormalWindowCreated(async (i) => {
      await this.discardAllTabsExcludeActiveAndNTP(i.id);
    }),
      this.discardMissedWindows().catch(l);
  }
  discardedDomainsByTabId = new Map();
  getDiscardedTabsDomains() {
    return this.discardedDomainsByTabId;
  }
  removeDiscardedDomainByTabId(e) {
    this.discardedDomainsByTabId.delete(e);
  }
  changeTabId(e, t) {
    let r = this.discardedDomainsByTabId.get(e);
    r &&
      (this.discardedDomainsByTabId.delete(e),
      this.discardedDomainsByTabId.set(t, r));
  }
  async discardMissedWindows() {
    this.browserEventsService.missedWindowsFromOnCreated.length > 0 &&
      (await this.discardAllTabsExcludeActiveAndNTP());
  }
  async discardAllTabsExcludeActiveAndNTP(e) {
    let r = (
      await this.browserService.getAllTabs({ discarded: !1, windowId: e })
    ).map(async (i) => {
      if (
        i.active ||
        !i.id ||
        !i.url ||
        this.browserService.isNTP(i.url) ||
        this.getIsTabApp(i)
      )
        return;
      let s = At(i.url);
      s && this.discardedDomainsByTabId.set(i.id, s),
        await this.browserService.discardTabById(i.id);
    });
    return Promise.all(r);
  }
  getIsTabApp(e) {
    let t = this.extraDataService.getTabExtraData(e)?.app ?? null;
    return Boolean(t);
  }
};
c();
var Xk = { locals: [], globals: [] },
  Ae = class {
    constructor(e, t, r, i, s, a, n, p, d, u, m) {
      this.applicationRepository = e;
      this.browserService = t;
      this.browserEventsService = r;
      this.connectionService = i;
      this.extraDataService = s;
      this.featureFlagsRepository = a;
      this.recipesRepository = n;
      this.tabInfoFollowerService = p;
      this.searchService = d;
      this.userSettingsRepository = u;
      this.startupTabsDiscarderService = m;
      let y = (v) => {
          delete this.checkResultsByTabId[v],
            this.emitter.emit("stats-updated");
        },
        b = (v) => {
          this.startupTabsDiscarderService.removeDiscardedDomainByTabId(v),
            this.checkResultsByTabId[v] && y(v);
        };
      d.domainStatistic.onDomainsStatistic((v) => {
        this.domainsStatistic = v;
      }),
        this.browserEventsService.subscribeToTabRemoved(b),
        this.browserEventsService.subscribeToTabActivated((v) => b(v.tabId)),
        this.browserEventsService.subscribeToTabReplaced((v, S) => {
          (this.checkResultsByTabId[v] = this.checkResultsByTabId[S] ?? null),
            this.startupTabsDiscarderService.changeTabId(S, v),
            y(S);
        }),
        W.on("user-settings-changed", this.setDiscarderSettings.bind(this)),
        this.setDiscarderSettings();
    }
    emitter = new A();
    logger = x.createInstance("tabs_discarder");
    checkResultsByTabId = {};
    domainsStatistic = {};
    discarderSettings = null;
    runInterval = null;
    customRunInterval = null;
    customMinutesBeforeDiscard = null;
    tabs = [];
    splitState = Xk;
    static resolve(e) {
      return { value: !0, reason: e };
    }
    static reject(e) {
      return { value: !1, reason: e };
    }
    getDiscardedTabsInfo() {
      return this.checkResultsByTabId;
    }
    getStats() {
      return Object.values(this.checkResultsByTabId).reduce(
        (t, r) => {
          let i = r?.memoryBeforeDiscard;
          return i
            ? {
                discardedTabsCount: t.discardedTabsCount + 1,
                savedTabsMemory: t.savedTabsMemory + i,
              }
            : t;
        },
        { discardedTabsCount: 0, savedTabsMemory: 0 }
      );
    }
    onStatsUpdated(e) {
      return this.emitter.on("stats-updated", e);
    }
    setCustomTimeouts(e, t = null) {
      (this.customRunInterval = e),
        (this.customMinutesBeforeDiscard = t),
        this.setDiscarderSettings();
    }
    setDiscarderSettings() {
      let e = this.userSettingsRepository.getSettings();
      this.runInterval && clearInterval(this.runInterval);
      let t = this.customRunInterval || e.minutesBeforeDiscard,
        r = this.customMinutesBeforeDiscard || e.minutesBeforeDiscard;
      e.disableDiscarding
        ? this.logger.info("Logger disabled")
        : this.logger.info(
            `Settings changed. Run interval: ${t} minutes. Discard tab after: ${r} minutes`
          ),
        (this.runInterval = setInterval(() => {
          this.checkAllTabs().catch(l);
        }, ye(Number(t)))),
        (this.discarderSettings = {
          whitelistDomains: e.noneDiscardableDomains,
          enabled: !e.disableDiscarding,
          minutesBeforeDiscard: r,
        });
    }
    getIsServiceTab(e) {
      return Boolean(this.getAppIdFromTab(e));
    }
    getIsSite(e) {
      return e.url?.startsWith("http") ?? !1;
    }
    getAppIdFromTab(e) {
      return this.extraDataService.getTabExtraData(e)?.app ?? null;
    }
    getAppFromTab(e) {
      let t = this.getAppIdFromTab(e);
      return t ? this.applicationRepository.getAppById(t) : null;
    }
    getIsServiceDeniedUnload(e) {
      return this.getAppFromTab(e)?.recoverClosed ?? null;
    }
    getIsMessengerApp(e) {
      let t = this.getAppFromTab(e);
      return t
        ? this.recipesRepository.getRecipeForApp(t).isMessagingApp ?? !1
        : !1;
    }
    domainIsInWhitelist(e) {
      let t = this.discarderSettings?.whitelistDomains,
        r = Vt(e.url || e.pendingUrl || "");
      return !t || !r ? !1 : t.some((i) => Qs(r, i));
    }
    isImportant(e) {
      return this.getIsMessengerApp(e) || this.domainIsInWhitelist(e);
    }
    getCountMoreThan(e, t) {
      return e.filter((r) => r >= t).length;
    }
    lastAccessSecondsAgo(e, t) {
      return Fo(t, e);
    }
    getOpenRank(e) {
      return (
        g(e, "Failed to get open rank: no tabId"),
        db(
          this.tabs,
          [
            (r) =>
              this.tabInfoFollowerService.getTabInfoById(r.id)
                ?.wasActivatedAt || 0,
          ],
          ["desc"]
        ).findIndex((r) => r.id === e) + 1 || 1 / 0
      );
    }
    wasUsedRecently(e, t, r) {
      let i = Ue(ye(Number(this.discarderSettings?.minutesBeforeDiscard))),
        { whitelistKeepSeconds: s } = this.getModelSettings(),
        a = !this.domainIsInWhitelist(r) || !this.getIsMessengerApp(r) ? i : s;
      return (this.lastAccessSecondsAgo(e, t) ?? 0) < (a ?? 1 / 0);
    }
    getIsInSplitView(e) {
      let t = e.id;
      return (
        this.splitState.locals.some(
          (r) => r.splitPair.left === t || r.splitPair.right === t
        ) || this.splitState.globals.some((r) => r.tabId === t)
      );
    }
    getIsNeedToBeForceDiscarded(e, t) {
      let { forceDiscardAfterSeconds: r } = this.getModelSettings();
      return (this.lastAccessSecondsAgo(e, t) || 0) > (r || 0);
    }
    canBeDiscarded(e, t, r) {
      let i = new Date(t?.wasActivatedAt ?? "").toLocaleString(),
        s = this.isImportant(e)
          ? `Tab ${
              this.getIsMessengerApp(e)
                ? "is a messenger"
                : "has a whitelisted domain"
            } and`
          : "Tab";
      if (e.discarded) {
        let p = e.id ? this.checkResultsByTabId[e.id]?.lastReason : null;
        return Ae.reject(p || "Tab is externally discarded already");
      }
      if (e.active) return Ae.reject("Tab is active now");
      if (this.getIsInSplitView(e)) return Ae.reject("Tab in split view");
      if (
        me.NODE_ENV !== "development" &&
        !this.getIsServiceTab(e) &&
        !this.getIsSite(e) &&
        this.getIsNeedToBeForceDiscarded(r, t?.wasActivatedAt ?? null)
      )
        return e.id
          ? (this.browserService.closeTab(e.id).catch(l),
            Ae.reject("Tab is service. It is closed"))
          : Ae.reject("Can't close. No id for service tab.");
      if (this.getIsServiceTab(e) && this.getIsServiceDeniedUnload(e))
        return Ae.reject(
          "Tab can't be unloaded because related service disallow it"
        );
      if (e.audible) return Ae.reject("Tab is audible now");
      if (this.wasUsedRecently(r, t?.wasActivatedAt ?? null, e))
        return Ae.reject(`${s} was used recently (${i})`);
      if (this.isImportant(e))
        return Ae.reject(`${s} wasn't used recently (${i})`);
      let a = new Date(t?.wasAudibleAt ?? "").toLocaleString();
      if (
        (this.lastAccessSecondsAgo(r, t?.wasAudibleAt ?? null) || 1 / 0) < 30 ||
        e.audible ||
        (t?.audibleInLastDomain.length ?? 0) > 0
      )
        return Ae.reject(`${s} was audible recently (${a})`);
      if (this.getIsNeedToBeForceDiscarded(r, t?.wasActivatedAt ?? null)) {
        let { forceDiscardAfterSeconds: p } = this.getModelSettings(),
          d = Pi(ce(p || 0));
        return Ae.resolve(`${s} wasn't used for last ${d}h (${i})`);
      }
      if (t?.isSemiActive) return Ae.reject("Tab is visible in window");
      if (e.hadFormInteraction) return Ae.reject("Tab has dirty forms");
      let n = this.discarderSettings?.minutesBeforeDiscard || 0;
      return Ae.resolve(`Last access more than ${n}min ago (${i})`);
    }
    shouldBeDiscarded(e, t, r) {
      return this.discarderSettings?.enabled
        ? t?.wasActivatedAt
          ? !this.getIsServiceTab(e) && !this.getIsSite(e)
            ? Ae.reject("Tab isn't recognized as site or service")
            : this.connectionService.getSaveData()
            ? Ae.reject("Device has save data mode")
            : this.connectionService.getIsOnline()
            ? r
            : Ae.reject("Device has offline mode")
          : Ae.reject("Tab isn't be active yet")
        : Ae.reject("Discarding is turned off");
    }
    async infoForDiscardModel(e, t, r, i) {
      let s = await this.browserService.getLastFocusedWindowId(),
        a = this.getOpenRank(e.id),
        n = this.tabs.length,
        p = e.discarded,
        d = e.active && e.windowId === s,
        u = t?.isSemiActive ?? !1,
        m = this.getIsSite(e),
        y = this.getIsServiceTab(e),
        b = this.getIsMessengerApp(e),
        v = e.pinned,
        S = e.audible || !1,
        w = e.hadFormInteraction ?? !1,
        T = (t?.audibleInLastDomain.length ?? 0) > 0,
        I = this.domainIsInWhitelist(e),
        {
          all: k = 0,
          week: _ = 0,
          month: O = 0,
        } = this.domainsStatistic[t?.hostname || ""] || {},
        {
          all: E = 0,
          week: f = 0,
          month: j = 0,
        } = (await this.searchService.domainStatistic.getUrlStatistic({
          hostname: t?.hostname || "",
          url: e.pendingUrl || e.url || "",
          partitionId: e.partitionName || "",
        })) || {};
      return {
        openRank: a,
        tabsCount: n,
        isDiscarded: p,
        canBeDiscarded: r,
        isActive: d,
        isSemiActive: u,
        isSite: m,
        isServiceTab: y,
        isMessagingApp: b,
        isPinned: v,
        isAudible: S,
        hasDirtyForms: w,
        hasBeenPlayedOnce: T,
        hasDiscardableDomain: I,
        lastAccessSecondsAgo: Fo(i, t?.wasActivatedAt ?? null) || 1 / 0,
        lastDomainChangeSecondsAgo:
          Fo(i, t?.tabHostnameChangedAt ?? null) || 1 / 0,
        lastAudibleSecondsAgo: Fo(i, t?.wasAudibleAt ?? null) || 1 / 0,
        totalAllOpensInCurrentDomain: k || 0,
        totalMonthOpensInCurrentDomain: O || 0,
        totalWeekOpensInCurrentDomain: _ || 0,
        totalAllOpens: E || 0,
        totalMonthOpens: j || 0,
        totalWeekOpens: f || 0,
        opensInLastHour: this.getCountMoreThan(
          t?.tabActivations ?? [],
          i - xe(1)
        ),
        opensInToday: this.getCountMoreThan(t?.tabActivations ?? [], i - pt(1)),
        opensInLastWeek: this.getCountMoreThan(
          t?.tabActivations ?? [],
          i - $s(1)
        ),
        opensInLastDomainInLastHour: this.getCountMoreThan(
          t?.tabActivationsInLastDomain ?? [],
          i - xe(1)
        ),
        opensInLastDomainInToday: this.getCountMoreThan(
          t?.tabActivationsInLastDomain ?? [],
          i - pt(1)
        ),
        opensInLastDomainInLastWeek: this.getCountMoreThan(
          t?.tabActivationsInLastDomain ?? [],
          i - $s(1)
        ),
        audibleInLastDomainInLastHour: this.getCountMoreThan(
          t?.audibleInLastDomain ?? [],
          i - xe(1)
        ),
        audibleInLastDomainInToday: this.getCountMoreThan(
          t?.audibleInLastDomain ?? [],
          i - pt(1)
        ),
        audibleInLastDomainInLastWeek: this.getCountMoreThan(
          t?.audibleInLastDomain ?? [],
          i - $s(1)
        ),
      };
    }
    async getDecision(e) {
      let t = Date.now(),
        r = this.tabInfoFollowerService.getTabInfoById(e.id),
        i = this.canBeDiscarded(e, r, t);
      if (
        i.value &&
        this.getIsNeedToBeForceDiscarded(t, r?.wasActivatedAt ?? null)
      )
        return i;
      let s = this.shouldBeDiscarded(e, r, i);
      if (!s.value) return s;
      let a = await this.infoForDiscardModel(e, r, i.value, t),
        n = this.getModelSettings();
      try {
        if (!n.model)
          throw new L(
            "ML-model isn't defined - do nothing, run fallback discarding mechanism",
            { isSilent: !0, level: "warning" }
          );
        let { threshold: p } = n;
        if (typeof p != "number" || p < 0 || p > 1)
          throw new TypeError(
            `Please provide correct threshold! Current value: ${p || 0}`
          );
        let [d = 1 / 0] = await ub({
          version: Ae.MODEL_VERSION,
          model: n.model,
          fields: Object.keys(a),
          records: [Object.values(a)],
        });
        return d < p
          ? Ae.resolve(
              `Discard tab because model ${d} less than threshold < ${p}`
            )
          : Ae.reject(
              `Tab is still alive because model ${d} more than threshold > ${p}`
            );
      } catch (p) {
        return (
          p && l(p),
          a.openRank <= 4
            ? { value: !1, reason: `Tab has open rank ${a.openRank} <= 4` }
            : s
        );
      }
    }
    getModelSettings() {
      let { tabsDiscarder2: e } = this.featureFlagsRepository.getFeatureFlags();
      return {
        useModel: !0,
        threshold: e[`threshold_v${Ae.MODEL_VERSION}`] ?? null,
        model: e[`model_v${Ae.MODEL_VERSION}`] ?? "",
        forceDiscardAfterSeconds: e.forceDiscardAfterSeconds,
        whitelistKeepSeconds: e.whitelistKeepSeconds,
      };
    }
    async checkAllTabs() {
      if (!this.discarderSettings?.enabled) return;
      let e = Object.values(await this.browserService.getTabsById()),
        t = await this.browserService.getAllProcesses();
      (this.tabs = e),
        (this.splitState = await this.browserService.getSplitState()),
        await Promise.all(
          e.map(async (r) => {
            let { value: i, reason: s } = await this.getDecision(r);
            if (!r.id) return;
            let a =
                t.find(
                  (p) =>
                    p.type === tn.RENDERER &&
                    p.tasks.some((d) => d.tabId === r.id)
                ) ?? null,
              n = a
                ? Math.max(
                    a?.privateMemory ||
                      0 / a.tasks.filter((p) => "tabId" in p).length,
                    0
                  )
                : 0;
            (i || !r.discarded) &&
              (this.checkResultsByTabId[r.id] = {
                memoryBeforeDiscard: i ? n : 0,
                lastReason: s,
              }),
              i &&
                (this.logger.info(`Discarding tab. Reason: ${s}. Tab: `, r),
                await this.browserService.discardTabById(r.id));
          })
        ),
        (this.tabs = []),
        (this.splitState = Xk);
    }
  },
  Ss = Ae;
lr(Ss, "MODEL_VERSION", 1);
c();
var FF = 0,
  MF = 8,
  xF = 16,
  WF = 4278190080,
  DF = 255,
  UF = 186,
  OF = 0.299,
  jF = 0.587,
  NF = 0.114,
  vo = class {
    constructor(e, t) {
      this.browserService = e;
      this.browserEventsService = t;
      this.browserEventsService.subscribeToChromeThemeChanged(
        this.setChromeTheme.bind(this)
      );
    }
    theme = "auto";
    chromeTheme = null;
    emitter = new A();
    logger = x.createInstance("theme");
    static async build(e, t) {
      let r = new vo(e, t);
      return await r.loadTheme(), r;
    }
    onThemeChanged(e) {
      return this.emitter.on("theme-changed", e);
    }
    getTheme() {
      return this.theme;
    }
    getChromeTheme() {
      return this.chromeTheme;
    }
    updateTheme(e) {
      return (
        (this.theme = e),
        this.emitter.emit("theme-changed"),
        this.browserService.saveIntoLocalBrowserStorage({ ["theme"]: e })
      );
    }
    getIsDarkThemeFromUIStorage() {
      return localStorage.getItem("theme") === "dark";
    }
    async loadTheme(e = !1) {
      try {
        this.theme = (await this.getThemeFromStorage()) ?? "auto";
      } catch (t) {
        if (e) throw t;
        (this.theme = "auto"),
          globalThis.setTimeout(() => {
            this.loadTheme(!0).catch(l);
          }, 150);
      }
      this.logger.info("Theme loaded", this.theme),
        this.emitter.emit("theme-changed");
    }
    setChromeTheme(e) {
      let t = (e >> xF) & 255,
        r = (e >> MF) & 255,
        i = (e >> FF) & 255,
        s = ((e >> WF) & 255) / DF,
        a = { red: t, green: r, blue: i, alpha: s };
      (this.chromeTheme = {
        ...a,
        isLight: this.detectIsLightThemeUsingNTSCFormula(a),
      }),
        this.emitter.emit("theme-changed");
    }
    detectIsLightThemeUsingNTSCFormula(e) {
      return OF * e.red + jF * e.green + NF * e.blue > UF;
    }
    async getThemeFromStorage() {
      return (await this.browserService.getFromLocalBrowserStorage("theme"))?.[
        "theme"
      ];
    }
  };
c();
var Zk = "sidekick.hide_toolbar_icon_by_default",
  tu = class {
    constructor(e) {
      this.browserService = e;
      this.loadPref().catch(l);
    }
    isHideOnHoverEnabled = !0;
    getIsHoverEnabled() {
      return this.isHideOnHoverEnabled;
    }
    handleHoverEnabledChanges(e) {
      return (
        (this.isHideOnHoverEnabled = e), this.browserService.setPref(Zk, e)
      );
    }
    async loadPref() {
      this.isHideOnHoverEnabled = (await this.browserService.getPref(Zk)).value;
    }
  };
c();
var LF = 7,
  ru = class {
    constructor(e, t, r, i) {
      this.modalService = e;
      this.featureFlagsRepository = t;
      this.browserStorage = r;
      this.actualUsageDaysRepository = i;
      this.featureFlagsRepository.onFeatureFlagsLoaded((s) => {
        !s.isVerticalModalEnabled ||
          !s.verticalTabsEnabled ||
          (this.tryShowVerticalTabsModal().catch(l),
          this.checkVerticalTabsBannerCondition().catch(l));
      });
    }
    shouldShowVerticalTabsBanner = !1;
    emitter = new A();
    onBannerVisibilityChanged(e) {
      return this.emitter.on("banner-visibility-changed", e);
    }
    isVerticalTabsBannerVisible() {
      return this.shouldShowVerticalTabsBanner;
    }
    hideVerticalTabsBanner() {
      (this.shouldShowVerticalTabsBanner = !1),
        this.emitter.emit("banner-visibility-changed"),
        this.saveBannerAsShowed();
    }
    async checkVerticalTabsBannerCondition() {
      if (
        (await this.browserStorage.getItem("vertical_tabs_banner_showed")) ||
        this.isFirstDateOfUsage()
      )
        return;
      let t = await this.browserStorage.getItem(
          "vertical_tabs_banner_date_of_showing"
        ),
        r = Date.now();
      if (t && Zs(r, new Date(t)) >= LF) {
        this.saveBannerAsShowed();
        return;
      }
      this.updateShouldShowVerticalTabsBanner(!0),
        this.browserStorage
          .setItem("vertical_tabs_banner_date_of_showing", r)
          .catch(l);
    }
    updateShouldShowVerticalTabsBanner(e) {
      (this.shouldShowVerticalTabsBanner = e),
        this.emitter.emit("banner-visibility-changed");
    }
    isFirstDateOfUsage() {
      return (this.actualUsageDaysRepository.getCount() ?? 0) <= 1;
    }
    saveBannerAsShowed() {
      this.browserStorage.setItem("vertical_tabs_banner_showed", !0).catch(l);
    }
    async tryShowVerticalTabsModal() {
      let e = await this.browserStorage.getItem("vertical_tabs_modal_showed");
      this.isFirstDateOfUsage() ||
        e ||
        (this.modalService.showVerticalTabsModal({}).catch(l),
        this.browserStorage.setItem("vertical_tabs_modal_showed", !0).catch(l));
    }
  };
c();
c();
c();
var eT = async (o) => {
  if (!o) return null;
  let t = await (await fetch(o)).blob();
  return g(t, "Failed to load blob: no blob"), t;
};
c();
var GF = (o) => {
    let e = o.endsWith("/") ? o : `${o}/`;
    return (t) => {
      if (!t) return e;
      let r = t;
      return (
        t.startsWith("/")
          ? (r = r.slice(1))
          : t.startsWith("./") && (r = r.slice(2)),
        `${e}${r}`
      );
    };
  },
  _t = (o, e) => {
    let t = GF(o);
    return e ? t(e) : "";
  };
var _y = "https://sidekick-cdn-production.meetsidekick.com/videos";
var HF = { 1: "meta.json", 2: "meta-v2.json" },
  iu = class {
    constructor(e, t) {
      this.videosStore = e;
      this.featureFlagsRepository = t;
      (this.videoUrl = ""),
        this.featureFlagsRepository.onFeatureFlagsLoaded((r) => {
          this.loadStored({ version: r.enableExploreSidekickV2 ? 2 : 1 }).catch(
            l
          );
        });
    }
    videosReadyToUse;
    videoUrl;
    emitter = new A();
    getVideos() {
      return this.videosReadyToUse;
    }
    getVideoUrl() {
      return this.videoUrl;
    }
    onVideosUpdate(e) {
      return this.emitter.on("videos-update", e);
    }
    getVideoData(e) {
      switch (e.id) {
        case "app-settings":
          return { appSettings: e };
        case "p2p-sharing":
          return { p2pSharing: e };
        case "tab-switcher":
          return { tabSwitcher: e };
        default:
          return { [e.id]: e };
      }
    }
    convertVideoRecords(e) {
      return e.reduce((t, r) => ({ ...t, ...this.getVideoData(r) }), {});
    }
    async loadStored(e = { version: 1 }) {
      let t = this.convertVideoRecords(await this.videosStore.getAll());
      return (
        Xs(t) || (this.videosReadyToUse = t), this.fetchBundledVideos(e.version)
      );
    }
    async fetchBundledVideos(e) {
      let t = new Request(_t(_y, HF[e])),
        r = await fetch(t),
        s = (await je(r, t)).map((n) => ({
          ...n,
          preview: _t(_y, n.preview),
          video: _t(_y, n.video),
        })),
        a = await Promise.all(
          s.map(
            async (n) => (
              g(n.id, "VideoItem must have an id to be processed"),
              {
                id: n.id,
                version: n.version,
                previewUrl: n.preview,
                previewBlob: await eT(n.preview),
                videoUrl: n.video,
              }
            )
          )
        );
      return (
        await Promise.all(a.map((n) => this.videosStore.put(n.id, n))),
        (this.videosReadyToUse = this.convertVideoRecords(a)),
        this.emitter.emit("videos-update"),
        this.videosReadyToUse
      );
    }
  };
c();
var ws = "/shared/assets/wallpapers",
  ou = class {
    constructor(e, t, r) {
      this.wallpaperStore = e;
      this.backendService = t;
      this.themeService = r;
    }
    async loadStored() {
      let e = await this.wallpaperStore.getAll();
      return e.length ? e : this.loadFromBundle();
    }
    async loadFromBackend() {
      let e = (await this.backendService.extension.getWallpapers()).map(
          (a) => (
            g(
              a.id,
              "Loading wallpaper from backend failed: dto does not have an id"
            ),
            {
              id: a.id,
              groupId: a.group_id,
              author: a.author,
              originalUrl: a.original_url,
              thumbnailUrl: a.thumbnail_url,
              imageNormalUrl: a.image_url,
              image4KUrl: a.image_4k_url,
            }
          )
        ),
        t = new Map((await this.wallpaperStore.getAll()).map((a) => [a.id, a])),
        { deletedIds: r, notModified: i, updated: s } = this.syncInfo(t, e);
      return [...i, ...(await this.processModified(s, r))];
    }
    getWallpaperBlob(e, t) {
      let r =
        this.getImageUrlKey(e, t) === "imageNormalUrl"
          ? "imageNormalBlob"
          : "image4KBlob";
      return e[r];
    }
    async loadImage(e, t) {
      let r = this.getImageUrlKey(e, t);
      if (e[r] === e.thumbnailUrl) return e.thumbnailBlob;
      let i = r === "imageNormalUrl" ? "imageNormalBlob" : "image4KBlob",
        s = await this.loadBlob(e[r]);
      return (
        await this.wallpaperStore.put(`${e.id}`, { ...e, [i]: s }).catch(l), s
      );
    }
    getImageUrlKey({ image4KUrl: e, imageNormalUrl: t }, r) {
      return !r && t ? "imageNormalUrl" : e ? "image4KUrl" : "imageNormalUrl";
    }
    syncInfo(e, t) {
      let r = [];
      return {
        updated: t.reduce((s, a) => {
          let { id: n } = a,
            p = e.get(n);
          return (
            p
              ? (this.allFieldsMatch(p, a) ? r.push(p) : s.push(a), e.delete(n))
              : s.push(a),
            s
          );
        }, []),
        notModified: r,
        deletedIds: [...e.keys()],
      };
    }
    async processModified(e, t) {
      let r = [];
      return (
        await Promise.all(
          e.map(async (i) => {
            try {
              let s = {
                ...i,
                groupId: i.groupId ?? 0,
                thumbnailBlob: await this.loadBlob(i.thumbnailUrl),
                imageNormalBlob: null,
                image4KBlob: null,
              };
              await this.wallpaperStore.put(`${s.id}`, s), r.push(s);
            } catch (s) {
              l(s);
            }
          })
        ),
        t.map((i) => this.wallpaperStore.remove(`${i}`).catch(l)),
        r
      );
    }
    async loadFromBundle() {
      let e = new Request(_t(ws, "meta.json")),
        t = await fetch(e),
        r = await je(t, e),
        i = this.themeService.getIsDarkThemeFromUIStorage(),
        s = r.filter((n) => n.image_4k_url.includes(i ? "dark" : "light")),
        a = await Promise.all(
          s.map(
            async (n) => (
              g(n.id, "Loading wallpaper from bundle failed: no wallpaper id"),
              {
                id: n.id,
                groupId: 1,
                author: n.author,
                originalUrl: n.original_url,
                thumbnailUrl: _t(ws, n.thumbnail_url),
                thumbnailBlob: await this.loadBlob(_t(ws, n.thumbnail_url)),
                imageNormalUrl: _t(ws, n.image_url),
                imageNormalBlob: null,
                image4KUrl: _t(ws, n.image_4k_url),
                image4KBlob: null,
              }
            )
          )
        );
      return (
        await Promise.all(a.map((n) => this.wallpaperStore.put(`${n.id}`, n))),
        a
      );
    }
    async loadBlob(e) {
      g(e, "Failed to load thumbnail blob: no url provided");
      let r = await (await fetch(e)).blob();
      return g(r, "No blob when loading thumbnail"), r;
    }
    allFieldsMatch(e, t) {
      return Object.keys(t).every((r) => e[r] === t[r]);
    }
  };
c();
var ks = [
  {
    id: 115,
    author: "",
    original_url: "",
    thumbnail_url: "./background_light.svg",
    image_4k_url: "./background_light.svg",
  },
  {
    id: 113,
    author: "",
    original_url: "",
    thumbnail_url: "./background_dark.svg",
    image_4k_url: "./background_dark.svg",
  },
];
var su = class {
  constructor(e, t, r, i, s, a) {
    this.browserStorage = e;
    this.userSettingsRepository = t;
    this.userApi = r;
    this.wallpapersStore = i;
    this.wallpaperLoaderService = s;
    this.themeService = a;
    this.loadWallpapers().catch(l),
      setInterval(() => {
        this.rotateWallpaper(!1).catch(l);
      }, ye(60));
  }
  wallpaperIdsForRotation = [];
  currentWallpaper = null;
  gradientsThumbnails = [];
  mainThumbnails = [];
  emitter = new A();
  onWallpaperChanged(e) {
    return this.emitter.on("wallpaper-changed", e);
  }
  onThumbnailsLoaded(e) {
    return this.emitter.on("thumbnails-loaded", e);
  }
  getCurrentWallpaper() {
    return this.currentWallpaper;
  }
  getDefaultWallpaper() {
    let e = "/shared/assets/wallpapers",
      r = this.themeService.getIsDarkThemeFromUIStorage() ? ks[1] : ks[0];
    return r
      ? {
          blur: !1,
          author: r.author,
          originalUrl: r.original_url,
          groupId: 0,
          url: _t(e, r.image_4k_url),
          thumbnailUrl: _t(e, r.thumbnail_url),
        }
      : null;
  }
  getThumbnails() {
    return this.mainThumbnails;
  }
  getGradients() {
    return this.gradientsThumbnails;
  }
  updateCurrentWallpaper() {
    return this.processLoadedWallpapers();
  }
  async rotateWallpaper(e) {
    let { preferredWallpaperId: t, rotateWallpapersEnabled: r } =
      this.userSettingsRepository.getSettings();
    if (!t) return;
    let i = new Date(),
      s = this.currentWallpaper?.groupId !== 0,
      a = await this.shouldRotateByDate(i),
      n = this.getNeededWallpaperId(t, a, s);
    ((!s && a && r) || e) &&
      (await this.browserStorage.setItem("wallpaper-info", {
        updatedAt: i.valueOf(),
      }),
      this.userApi.changePreferredWallpaperSettings(n, !0),
      await this.processLoadedWallpapers());
  }
  getNeededWallpaperId(e, t, r) {
    return r ? 1 : t ? this.findNextId(e) : e;
  }
  findNextId(e) {
    let t = this.wallpaperIdsForRotation.indexOf(e),
      r = this.wallpaperIdsForRotation[t + 1];
    return r || r === 0 ? r : this.wallpaperIdsForRotation[0] ?? e;
  }
  async shouldRotateByDate(e) {
    let t = await this.browserStorage.getItem("wallpaper-info");
    return !t?.updatedAt || new Date(t.updatedAt).getDate() !== e.getDate();
  }
  async loadWallpapers() {
    this.setWallpapers(await this.wallpaperLoaderService.loadStored()),
      await this.processLoadedWallpapers(!1),
      this.setWallpapers(await this.wallpaperLoaderService.loadFromBackend()),
      this.currentWallpaper || (await this.processLoadedWallpapers());
  }
  setWallpapers(e) {
    (this.wallpaperIdsForRotation = e
      .filter(({ groupId: t }) => t === 0)
      .map(({ id: t }) => t)),
      this.setThumbnails(e);
  }
  async processLoadedWallpapers(e = !0) {
    let t = this.getPreferredWallpaperId();
    if (t === null) return;
    let r = await this.wallpapersStore.get(`${t}`);
    if (r) {
      this.changeWallpaper(r);
      return;
    }
    e &&
      (await this.browserStorage.removeItem("wallpaper-info"),
      this.userApi.changePreferredWallpaperSettings(null),
      this.setCurrentWallpaper(null));
  }
  changeWallpaper(e) {
    let t = this.is4kPreferred(),
      r = this.wallpaperLoaderService.getWallpaperBlob(e, t),
      { thumbnailBlob: i, author: s, groupId: a, originalUrl: n } = e;
    r
      ? this.setCurrentWallpaper({
          blob: r,
          thumbnailBlob: i,
          blur: !1,
          author: s,
          groupId: a,
          originalUrl: n,
        })
      : (this.setCurrentWallpaper({
          blob: i,
          thumbnailBlob: i,
          blur: !0,
          author: s,
          groupId: a,
          originalUrl: n,
        }),
        this.scheduleImageLoading(e, t).catch(l));
  }
  getPreferredWallpaperId() {
    let { preferredWallpaperId: e, rotateWallpapersEnabled: t } =
      this.userSettingsRepository.getSettings();
    if (t && e === null) {
      let r = this.findNextId(0);
      return this.userApi.changePreferredWallpaperSettings(r), r;
    }
    if (!e) {
      let r = this.themeService.getIsDarkThemeFromUIStorage(),
        i = ks.find((a) => a.image_4k_url.includes("light"))?.id ?? null,
        s = ks.find((a) => a.image_4k_url.includes("dark"))?.id ?? null;
      return r ? s : i;
    }
    return e;
  }
  is4kPreferred() {
    return window.devicePixelRatio > 1.3;
  }
  async scheduleImageLoading(e, t) {
    let r = await this.wallpaperLoaderService.loadImage(e, t);
    this.setCurrentWallpaper({
      blob: r,
      thumbnailBlob: e.thumbnailBlob,
      blur: !1,
      author: e.author,
      groupId: e.groupId,
      originalUrl: e.originalUrl,
    });
  }
  setCurrentWallpaper(e) {
    if (
      (this.currentWallpaper &&
        (URL.revokeObjectURL(this.currentWallpaper.url),
        URL.revokeObjectURL(this.currentWallpaper.thumbnailUrl),
        (this.currentWallpaper = null)),
      e)
    ) {
      let {
        blob: t,
        thumbnailBlob: r,
        blur: i,
        author: s,
        groupId: a,
        originalUrl: n,
      } = e;
      this.currentWallpaper = {
        url: URL.createObjectURL(t),
        thumbnailUrl: URL.createObjectURL(r),
        blur: i,
        author: s,
        groupId: a,
        originalUrl: n,
      };
    }
    this.emitter.emit("wallpaper-changed");
  }
  setThumbnails(e) {
    let t = new Map();
    this.mainThumbnails.forEach(({ id: i, url: s }) => t.set(i, s)),
      this.gradientsThumbnails.forEach(({ id: i, url: s }) => t.set(i, s));
    let r = e.map((i) => {
      let { id: s, groupId: a, thumbnailBlob: n } = i,
        p = t.has(s) ? t.get(s) : URL.createObjectURL(n);
      return t.delete(s), { id: s, groupId: a, url: p };
    });
    t.forEach((i) => URL.revokeObjectURL(i)),
      (this.mainThumbnails = r.filter(({ groupId: i }) => i === 0)),
      (this.gradientsThumbnails = r.filter(({ groupId: i }) => i === 1)),
      this.emitter.emit("thumbnails-loaded");
  }
};
c();
var au = class {
  constructor(e, t, r) {
    this.browserService = e;
    this.tabInfoFollowerService = r;
    t.subscribeToTabCreated((i) => {
      !i.id ||
        !this.isZoomTab(i) ||
        (this.zoomTabIds.add(i.id), this.scheduleNextRun());
    }),
      t.subscribeToTabUpdated((i, s, a) => {
        this.isZoomTab(a)
          ? (this.zoomTabIds.add(i), this.scheduleNextRun())
          : this.zoomTabIds.delete(i);
      }),
      t.subscribeToTabRemoved((i) => {
        this.zoomTabIds.delete(i);
      }),
      this.loadZoomTabIds()
        .then(() => this.run())
        .catch(l);
  }
  zoomTabIds = new Set();
  nextRunTimer = null;
  async loadZoomTabIds() {
    let e = await this.browserService.getAllTabs();
    this.zoomTabIds.clear(),
      e.forEach((t) => {
        !t?.id || !this.isZoomTab(t) || this.zoomTabIds.add(t.id);
      });
  }
  run() {
    let e = Date.now();
    this.zoomTabIds.forEach((t) => {
      let r = this.tabInfoFollowerService.getTabInfoById(t);
      r &&
        (r.isFullActive ||
          r.isSemiActive ||
          (r.wasActivatedAt !== null && e - r.wasActivatedAt < ce(10)) ||
          (this.zoomTabIds.delete(t),
          this.browserService.closeTab(t).catch(l)));
    }),
      this.scheduleNextRun();
  }
  scheduleNextRun() {
    this.nextRunTimer ||
      !this.zoomTabIds.size ||
      (this.nextRunTimer = setTimeout(() => {
        (this.nextRunTimer = null), this.run();
      }, ce(15)));
  }
  isZoomTab(e) {
    let { url: t } = e,
      r = Gt(t);
    return r
      ? r.hostname.endsWith("zoom.us") &&
          ["/j/", "/s/", "/postattendee"].some((i) => r.pathname.startsWith(i))
      : !1;
  }
};
var tT = async () => {
  let o = Date.now();
  x.loadInstancesFromStorage().catch(l);
  let [e, t] = await ho.build(me.SENTRY_DSN || "", {
      environment: me.NODE_ENV,
      version: ca(),
      type: "background",
    }),
    r = new nn(e.sentry),
    i = Date.now(),
    s = r.start({ ...Rb.START_TRX, startTimestamp: Ue(o) }),
    a = qm(s, Ee.INIT_SERVICES, o),
    n = a.startChild(Ee.BROWSER),
    p = new Cp(r),
    d = await no.build(p),
    u = new _p(d),
    [m, y, b] = await Promise.all([
      po.build(p, d),
      co.build(p, d),
      vo.build(p, d),
    ]),
    v = new on(p),
    S = new Ja(p, v),
    w = new Wp(p);
  p.closeAllOverlays().catch(fe),
    p.closeAllPopups().catch(fe),
    p.notifyExtensionReady();
  let { wallpaperStore: T, applicationLocalStore: I, videoStore: k } = tb();
  n.finish();
  let _ = a.startChild(Ee.AUTH),
    O = new Ip(p, d),
    E = await so.build(O, p);
  if (O.getIsAfterOnboarding()) {
    let $r = Date.now(),
      Ls = [n, _];
    mv([s, a, ...Ls], $r), hv(Ls, $r), zm(s, "is-from-onboarding");
  } else {
    let $r = sn(a, Ee.SENTRY, o, i);
    sn($r, Ee.SENTRY_BUILD_GET_PREF, o, t.getIsSidekickTeam),
      sn(
        $r,
        Ee.SENTRY_BUILD_GET_CONFIG,
        t.getIsSidekickTeam,
        t.getSentrySamplingConfig
      );
  }
  _.finish();
  let { browserStorage: f, storageReport: j } = await zk(p, d, E, a);
  rr(s, "storage", sa(j.sizeInBytes), "megabyte");
  let ue = a.startChild(Ee.SYSTEM_INFO),
    Q = await go.build(p, f, O);
  e.setBrowserVersion(Q.browserVersion),
    e.setOsInfo(Q.os.name, Q.os.version),
    ue.finish(),
    new xp(d, p, E);
  let C = await bo.build(p, d, f);
  Hb();
  let G = new an(r, s, p),
    K = a.startChild(Ee.REPOSITORIES),
    [B, X, ie, Z, ve, Qe, St, wt, kt, Me] = await xS(f);
  ie.getIsLoadedFromCache() && zm(s, "is-from-cache"), K.finish();
  let Ye = new rd(f),
    { fetch: Jt, originalFetch: ar, retryApi: Ke } = tw(f),
    fo = me.SIDEKICK_API || "",
    nu = new Bp(Q, r, fo, Jt, E),
    N = new Qa(nu),
    Ts = new ql(f, N),
    Is = new Gp(Ke),
    {
      teamNotificationsService: cu,
      userNotificationsService: pu,
      eventSourceManager: As,
    } = fw(E);
  new ol(B, N, Ye, Ts);
  let lu = new tu(p),
    nr = new jp(p, d, y, Z, w),
    Lt = new Pc(Ts, pu, cu, B, As);
  e.subscribeToFeatureFlags(B);
  let ne = new hp(E, e.sentry, f, Q, {
    fetch: ar,
    firehose: { endpoint: me.FIREHOSE_DSN || "" },
    storageReport: j,
  });
  new yp(d, ne, B, p), new fp(p, d, Ye, ne, f);
  let Or = await p.getAllNormalWindows(!0),
    du = s.startChild(Ee.DOMAIN_USER),
    [mt, Ft, Zt] = FS(f, Q, N, p, Ye, ne, d, B, Z, ve, E);
  du.finish();
  let Si = new Jd(p, d),
    uu = s.startChild(Ee.DOMAIN_APPS),
    {
      applicationRepository: Xe,
      applicationService: Ps,
      applicationsActivationService: mu,
      recipesRepository: jr,
      accountRepository: cr,
      accountService: Rs,
      onboardingAppsService: hu,
      splitViewService: ht,
      runningApplicationsObserver: wi,
    } = await TS(p, w, Lt, f, d, B, ne, I, N, ie, X, Or);
  uu.finish();
  let Le = new Il(p, v, S, d),
    So = new Pp(p, d, E, Q, b, Zt, B, mt, ve, Le, ne, me.SIDEKICK_APP || ""),
    Nr = new zp(p, d);
  new dn(p, B, ve, E);
  let ki = new en(f, N),
    Lr = new rn(Xe, p, jr, Z, B, nr, C, d),
    Tt = new ip(Ft, mt, Z, Lr, p),
    Je = new Yl(p, d, Z),
    er = new un(Je, p, d),
    It = AS({
      accountRepository: cr,
      analytics: ne,
      applicationRepository: Xe,
      backendService: N,
      billingPlansRepository: wt,
      billingRepository: X,
      billingUrl: me.SIDEKICK_BILLING_PAGE ?? "",
      browserEventsService: d,
      browserService: p,
      browserStorage: f,
      featureFlagsRepository: B,
      invitationsRepository: kt,
      modalService: Le,
      notificationManager: er,
      notificationsExperimentalLayer: Lt,
      popupService: Je,
      recipesRepository: jr,
      signUpService: So,
      userApi: Tt,
      userRepository: ve,
      userSettingsRepository: Z,
      workspaceRepository: ie,
      sessionRepository: Me,
      actualUsageDaysRepository: Zt,
    });
  new ya(er, B, p, f, d, It, Tt, O);
  let yu = s.startChild(Ee.DOMAIN_WORKSPACES),
    bu = await qi.build(ie, ne, N, p, w, Lt, d);
  yu.finish();
  let gu = new Pd(),
    Ti = new Cd(p, B, d, gu, ne),
    vu = s.startChild(Ee.DOMAIN_SESSIONS),
    Gr = await CS({
      analyticsTracker: ne,
      backendService: N,
      browserEventsService: d,
      browserService: p,
      browserStorage: f,
      encryptionService: ki,
      extraDataService: w,
      featureFlagsRepository: B,
      onboardingDataService: O,
      sessionRepository: Me,
      tabStripObserver: y,
      userRepository: ve,
      windowHeadlessService: nr,
      workspaceRepository: ie,
      userApi: Tt,
      openWindows: Or,
      billingRepository: X,
      billingApi: It,
      sidecarAppearanceService: Ti,
    }),
    Es = Me.getSessionsArray(),
    fu = Es.reduce(($r, Ls) => $r + Ls.tabsOrder.length, 0);
  rr(s, "sessions", Es.length),
    rr(s, "tabs", fu),
    rr(s, "windows", Or.length),
    vu.finish();
  let wo = new iu(k, B),
    ko = new ba(f, ki),
    Bs = new Fa(ko, ki, N, Lt),
    Su = new Ma(Bs, ko),
    wu = new wp(N, E, Lt, Xe, f);
  new xr(p, d, Xe, ki, wu, u);
  let To = new Xl(Je, d),
    Cs = new mn(er, d, p, b);
  ht.setupSplitView(It), new cn(d);
  let Ar = new gc(mu, Ps, hu, ie, It, Rs, cr, Xe, wi, p, ne, X),
    Io = new cp(Ar, ie, bu, It, Gr, Le, ne, d);
  new Ap(O, Ar, N);
  let ku = new Al(),
    Hr = new ud(p, f, d, B, Ar, Xe, ie, ku, jr, cr, Si, wi, w, Ye),
    Tu = new Ya(p);
  new Kp(p, d, Xe, Ps, cr, w, Rs, Lr, Hr, ne, Tu);
  let Ao = _S(p, N, ie, Le, f, ne, Lt, Qe, St),
    [Vr, _s, Iu, Fs] = PS(N, Lt, B, p, ie, Hr, d, Ao, f, Le, Zt, Me),
    pr = new _d(p, f, B, d, Vr, Ti),
    [Ms, Po, xs] = mw({
      analytics: ne,
      browserStorage: f,
      featureFlagsRepository: B,
      invitationsRepository: kt,
      modalService: Le,
      popupService: Je,
      collectionsRepository: Vr,
    }),
    Ws = new Rn(O, p, Le, pr, f, Je, ie, Xe, d, B, ne, Po);
  new Pn(p, Je, Ws, Z, Po);
  let Au = new ou(T, N, b),
    Pu = new su(f, Z, Tt, T, Au, b),
    Ds = new Zd(p, w, d, Le, Z),
    Us = new ed(Gr, Me, ie, It),
    { api: Ro, repository: rT } = Sw({
      analyticsTracker: ne,
      browserEventsService: d,
      browserService: p,
      browserStorage: f,
      featureFlagsRepository: B,
      focusModeService: Lr,
      popupService: Je,
      userApi: Tt,
      userSettingsRepository: Z,
    }),
    iT = s.startChild(Ee.SHORTCUTS),
    Os = await yo.build(
      Q,
      p,
      Le,
      Je,
      pr,
      Ds,
      ht,
      Us,
      Ar,
      B,
      ne,
      d,
      f,
      Lr,
      Z,
      C,
      Ro
    );
  iT.finish(), new Xp(p, ne, f, B, d), new Jp(f, p, ne), new il(p, f, ne, B, d);
  let oT = new Zl(B, Z, p),
    sT = new up(p, Z, B, d, Je, Tt, X),
    aT = new tl(Le, p, d, B, O, Ft, Z),
    Fy = new Mp(Q, N, p, ne, d),
    Eo = new rl(f),
    nT = hw({
      actualUsageDaysRepository: Zt,
      analytics: ne,
      browserEventsService: d,
      browserService: p,
      browserStorage: f,
      featureFlagsRepository: B,
      focusModeService: Lr,
      runningApplicationsObserver: wi,
      shortcutService: Os,
      splitViewService: ht,
      uiHintsManager: To,
      userApi: Tt,
      userSettingsRepository: Z,
      windowHeadlessService: nr,
      applicationRepository: Xe,
    }),
    My = new md(p, B, d, ne, Le);
  new Ad(Z, ie, Xe, Me, Os, p, b, cr, d, xs, Eo, Fy, X, B, wi, My, Ti, Vr, Or),
    new gd(Je, Ar, Io, It, Gr, ne, Q, Eo, B, Xe, ie, pr, d),
    new Id(Le, Tt, pr, ne, Eo, It, Ro, Je, d, B, My);
  let xy = new eu(p, d, w),
    Wy = new Ss(Xe, p, d, Is, w, B, jr, Si, Hr, Z, xy),
    Dy = new Op(p, d, f),
    cT = new Up(p, d, Dy),
    Uy = new vp(Wy, cT, xy, Dy);
  new gp(Uy, Ye, ne), new au(p, d, Si), new sd(p, d, Hr, ne);
  let pT = new Xa(p, d, w, B, Z, f, S, ne, Si, Je),
    lT = new zl(Eo, B, f, Zt),
    Oy = new Zp(p, B, f, er, d, X, ne, Zt);
  new bp(p, N, ve, ne, Ye, Oy);
  let js = new kp(N, fo),
    jy = new Tp(fo),
    dT = s.startChild(Ee.EXTERNAL_AUTH),
    Ns = await ao.build(js, jy, f);
  dT.finish();
  let uT = new di(Le, js, jy, Ns),
    mT = new Gc(_s),
    hT = new qp(p, d, _s, Vr, B, Ao, Nr, To, ne),
    yT = new Yp(p, d, B, Nr, Cs, pr, ne);
  new Qp(Me, Gr, p, ie, ne, Nr, d);
  let bT = new ha(Fs),
    gT = new Np(B, Ns, js, Z, f, Le, er, p, d, O),
    vT = new sl(Ns, js, er, kt, B, Xe, cr, Z, f, Tt, X, ne),
    fT = new Jl(B, f, p, d, er),
    ST = new Lp(Os, Le, Je, ht, p, pr, Tt, B),
    wT = new Md(It, B, X, f, p, ne, d),
    kT = new ru(Le, B, f, Zt);
  new ln(d), new An(p, B, Q, Z);
  let TT = wS(
      gT,
      er,
      Le,
      Eo,
      Wy,
      p,
      xs,
      Ms,
      Po,
      Os,
      Q,
      wo,
      ie,
      Io,
      B,
      Hr,
      Tt,
      Z,
      b,
      Ws,
      pr,
      Ti,
      Je,
      ht,
      ne,
      Xe,
      sT,
      Pu,
      Is,
      Ar,
      Uy,
      Qe,
      E,
      Fy,
      ve,
      cr,
      lT,
      C,
      oT,
      jr,
      Gr,
      d,
      So,
      Me,
      Ds,
      Us,
      S,
      pT,
      Su,
      Bs,
      ko,
      mT,
      Fs,
      bT,
      Vr,
      Iu,
      Oy,
      Zt,
      It,
      X,
      ST,
      To,
      nT,
      Ro,
      rT,
      Cs,
      aT,
      fT,
      lu,
      uT,
      Ao,
      wT,
      Ns,
      kt,
      vT,
      yT,
      hT,
      kT
    ),
    IT = {
      enable: nr.enablePermanentHeadless.bind(nr),
      disable: nr.disablePermanentHeadless.bind(nr),
    };
  return (
    a.finish(),
    G.tryFinish().catch(l),
    {
      analytics: ne,
      sentryConfigurator: e,
      ...TT,
      windowTabObserver: m,
      headless: IT,
    }
  );
};
var $F = async () => {
  let o = await tT(),
    {
      adblockerPopupApi: e,
      addApplicationModalApi: t,
      analytics: r,
      applicationPopupApi: i,
      b2bModalApi: s,
      billingDetailsPopupApi: a,
      billingModalsApi: n,
      calendarModalApi: p,
      collectionModalApi: d,
      collectionsListApi: u,
      cpuMonitorPopupApi: m,
      exploreApi: y,
      globalSettingsApi: b,
      helpApi: v,
      hintsApi: S,
      launchpadApi: w,
      marketplaceModalApi: T,
      modalApi: I,
      notificationsApi: k,
      notificationsSettingsPopupApi: _,
      platformApi: O,
      pmfSurveyApi: E,
      popupApi: f,
      productHuntApi: j,
      quickSessionSwitcherPopupApi: ue,
      searchApi: Q,
      sessionContextMenuApi: C,
      sessionListApi: G,
      shareApplicationModalApi: K,
      sidecarApi: B,
      signUpModalApi: X,
      tabSwitcherModalApi: ie,
      themeApi: Z,
      upgradePlanModalApi: ve,
      walkthroughApi: Qe,
      windowTabObserver: St,
      workspaceEditModalApi: wt,
      workspaceManagementModalApi: kt,
    } = o,
    Me = $b({
      analytics: r,
      applicationPopupApi: i,
      b2bModalApi: s,
      billingDetailsPopupApi: a,
      exploreApi: y,
      helpApi: v,
      launchpadApi: w,
      modalApi: I,
      platformApi: O,
      pmfSurveyApi: E,
      popupApi: f,
      productHuntApi: j,
      searchApi: Q,
      shareApplicationModalApi: K,
      sidecarApi: B,
      signUpModalApi: X,
      themeApi: Z,
      walkthroughApi: Qe,
      windowTabObserver: St,
    }),
    Ye = Kb({
      addApplicationModalApi: t,
      billingModalsApi: n,
      modalApi: I,
      exploreApi: y,
      analytics: r,
      globalSettingsApi: b,
      marketplaceModalApi: T,
      platformApi: O,
      popupApi: f,
      searchApi: Q,
      cpuMonitorPopupApi: m,
      upgradePlanModalApi: ve,
      tabSwitcherModalApi: ie,
      b2bModalApi: s,
      shareApplicationModalApi: K,
      signUpModalApi: X,
      themeApi: Z,
      calendarModalApi: p,
      workspaceManagementModalApi: kt,
      workspaceEditModalApi: wt,
      collectionModalApi: d,
      collectionsListApi: u,
      walkthroughApi: Qe,
      sidecarApi: B,
    }),
    Jt = zb({
      analytics: r,
      b2bModalApi: s,
      collectionsListApi: u,
      exploreApi: y,
      helpApi: v,
      modalApi: I,
      platformApi: O,
      popupApi: f,
      sessionListApi: G,
      sidecarApi: B,
      themeApi: Z,
      walkthroughApi: Qe,
      sessionContextMenuApi: C,
    }),
    ar = qb({
      analytics: r,
      applicationPopupApi: i,
      cpuMonitorPopupApi: m,
      exploreApi: y,
      hintsApi: S,
      modalApi: I,
      notificationsApi: k,
      notificationsSettingsPopupApi: _,
      platformApi: O,
      popupApi: f,
      productHuntApi: j,
      quickSessionSwitcherPopupApi: ue,
      searchApi: Q,
      themeApi: Z,
      walkthroughApi: Qe,
      helpApi: v,
      globalSettingsApi: b,
      adblockerPopupApi: e,
      sessionContextMenuApi: C,
      sessionListApi: G,
    });
  Object.assign(globalThis, {
    ntpUIApi: Me,
    overlayUIApi: Ye,
    popupsUIApi: ar,
    services: o,
    sidecarUIApi: Jt,
  });
};
$F().catch(l);
/*! Bundled license information:

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/component/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/logger/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/app/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/app/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/app/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/app/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase/app/dist/esm/index.esm.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/messaging/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
   * in compliance with the License. You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under the License
   * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
   * or implied. See the License for the specific language governing permissions and limitations under
   * the License.
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/messaging/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
